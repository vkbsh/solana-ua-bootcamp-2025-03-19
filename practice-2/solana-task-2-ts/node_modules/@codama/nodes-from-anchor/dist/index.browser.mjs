// src/index.ts
import { visit as visit2 } from "@codama/visitors";

// src/defaultVisitor.ts
import { assertIsNode } from "@codama/nodes";
import {
  deduplicateIdenticalDefinedTypesVisitor,
  flattenInstructionDataArgumentsVisitor,
  getCommonInstructionAccountDefaultRules,
  rootNodeVisitor,
  setFixedAccountSizesVisitor,
  setInstructionAccountDefaultValuesVisitor,
  transformU8ArraysToBytesVisitor,
  unwrapInstructionArgsDefinedTypesVisitor,
  visit
} from "@codama/visitors";
function defaultVisitor() {
  return rootNodeVisitor((currentRoot) => {
    let root = currentRoot;
    const updateRoot = (visitor) => {
      const newRoot = visit(root, visitor);
      assertIsNode(newRoot, "rootNode");
      root = newRoot;
    };
    updateRoot(deduplicateIdenticalDefinedTypesVisitor());
    updateRoot(setFixedAccountSizesVisitor());
    updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));
    updateRoot(unwrapInstructionArgsDefinedTypesVisitor());
    updateRoot(flattenInstructionDataArgumentsVisitor());
    updateRoot(transformU8ArraysToBytesVisitor());
    return root;
  });
}

// src/v00/AccountNode.ts
import {
  accountNode,
  assertIsNode as assertIsNode2,
  bytesTypeNode as bytesTypeNode2,
  camelCase,
  fieldDiscriminatorNode,
  fixedSizeTypeNode,
  pdaLinkNode,
  structFieldTypeNode as structFieldTypeNode2,
  structTypeNode as structTypeNode2
} from "@codama/nodes";

// src/discriminators.ts
import { bytesValueNode, pascalCase, snakeCase } from "@codama/nodes";
import { sha256 } from "@noble/hashes/sha256";

// src/utils.ts
function hex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// src/discriminators.ts
var getAnchorDiscriminatorV01 = (discriminator) => {
  return bytesValueNode("base16", hex(new Uint8Array(discriminator)));
};
var getAnchorInstructionDiscriminatorV00 = (idlName) => {
  const hash = sha256(`global:${snakeCase(idlName)}`).slice(0, 8);
  return bytesValueNode("base16", hex(hash));
};
var getAnchorAccountDiscriminatorV00 = (idlName) => {
  const hash = sha256(`account:${pascalCase(idlName)}`).slice(0, 8);
  return bytesValueNode("base16", hex(hash));
};

// src/v00/typeNodes/ArrayTypeNode.ts
import {
  arrayTypeNode,
  fixedCountNode as fixedCountNode3,
  numberTypeNode as numberTypeNode6,
  prefixedCountNode as prefixedCountNode3,
  remainderCountNode as remainderCountNode3
} from "@codama/nodes";

// src/v00/typeNodes/TypeNode.ts
import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from "@codama/errors";
import {
  booleanTypeNode,
  bytesTypeNode,
  definedTypeLinkNode,
  numberTypeNode as numberTypeNode5,
  publicKeyTypeNode,
  sizePrefixTypeNode,
  stringTypeNode
} from "@codama/nodes";

// src/v00/typeNodes/EnumTypeNode.ts
import { enumTypeNode, numberTypeNode } from "@codama/nodes";

// src/v00/typeNodes/EnumEmptyVariantTypeNode.ts
import { enumEmptyVariantTypeNode } from "@codama/nodes";
function enumEmptyVariantTypeNodeFromAnchorV00(idl) {
  return enumEmptyVariantTypeNode(idl.name ?? "");
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
import { enumStructVariantTypeNode } from "@codama/nodes";

// src/v00/typeNodes/StructTypeNode.ts
import { structTypeNode } from "@codama/nodes";

// src/v00/typeNodes/StructFieldTypeNode.ts
import { structFieldTypeNode } from "@codama/nodes";
function structFieldTypeNodeFromAnchorV00(idl) {
  return structFieldTypeNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV00(idl) {
  return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV00(idl) {
  return enumStructVariantTypeNode(
    idl.name ?? "",
    structTypeNodeFromAnchorV00({ fields: idl.fields, kind: "struct" })
  );
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
import { enumTupleVariantTypeNode } from "@codama/nodes";

// src/v00/typeNodes/TupleTypeNode.ts
import { tupleTypeNode } from "@codama/nodes";
function tupleTypeNodeFromAnchorV00(idl) {
  return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV00(idl) {
  return enumTupleVariantTypeNode(idl.name ?? "", tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));
}

// src/v00/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV00(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV00(variant);
    }
    if (isStructVariant(variant)) {
      return enumStructVariantTypeNodeFromAnchorV00(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV00(variant);
  });
  return enumTypeNode(variants, {
    size: idl.size ? numberTypeNode(idl.size) : void 0
  });
}
function isStructVariant(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v00/typeNodes/MapTypeNode.ts
import {
  fixedCountNode,
  mapTypeNode,
  numberTypeNode as numberTypeNode2,
  prefixedCountNode,
  remainderCountNode
} from "@codama/nodes";
function mapTypeNodeFromAnchorV00(idl) {
  const [key, value] = "hashMap" in idl ? idl.hashMap : idl.bTreeMap;
  let size;
  if (idl.size === "remainder") {
    size = remainderCountNode();
  } else if (typeof idl.size === "number") {
    size = fixedCountNode(idl.size);
  } else {
    size = prefixedCountNode(numberTypeNode2(idl.size ?? "u32"));
  }
  return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);
}

// src/v00/typeNodes/OptionTypeNode.ts
import { numberTypeNode as numberTypeNode3, optionTypeNode } from "@codama/nodes";
function optionTypeNodeFromAnchorV00(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const defaultPrefix = numberTypeNode3("option" in idl ? "u8" : "u32");
  const defaultFixed = !("option" in idl);
  return optionTypeNode(typeNodeFromAnchorV00(item), {
    fixed: idl.fixed !== void 0 ? idl.fixed : defaultFixed,
    prefix: idl.prefix ? numberTypeNode3(idl.prefix) : defaultPrefix
  });
}

// src/v00/typeNodes/SetTypeNode.ts
import {
  fixedCountNode as fixedCountNode2,
  numberTypeNode as numberTypeNode4,
  prefixedCountNode as prefixedCountNode2,
  remainderCountNode as remainderCountNode2,
  setTypeNode
} from "@codama/nodes";
function setTypeNodeFromAnchorV00(idl) {
  const child = "hashSet" in idl ? idl.hashSet : idl.bTreeSet;
  let size;
  if (idl.size === "remainder") {
    size = remainderCountNode2();
  } else if (typeof idl.size === "number") {
    size = fixedCountNode2(idl.size);
  } else {
    size = prefixedCountNode2(numberTypeNode4(idl.size ?? "u32"));
  }
  return setTypeNode(typeNodeFromAnchorV00(child), size);
}

// src/v00/typeNodes/TypeNode.ts
var IDL_V00_TYPE_LEAVES = [
  "string",
  "publicKey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV00 = (idlType) => {
  if (typeof idlType === "string" && IDL_V00_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return booleanTypeNode();
    if (idlType === "publicKey") return publicKeyTypeNode();
    if (idlType === "string") return sizePrefixTypeNode(stringTypeNode("utf8"), numberTypeNode5("u32"));
    if (idlType === "bytes") return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode5("u32"));
    return numberTypeNode5(idlType);
  }
  if (typeof idlType !== "object") {
    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "string") {
    return definedTypeLinkNode(idlType.defined);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV00(idlType);
  }
  if ("hashMap" in idlType && isArrayOfSize(idlType.hashMap, 2) || "bTreeMap" in idlType && isArrayOfSize(idlType.bTreeMap, 2)) {
    return mapTypeNodeFromAnchorV00(idlType);
  }
  if ("option" in idlType || "coption" in idlType) {
    return optionTypeNodeFromAnchorV00(idlType);
  }
  if ("hashSet" in idlType || "bTreeSet" in idlType) {
    return setTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && "fields" in idlType && idlType.kind === "struct") {
    return structTypeNodeFromAnchorV00(idlType);
  }
  if ("tuple" in idlType && Array.isArray(idlType.tuple)) {
    return tupleTypeNodeFromAnchorV00(idlType);
  }
  throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize(array, size) {
  return Array.isArray(array) && array.length === size;
}

// src/v00/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV00(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV00(idl.array[0]);
    return arrayTypeNode(item2, fixedCountNode3(idl.array[1]));
  }
  const item = typeNodeFromAnchorV00(idl.vec);
  if (idl.size === "remainder") return arrayTypeNode(item, remainderCountNode3());
  return arrayTypeNode(item, prefixedCountNode3(numberTypeNode6(idl.size ?? "u32")));
}

// src/v00/AccountNode.ts
function accountNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = camelCase(idlName);
  const idlStruct = idl.type ?? { fields: [], kind: "struct" };
  let data = structTypeNodeFromAnchorV00(idlStruct);
  assertIsNode2(data, "structTypeNode");
  const hasSeeds = (idl.seeds ?? []).length > 0;
  let discriminators;
  if (origin === "anchor") {
    const discriminator = structFieldTypeNode2({
      defaultValue: getAnchorAccountDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: fixedSizeTypeNode(bytesTypeNode2(), 8)
    });
    data = structTypeNode2([discriminator, ...data.fields]);
    discriminators = [fieldDiscriminatorNode("discriminator")];
  }
  return accountNode({
    data,
    discriminators,
    docs: idl.docs ?? [],
    name,
    pda: hasSeeds ? pdaLinkNode(name) : void 0,
    size: idl.size
  });
}

// src/v00/DefinedTypeNode.ts
import { definedTypeNode } from "@codama/nodes";
function definedTypeNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV00(idlType);
  return definedTypeNode({ docs: idl.docs, name, type });
}

// src/v00/ErrorNode.ts
import { errorNode } from "@codama/nodes";
function errorNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return errorNode({
    code: idl.code ?? -1,
    docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],
    message: msg,
    name
  });
}

// src/v00/InstructionAccountNode.ts
import { instructionAccountNode } from "@codama/nodes";
function instructionAccountNodesFromAnchorV00(idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV00(account.accounts) : [instructionAccountNodeFromAnchorV00(account)]
  );
}
function instructionAccountNodeFromAnchorV00(idl) {
  const isOptional = idl.optional ?? idl.isOptional ?? false;
  const desc = idl.desc ? [idl.desc] : void 0;
  return instructionAccountNode({
    docs: idl.docs ?? desc ?? [],
    isOptional,
    isSigner: idl.isOptionalSigner ? "either" : idl.isSigner ?? false,
    isWritable: idl.isMut ?? false,
    name: idl.name ?? ""
  });
}

// src/v00/InstructionArgumentNode.ts
import { instructionArgumentNode } from "@codama/nodes";
function instructionArgumentNodeFromAnchorV00(idl) {
  return instructionArgumentNode({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/InstructionNode.ts
import {
  bytesTypeNode as bytesTypeNode3,
  camelCase as camelCase2,
  fieldDiscriminatorNode as fieldDiscriminatorNode2,
  fixedSizeTypeNode as fixedSizeTypeNode2,
  instructionArgumentNode as instructionArgumentNode2,
  instructionNode,
  numberValueNode
} from "@codama/nodes";
function instructionNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = camelCase2(idlName);
  let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);
  let discriminators;
  if (idl.discriminant) {
    const discriminatorField = instructionArgumentNode2({
      defaultValue: numberValueNode(idl.discriminant.value),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: typeNodeFromAnchorV00(idl.discriminant.type)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [fieldDiscriminatorNode2("discriminator")];
  } else if (origin === "anchor") {
    const discriminatorField = instructionArgumentNode2({
      defaultValue: getAnchorInstructionDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: fixedSizeTypeNode2(bytesTypeNode3(), 8)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [fieldDiscriminatorNode2("discriminator")];
  }
  return instructionNode({
    accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name,
    optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? "omitted" : "programId"
  });
}

// src/v00/PdaNode.ts
import {
  booleanValueNode,
  bytesTypeNode as bytesTypeNode4,
  camelCase as camelCase3,
  constantPdaSeedNode,
  constantPdaSeedNodeFromProgramId,
  numberValueNode as numberValueNode2,
  pdaNode,
  stringTypeNode as stringTypeNode2,
  stringValueNode,
  variablePdaSeedNode
} from "@codama/nodes";
function pdaNodeFromAnchorV00(idl) {
  const name = camelCase3(idl.name ?? "");
  const seeds = (idl.seeds ?? []).map((seed) => {
    if (seed.kind === "constant") {
      const type = (() => {
        if (seed.type === "string") return stringTypeNode2("utf8");
        if (seed.type === "bytes") return bytesTypeNode4();
        return typeNodeFromAnchorV00(seed.type);
      })();
      const value = (() => {
        if (typeof seed.value === "string") return stringValueNode(seed.value);
        if (typeof seed.value === "number") return numberValueNode2(seed.value);
        return booleanValueNode(seed.value);
      })();
      return constantPdaSeedNode(type, value);
    }
    if (seed.kind === "variable") {
      return variablePdaSeedNode(
        seed.name,
        typeNodeFromAnchorV00(seed.type),
        seed.description ? [seed.description] : []
      );
    }
    return constantPdaSeedNodeFromProgramId();
  });
  return pdaNode({ name, seeds });
}

// src/v00/ProgramNode.ts
import { programNode } from "@codama/nodes";
function programNodeFromAnchorV00(idl) {
  const origin = idl?.metadata?.origin ?? "anchor";
  const pdas = (idl.accounts ?? []).filter((account) => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);
  const accounts = (idl.accounts ?? []).map((a) => accountNodeFromAnchorV00(a, origin));
  const instructions = (idl.instructions ?? []).map((i) => instructionNodeFromAnchorV00(i, origin));
  return programNode({
    accounts,
    definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),
    errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),
    instructions,
    name: idl?.name ?? "",
    origin,
    pdas,
    publicKey: idl?.metadata?.address ?? "",
    version: idl.version
  });
}

// src/v00/RootNode.ts
import { rootNode } from "@codama/nodes";
function rootNodeFromAnchorV00(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV00(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);
  return rootNode(programNode3, additionalProgramNodes);
}

// src/v01/AccountNode.ts
import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError as CodamaError4 } from "@codama/errors";
import {
  accountNode as accountNode2,
  assertIsNode as assertIsNode3,
  bytesTypeNode as bytesTypeNode6,
  camelCase as camelCase4,
  fieldDiscriminatorNode as fieldDiscriminatorNode3,
  fixedSizeTypeNode as fixedSizeTypeNode3,
  structFieldTypeNode as structFieldTypeNode4,
  structTypeNode as structTypeNode4
} from "@codama/nodes";

// src/v01/typeNodes/ArrayTypeNode.ts
import { arrayTypeNode as arrayTypeNode2, fixedCountNode as fixedCountNode4, numberTypeNode as numberTypeNode9, prefixedCountNode as prefixedCountNode4 } from "@codama/nodes";

// src/v01/typeNodes/TypeNode.ts
import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE as CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE3, CodamaError as CodamaError3 } from "@codama/errors";
import {
  booleanTypeNode as booleanTypeNode2,
  bytesTypeNode as bytesTypeNode5,
  definedTypeLinkNode as definedTypeLinkNode2,
  numberTypeNode as numberTypeNode8,
  publicKeyTypeNode as publicKeyTypeNode2,
  sizePrefixTypeNode as sizePrefixTypeNode2,
  stringTypeNode as stringTypeNode3
} from "@codama/nodes";

// src/v01/typeNodes/EnumTypeNode.ts
import { enumTypeNode as enumTypeNode2 } from "@codama/nodes";

// src/v01/typeNodes/EnumEmptyVariantTypeNode.ts
import { enumEmptyVariantTypeNode as enumEmptyVariantTypeNode2 } from "@codama/nodes";
function enumEmptyVariantTypeNodeFromAnchorV01(idl) {
  return enumEmptyVariantTypeNode2(idl.name ?? "");
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
import { enumStructVariantTypeNode as enumStructVariantTypeNode2 } from "@codama/nodes";

// src/v01/typeNodes/StructTypeNode.ts
import { structTypeNode as structTypeNode3 } from "@codama/nodes";

// src/v01/typeNodes/StructFieldTypeNode.ts
import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE as CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE2, CodamaError as CodamaError2 } from "@codama/errors";
import { structFieldTypeNode as structFieldTypeNode3 } from "@codama/nodes";
function structFieldTypeNodeFromAnchorV01(idl) {
  if (!isStructField(idl)) {
    throw new CodamaError2(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE2, {
      idlType: JSON.stringify(idl)
    });
  }
  return structFieldTypeNode3({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type)
  });
}
function isStructField(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV01(idl) {
  const fields = idl.fields ?? [];
  return structTypeNode3(fields.map(structFieldTypeNodeFromAnchorV01));
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV01(idl) {
  return enumStructVariantTypeNode2(
    idl.name ?? "",
    structTypeNodeFromAnchorV01({ fields: idl.fields, kind: "struct" })
  );
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
import { enumTupleVariantTypeNode as enumTupleVariantTypeNode2 } from "@codama/nodes";

// src/v01/typeNodes/TupleTypeNode.ts
import { tupleTypeNode as tupleTypeNode2 } from "@codama/nodes";
function tupleTypeNodeFromAnchorV01(idl) {
  return tupleTypeNode2(idl.map(typeNodeFromAnchorV01));
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV01(idl) {
  return enumTupleVariantTypeNode2(idl.name ?? "", tupleTypeNodeFromAnchorV01(idl.fields));
}

// src/v01/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV01(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV01(variant);
    }
    if (isStructVariant2(variant)) {
      return enumStructVariantTypeNodeFromAnchorV01(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV01(
      variant
    );
  });
  return enumTypeNode2(variants);
}
function isStructVariant2(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/OptionTypeNode.ts
import { numberTypeNode as numberTypeNode7, optionTypeNode as optionTypeNode2 } from "@codama/nodes";
function optionTypeNodeFromAnchorV01(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const hasOptionField = "option" in idl;
  const prefix = numberTypeNode7(hasOptionField ? "u8" : "u32");
  const fixed = !hasOptionField;
  return optionTypeNode2(typeNodeFromAnchorV01(item), {
    fixed,
    prefix
  });
}

// src/v01/typeNodes/TypeNode.ts
var IDL_V01_TYPE_LEAVES = [
  "string",
  "pubkey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV01 = (idlType) => {
  if (typeof idlType === "string" && IDL_V01_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return booleanTypeNode2();
    if (idlType === "pubkey") return publicKeyTypeNode2();
    if (idlType === "string") return sizePrefixTypeNode2(stringTypeNode3("utf8"), numberTypeNode8("u32"));
    if (idlType === "bytes") return sizePrefixTypeNode2(bytesTypeNode5(), numberTypeNode8("u32"));
    return numberTypeNode8(idlType);
  }
  if (typeof idlType !== "object") {
    throw new CodamaError3(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE3, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize2(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV01(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV01(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "object") {
    return definedTypeLinkNode2(idlType.defined.name);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV01(idlType);
  }
  if ("option" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType);
  }
  if ("coption" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType);
  }
  if ("kind" in idlType && idlType.kind === "struct") {
    const fields = idlType.fields ?? [];
    if (isStructFieldArray(fields)) {
      return structTypeNodeFromAnchorV01(idlType);
    }
    if (isTupleFieldArray(fields)) {
      return tupleTypeNodeFromAnchorV01(fields);
    }
  }
  throw new CodamaError3(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE3, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize2(array, size) {
  return Array.isArray(array) && array.length === size;
}
function isStructFieldArray(field) {
  return field.every(isStructField2);
}
function isTupleFieldArray(field) {
  return field.every((f) => !isStructField2(f));
}
function isStructField2(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV01(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV01(idl.array[0]);
    return arrayTypeNode2(item2, fixedCountNode4(idl.array[1]));
  }
  const item = typeNodeFromAnchorV01(idl.vec);
  return arrayTypeNode2(item, prefixedCountNode4(numberTypeNode9("u32")));
}

// src/v01/AccountNode.ts
function accountNodeFromAnchorV01(idl, types) {
  const name = camelCase4(idl.name);
  const type = types.find(({ name: name2 }) => name2 === idl.name);
  if (!type) {
    throw new CodamaError4(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });
  }
  const data = typeNodeFromAnchorV01(type.type);
  assertIsNode3(data, "structTypeNode");
  const discriminator = structFieldTypeNode4({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: fixedSizeTypeNode3(bytesTypeNode6(), idl.discriminator.length)
  });
  return accountNode2({
    data: structTypeNode4([discriminator, ...data.fields]),
    discriminators: [fieldDiscriminatorNode3("discriminator")],
    name
  });
}
function accountNodeFromAnchorV01WithTypeDefinition(types) {
  return function(idl) {
    return accountNodeFromAnchorV01(idl, types);
  };
}

// src/v01/DefinedTypeNode.ts
import { definedTypeNode as definedTypeNode2 } from "@codama/nodes";
function definedTypeNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV01(idlType);
  return definedTypeNode2({ docs: idl.docs, name, type });
}

// src/v01/ErrorNode.ts
import { errorNode as errorNode2 } from "@codama/nodes";
function errorNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return errorNode2({
    code: idl.code ?? -1,
    docs: `${name}: ${msg}`,
    message: msg,
    name
  });
}

// src/v01/InstructionAccountNode.ts
import {
  CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING as CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING2,
  CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,
  CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED,
  CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,
  CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING,
  CodamaError as CodamaError5
} from "@codama/errors";
import {
  accountValueNode,
  argumentValueNode,
  camelCase as camelCase5,
  constantPdaSeedNodeFromBytes,
  instructionAccountNode as instructionAccountNode2,
  pdaNode as pdaNode2,
  pdaSeedValueNode,
  pdaValueNode,
  publicKeyTypeNode as publicKeyTypeNode3,
  publicKeyValueNode,
  resolveNestedTypeNode,
  variablePdaSeedNode as variablePdaSeedNode2
} from "@codama/nodes";
import { getBase58Codec } from "@solana/codecs";
function instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts) : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account)]
  );
}
function instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, idl) {
  const isOptional = idl.optional ?? false;
  const docs = idl.docs ?? [];
  const isSigner = idl.signer ?? false;
  const isWritable = idl.writable ?? false;
  const name = idl.name ?? "";
  let defaultValue;
  if (idl.address) {
    defaultValue = publicKeyValueNode(idl.address, name);
  } else if (idl.pda) {
    const seedsWithNestedPaths = idl.pda.seeds.some((seed) => "path" in seed && seed.path.includes("."));
    if (!seedsWithNestedPaths) {
      const [seeds, lookups] = idl.pda.seeds.reduce(
        ([seeds2, lookups2], seed) => {
          const kind = seed.kind;
          switch (kind) {
            case "const":
              return [[...seeds2, constantPdaSeedNodeFromBytes("base16", hex(seed.value))], lookups2];
            case "account": {
              const path = seed.path.split(".");
              if (path.length === 1) {
                return [
                  [...seeds2, variablePdaSeedNode2(seed.path, publicKeyTypeNode3())],
                  [...lookups2, pdaSeedValueNode(seed.path, accountValueNode(seed.path))]
                ];
              } else if (path.length === 2) {
                const accountName = camelCase5(seed.account ?? "");
                const accountNode3 = allAccounts.find(({ name: name2 }) => name2 === accountName);
                if (!accountNode3) {
                  throw new CodamaError5(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING2, { kind });
                }
                const fieldName = camelCase5(path[1]);
                const accountFields = resolveNestedTypeNode(accountNode3.data).fields;
                const fieldNode = accountFields.find(({ name: name2 }) => name2 === fieldName);
                if (!fieldNode) {
                  throw new CodamaError5(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                    idlType: seed.account,
                    path: seed.path
                  });
                }
                const seedName = camelCase5(seed.path);
                return [[...seeds2, variablePdaSeedNode2(seedName, fieldNode.type)], []];
              } else {
                throw new CodamaError5(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                  idlType: seed,
                  path: seed.path
                });
              }
            }
            case "arg": {
              const argumentName = camelCase5(seed.path);
              const argumentNode = instructionArguments.find(({ name: name2 }) => name2 === argumentName);
              if (!argumentNode) {
                throw new CodamaError5(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });
              }
              return [
                [...seeds2, variablePdaSeedNode2(seed.path, argumentNode.type)],
                [...lookups2, pdaSeedValueNode(seed.path, argumentValueNode(seed.path))]
              ];
            }
            default:
              throw new CodamaError5(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });
          }
        },
        [[], []]
      );
      let programId;
      if (idl.pda.program !== void 0) {
        const kind = idl.pda.program.kind;
        switch (kind) {
          case "const": {
            programId = getBase58Codec().decode(new Uint8Array(idl.pda.program.value));
            break;
          }
          default: {
            throw new CodamaError5(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });
          }
        }
      }
      defaultValue = pdaValueNode(
        pdaNode2({ name, seeds, ...programId !== void 0 ? { programId } : {} }),
        lookups
      );
    }
  }
  return instructionAccountNode2({
    defaultValue,
    docs,
    isOptional,
    isSigner,
    isWritable,
    name
  });
}

// src/v01/InstructionArgumentNode.ts
import { instructionArgumentNode as instructionArgumentNode3 } from "@codama/nodes";
function instructionArgumentNodeFromAnchorV01(idl) {
  return instructionArgumentNode3({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type)
  });
}

// src/v01/InstructionNode.ts
import {
  bytesTypeNode as bytesTypeNode7,
  camelCase as camelCase6,
  fieldDiscriminatorNode as fieldDiscriminatorNode4,
  fixedSizeTypeNode as fixedSizeTypeNode4,
  instructionArgumentNode as instructionArgumentNode4,
  instructionNode as instructionNode2
} from "@codama/nodes";
function instructionNodeFromAnchorV01(allAccounts, idl) {
  const name = idl.name;
  let dataArguments = idl.args.map(instructionArgumentNodeFromAnchorV01);
  const discriminatorField = instructionArgumentNode4({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: fixedSizeTypeNode4(bytesTypeNode7(), idl.discriminator.length)
  });
  dataArguments = [discriminatorField, ...dataArguments];
  const discriminators = [fieldDiscriminatorNode4("discriminator")];
  return instructionNode2({
    accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name: camelCase6(name),
    optionalAccountStrategy: "programId"
  });
}

// src/v01/ProgramNode.ts
import { programNode as programNode2 } from "@codama/nodes";
function programNodeFromAnchorV01(idl) {
  const types = idl.types ?? [];
  const accounts = idl.accounts ?? [];
  const instructions = idl.instructions ?? [];
  const errors = idl.errors ?? [];
  const filteredTypes = types.filter((type) => !accounts.some((account) => account.name === type.name));
  const definedTypes = filteredTypes.map(definedTypeNodeFromAnchorV01);
  const accountNodeFromAnchorV012 = accountNodeFromAnchorV01WithTypeDefinition(types);
  const accountNodes = accounts.map(accountNodeFromAnchorV012);
  return programNode2({
    accounts: accountNodes,
    definedTypes,
    errors: errors.map(errorNodeFromAnchorV01),
    instructions: instructions.map((instruction) => instructionNodeFromAnchorV01(accountNodes, instruction)),
    name: idl.metadata.name,
    origin: "anchor",
    publicKey: idl.address,
    version: idl.metadata.version
  });
}

// src/v01/RootNode.ts
import { rootNode as rootNode2 } from "@codama/nodes";
function rootNodeFromAnchorV01(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV01(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);
  return rootNode2(programNode3, additionalProgramNodes);
}

// src/index.ts
function rootNodeFromAnchor(idl) {
  return visit2(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());
}
function rootNodeFromAnchorWithoutDefaultVisitor(idl) {
  if (idl.metadata?.spec === "0.1.0") {
    return rootNodeFromAnchorV01(idl);
  }
  return rootNodeFromAnchorV00(idl);
}
export {
  accountNodeFromAnchorV00,
  accountNodeFromAnchorV01,
  accountNodeFromAnchorV01WithTypeDefinition,
  arrayTypeNodeFromAnchorV00,
  arrayTypeNodeFromAnchorV01,
  definedTypeNodeFromAnchorV00,
  definedTypeNodeFromAnchorV01,
  enumEmptyVariantTypeNodeFromAnchorV00,
  enumEmptyVariantTypeNodeFromAnchorV01,
  enumStructVariantTypeNodeFromAnchorV00,
  enumStructVariantTypeNodeFromAnchorV01,
  enumTupleVariantTypeNodeFromAnchorV00,
  enumTupleVariantTypeNodeFromAnchorV01,
  enumTypeNodeFromAnchorV00,
  enumTypeNodeFromAnchorV01,
  errorNodeFromAnchorV00,
  errorNodeFromAnchorV01,
  getAnchorAccountDiscriminatorV00,
  getAnchorDiscriminatorV01,
  getAnchorInstructionDiscriminatorV00,
  instructionAccountNodeFromAnchorV00,
  instructionAccountNodeFromAnchorV01,
  instructionAccountNodesFromAnchorV00,
  instructionAccountNodesFromAnchorV01,
  instructionArgumentNodeFromAnchorV00,
  instructionArgumentNodeFromAnchorV01,
  instructionNodeFromAnchorV00,
  instructionNodeFromAnchorV01,
  mapTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV01,
  pdaNodeFromAnchorV00,
  programNodeFromAnchorV00,
  programNodeFromAnchorV01,
  rootNodeFromAnchor,
  rootNodeFromAnchorV00,
  rootNodeFromAnchorV01,
  rootNodeFromAnchorWithoutDefaultVisitor,
  setTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV01,
  structTypeNodeFromAnchorV00,
  structTypeNodeFromAnchorV01,
  tupleTypeNodeFromAnchorV00,
  tupleTypeNodeFromAnchorV01,
  typeNodeFromAnchorV00,
  typeNodeFromAnchorV01
};
//# sourceMappingURL=index.browser.mjs.map