{"version":3,"sources":["../src/index.ts","../src/defaultVisitor.ts","../src/v00/AccountNode.ts","../src/discriminators.ts","../src/utils.ts","../src/v00/typeNodes/ArrayTypeNode.ts","../src/v00/typeNodes/TypeNode.ts","../src/v00/typeNodes/EnumTypeNode.ts","../src/v00/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v00/typeNodes/EnumStructVariantTypeNode.ts","../src/v00/typeNodes/StructTypeNode.ts","../src/v00/typeNodes/StructFieldTypeNode.ts","../src/v00/typeNodes/EnumTupleVariantTypeNode.ts","../src/v00/typeNodes/TupleTypeNode.ts","../src/v00/typeNodes/MapTypeNode.ts","../src/v00/typeNodes/OptionTypeNode.ts","../src/v00/typeNodes/SetTypeNode.ts","../src/v00/DefinedTypeNode.ts","../src/v00/ErrorNode.ts","../src/v00/InstructionAccountNode.ts","../src/v00/InstructionArgumentNode.ts","../src/v00/InstructionNode.ts","../src/v00/PdaNode.ts","../src/v00/ProgramNode.ts","../src/v00/RootNode.ts","../src/v01/AccountNode.ts","../src/v01/typeNodes/ArrayTypeNode.ts","../src/v01/typeNodes/TypeNode.ts","../src/v01/typeNodes/EnumTypeNode.ts","../src/v01/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v01/typeNodes/EnumStructVariantTypeNode.ts","../src/v01/typeNodes/StructTypeNode.ts","../src/v01/typeNodes/StructFieldTypeNode.ts","../src/v01/typeNodes/EnumTupleVariantTypeNode.ts","../src/v01/typeNodes/TupleTypeNode.ts","../src/v01/typeNodes/OptionTypeNode.ts","../src/v01/DefinedTypeNode.ts","../src/v01/ErrorNode.ts","../src/v01/InstructionAccountNode.ts","../src/v01/InstructionArgumentNode.ts","../src/v01/InstructionNode.ts","../src/v01/ProgramNode.ts","../src/v01/RootNode.ts"],"sourcesContent":["import { RootNode } from '@codama/nodes';\nimport { visit } from '@codama/visitors';\n\nimport { defaultVisitor } from './defaultVisitor';\nimport { IdlV00, rootNodeFromAnchorV00 } from './v00';\nimport { IdlV01, rootNodeFromAnchorV01 } from './v01';\n\nexport * from './discriminators';\nexport * from './v00';\nexport * from './v01';\n\nexport type AnchorIdl = IdlV00 | IdlV01;\n\nexport function rootNodeFromAnchor(idl: AnchorIdl): RootNode {\n    return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());\n}\n\nexport function rootNodeFromAnchorWithoutDefaultVisitor(idl: AnchorIdl): RootNode {\n    if ((idl.metadata as { spec?: string })?.spec === '0.1.0') {\n        return rootNodeFromAnchorV01(idl as IdlV01);\n    }\n\n    return rootNodeFromAnchorV00(idl as IdlV00);\n}\n","import { assertIsNode, Node, RootNode } from '@codama/nodes';\nimport {\n    deduplicateIdenticalDefinedTypesVisitor,\n    flattenInstructionDataArgumentsVisitor,\n    getCommonInstructionAccountDefaultRules,\n    rootNodeVisitor,\n    setFixedAccountSizesVisitor,\n    setInstructionAccountDefaultValuesVisitor,\n    transformU8ArraysToBytesVisitor,\n    unwrapInstructionArgsDefinedTypesVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors';\n\nexport function defaultVisitor() {\n    return rootNodeVisitor(currentRoot => {\n        let root: RootNode = currentRoot;\n        const updateRoot = (visitor: Visitor<Node | null, 'rootNode'>) => {\n            const newRoot = visit(root, visitor);\n            assertIsNode(newRoot, 'rootNode');\n            root = newRoot;\n        };\n\n        // Defined types.\n        updateRoot(deduplicateIdenticalDefinedTypesVisitor());\n\n        // Accounts.\n        updateRoot(setFixedAccountSizesVisitor());\n\n        // Instructions.\n        updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));\n        updateRoot(unwrapInstructionArgsDefinedTypesVisitor());\n        updateRoot(flattenInstructionDataArgumentsVisitor());\n\n        // Extras.\n        updateRoot(transformU8ArraysToBytesVisitor());\n\n        return root;\n    });\n}\n","import {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    pdaLinkNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorAccountDiscriminatorV00 } from '../discriminators';\nimport { IdlV00AccountDef } from './idl';\nimport { structTypeNodeFromAnchorV00 } from './typeNodes';\n\nexport function accountNodeFromAnchorV00(\n    idl: IdlV00AccountDef,\n    origin?: 'anchor' | 'shank',\n): AccountNode<StructTypeNode> {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    const idlStruct = idl.type ?? { fields: [], kind: 'struct' };\n    let data = structTypeNodeFromAnchorV00(idlStruct);\n    assertIsNode(data, 'structTypeNode');\n    const hasSeeds = (idl.seeds ?? []).length > 0;\n\n    // Account discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (origin === 'anchor') {\n        const discriminator = structFieldTypeNode({\n            defaultValue: getAnchorAccountDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        data = structTypeNode([discriminator, ...data.fields]);\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return accountNode({\n        data,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        pda: hasSeeds ? pdaLinkNode(name) : undefined,\n        size: idl.size,\n    });\n}\n","import { BytesValueNode, bytesValueNode, pascalCase, snakeCase } from '@codama/nodes';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { hex } from './utils';\n\nexport const getAnchorDiscriminatorV01 = (discriminator: number[]): BytesValueNode => {\n    return bytesValueNode('base16', hex(new Uint8Array(discriminator)));\n};\n\nexport const getAnchorInstructionDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`global:${snakeCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n\nexport const getAnchorAccountDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`account:${pascalCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n","export function hex(bytes: number[] | Uint8Array): string {\n    return (bytes as number[]).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeArray, IdlV00TypeVec } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV00(idl: IdlV00TypeArray | IdlV00TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV00(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1]));\n    }\n    const item = typeNodeFromAnchorV00(idl.vec);\n    if (idl.size === 'remainder') return arrayTypeNode(item, remainderCountNode());\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? 'u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00Type, IdlV00TypeDefTy, IdlV00TypeMap, IdlV00TypeSet } from '../idl';\nimport { arrayTypeNodeFromAnchorV00 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV00 } from './EnumTypeNode';\nimport { mapTypeNodeFromAnchorV00 } from './MapTypeNode';\nimport { optionTypeNodeFromAnchorV00 } from './OptionTypeNode';\nimport { setTypeNodeFromAnchorV00 } from './SetTypeNode';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nconst IDL_V00_TYPE_LEAVES = [\n    'string',\n    'publicKey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV00 = (idlType: IdlV00Type | IdlV00TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V00_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'publicKey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'string') {\n        return definedTypeLinkNode(idlType.defined);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Map.\n    if (\n        ('hashMap' in idlType && isArrayOfSize(idlType.hashMap, 2)) ||\n        ('bTreeMap' in idlType && isArrayOfSize(idlType.bTreeMap, 2))\n    ) {\n        return mapTypeNodeFromAnchorV00(idlType as IdlV00TypeMap);\n    }\n\n    // Option.\n    if ('option' in idlType || 'coption' in idlType) {\n        return optionTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Set.\n    if ('hashSet' in idlType || 'bTreeSet' in idlType) {\n        return setTypeNodeFromAnchorV00(idlType as IdlV00TypeSet);\n    }\n\n    // Struct.\n    if ('kind' in idlType && 'fields' in idlType && idlType.kind === 'struct') {\n        return structTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Tuple.\n    if ('tuple' in idlType && Array.isArray(idlType.tuple)) {\n        return tupleTypeNodeFromAnchorV00(idlType);\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode, numberTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumFieldsTuple, IdlV00EnumVariant, IdlV00TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV00 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV00 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV00 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV00(\n    idl: IdlV00TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV00(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV00(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV00(variant as IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple });\n    });\n    return enumTypeNode(variants, {\n        size: idl.size ? numberTypeNode(idl.size) : undefined,\n    });\n}\n\nfunction isStructVariant(variant: IdlV00EnumVariant): variant is IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV00(idl: IdlV00EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV00({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV00 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV00(idl: IdlV00TypeDefTyStruct): StructTypeNode {\n    return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));\n}\n","import { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV00Field } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV00(idl: IdlV00Field): StructFieldTypeNode {\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsTuple, IdlV00EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeTuple } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV00(idl: IdlV00TypeTuple): TupleTypeNode {\n    return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));\n}\n","import {\n    CountNode,\n    fixedCountNode,\n    MapTypeNode,\n    mapTypeNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeMap } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function mapTypeNodeFromAnchorV00(idl: IdlV00TypeMap): MapTypeNode {\n    const [key, value] = 'hashMap' in idl ? idl.hashMap : idl.bTreeMap;\n    let size: CountNode | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeOption } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV00(idl: IdlV00TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const defaultPrefix = numberTypeNode('option' in idl ? 'u8' : 'u32');\n    const defaultFixed = !('option' in idl);\n    return optionTypeNode(typeNodeFromAnchorV00(item), {\n        fixed: idl.fixed !== undefined ? idl.fixed : defaultFixed,\n        prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix,\n    });\n}\n","import {\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n    SetTypeNode,\n    setTypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeSet } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function setTypeNodeFromAnchorV00(idl: IdlV00TypeSet): SetTypeNode {\n    const child = 'hashSet' in idl ? idl.hashSet : idl.bTreeSet;\n    let size: SetTypeNode['count'] | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return setTypeNode(typeNodeFromAnchorV00(child), size);\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV00(idl: Partial<IdlV00TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV00(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV00ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV00(idl: Partial<IdlV00ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],\n        message: msg,\n        name,\n    });\n}\n","import { InstructionAccountNode, instructionAccountNode } from '@codama/nodes';\n\nimport { IdlV00Account, IdlV00AccountItem } from './idl';\n\nexport function instructionAccountNodesFromAnchorV00(idl: IdlV00AccountItem[]): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV00(account.accounts)\n            : [instructionAccountNodeFromAnchorV00(account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV00(idl: IdlV00Account): InstructionAccountNode {\n    const isOptional = idl.optional ?? idl.isOptional ?? false;\n    const desc = idl.desc ? [idl.desc] : undefined;\n    return instructionAccountNode({\n        docs: idl.docs ?? desc ?? [],\n        isOptional,\n        isSigner: idl.isOptionalSigner ? 'either' : (idl.isSigner ?? false),\n        isWritable: idl.isMut ?? false,\n        name: idl.name ?? '',\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV00Field } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV00(idl: IdlV00Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import {\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    numberValueNode,\n} from '@codama/nodes';\n\nimport { getAnchorInstructionDiscriminatorV00 } from '../discriminators';\nimport { IdlV00Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV00 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV00 } from './InstructionArgumentNode';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionNodeFromAnchorV00(idl: IdlV00Instruction, origin?: 'anchor' | 'shank'): InstructionNode {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);\n\n    // Instruction discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (idl.discriminant) {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: numberValueNode(idl.discriminant.value),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: typeNodeFromAnchorV00(idl.discriminant.type),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'anchor') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: getAnchorInstructionDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? 'omitted' : 'programId',\n    });\n}\n","import {\n    booleanValueNode,\n    bytesTypeNode,\n    camelCase,\n    constantPdaSeedNode,\n    constantPdaSeedNodeFromProgramId,\n    numberValueNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    stringTypeNode,\n    stringValueNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\n\nimport { IdlV00PdaDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function pdaNodeFromAnchorV00(idl: IdlV00PdaDef): PdaNode {\n    const name = camelCase(idl.name ?? '');\n    const seeds = (idl.seeds ?? []).map((seed): PdaSeedNode => {\n        if (seed.kind === 'constant') {\n            const type = (() => {\n                if (seed.type === 'string') return stringTypeNode('utf8');\n                if (seed.type === 'bytes') return bytesTypeNode();\n                return typeNodeFromAnchorV00(seed.type);\n            })();\n            const value = (() => {\n                if (typeof seed.value === 'string') return stringValueNode(seed.value);\n                if (typeof seed.value === 'number') return numberValueNode(seed.value);\n                return booleanValueNode(seed.value);\n            })();\n            return constantPdaSeedNode(type, value);\n        }\n        if (seed.kind === 'variable') {\n            return variablePdaSeedNode(\n                seed.name,\n                typeNodeFromAnchorV00(seed.type),\n                seed.description ? [seed.description] : [],\n            );\n        }\n        return constantPdaSeedNodeFromProgramId();\n    });\n    return pdaNode({ name, seeds });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV00 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV00 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV00 } from './ErrorNode';\nimport { IdlV00 } from './idl';\nimport { instructionNodeFromAnchorV00 } from './InstructionNode';\nimport { pdaNodeFromAnchorV00 } from './PdaNode';\n\nexport function programNodeFromAnchorV00(idl: IdlV00): ProgramNode {\n    const origin = (idl?.metadata as { origin?: 'anchor' | 'shank' })?.origin ?? 'anchor';\n    const pdas = (idl.accounts ?? []).filter(account => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);\n    const accounts = (idl.accounts ?? []).map(a => accountNodeFromAnchorV00(a, origin));\n    const instructions = (idl.instructions ?? []).map(i => instructionNodeFromAnchorV00(i, origin));\n    return programNode({\n        accounts,\n        definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),\n        errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),\n        instructions,\n        name: idl?.name ?? '',\n        origin,\n        pdas,\n        publicKey: (idl?.metadata as { address?: string })?.address ?? '',\n        version: idl.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV00 } from './idl';\nimport { programNodeFromAnchorV00 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV00(program: IdlV00, additionalPrograms: IdlV00[] = []): RootNode {\n    const programNode = programNodeFromAnchorV00(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from './../discriminators';\nimport { IdlV01Account, IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function accountNodeFromAnchorV01(idl: IdlV01Account, types: IdlV01TypeDef[]): AccountNode {\n    const name = camelCase(idl.name);\n    const type = types.find(({ name }) => name === idl.name);\n\n    if (!type) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });\n    }\n\n    const data = typeNodeFromAnchorV01(type.type);\n    assertIsNode(data, 'structTypeNode');\n\n    const discriminator = structFieldTypeNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n\n    return accountNode({\n        data: structTypeNode([discriminator, ...data.fields]),\n        discriminators: [fieldDiscriminatorNode('discriminator')],\n        name,\n    });\n}\n\nexport function accountNodeFromAnchorV01WithTypeDefinition(types: IdlV01TypeDef[]) {\n    return function (idl: IdlV01Account): AccountNode {\n        return accountNodeFromAnchorV01(idl, types);\n    };\n}\n","import { ArrayTypeNode, arrayTypeNode, fixedCountNode, numberTypeNode, prefixedCountNode } from '@codama/nodes';\n\nimport { IdlV01TypeArray, IdlV01TypeVec } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV01(idl: IdlV01TypeArray | IdlV01TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV01(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1] as number));\n    }\n\n    const item = typeNodeFromAnchorV01(idl.vec);\n\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode('u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport {\n    IdlV01DefinedFields,\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01Field,\n    IdlV01Type,\n    IdlV01TypeDefTy,\n} from '../idl';\nimport { arrayTypeNodeFromAnchorV01 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV01 } from './EnumTypeNode';\nimport { optionTypeNodeFromAnchorV01 } from './OptionTypeNode';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nconst IDL_V01_TYPE_LEAVES = [\n    'string',\n    'pubkey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV01 = (idlType: IdlV01Type | IdlV01TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V01_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'pubkey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Defined link.\n    // TODO: Support generics.\n    if ('defined' in idlType && typeof idlType.defined === 'object') {\n        return definedTypeLinkNode(idlType.defined.name);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Option.\n    if ('option' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    if ('coption' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Struct and Tuple.\n    if ('kind' in idlType && idlType.kind === 'struct') {\n        const fields = idlType.fields ?? [];\n        if (isStructFieldArray(fields)) {\n            return structTypeNodeFromAnchorV01(idlType);\n        }\n        if (isTupleFieldArray(fields)) {\n            return tupleTypeNodeFromAnchorV01(fields);\n        }\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n\nfunction isStructFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsNamed {\n    return field.every(isStructField);\n}\n\nfunction isTupleFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsTuple {\n    return field.every(f => !isStructField(f));\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01DefinedFieldsTuple, IdlV01EnumVariant, IdlV01TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV01 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV01 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV01 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV01(\n    idl: IdlV01TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV01(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV01(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV01(\n            variant as IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n        );\n    });\n    return enumTypeNode(variants);\n}\n\nfunction isStructVariant(\n    variant: IdlV01EnumVariant,\n): variant is IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV01EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV01(idl: IdlV01EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV01({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFields, IdlV01TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV01 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV01(idl: IdlV01TypeDefTyStruct): StructTypeNode {\n    const fields: IdlV01DefinedFields = idl.fields ?? [];\n\n    return structTypeNode(fields.map(structFieldTypeNodeFromAnchorV01));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV01Field, IdlV01Type } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV01(idl: IdlV01Field | IdlV01Type): StructFieldTypeNode {\n    if (!isStructField(idl)) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idl),\n        });\n    }\n\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple, IdlV01EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV01(idl.fields));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV01(idl: IdlV01DefinedFieldsTuple): TupleTypeNode {\n    return tupleTypeNode(idl.map(typeNodeFromAnchorV01));\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeCOption, IdlV01TypeOption } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV01(idl: IdlV01TypeCOption | IdlV01TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const hasOptionField = 'option' in idl;\n\n    const prefix = numberTypeNode(hasOptionField ? 'u8' : 'u32');\n    const fixed = !hasOptionField;\n\n    return optionTypeNode(typeNodeFromAnchorV01(item), {\n        fixed,\n        prefix,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV01(idl: Partial<IdlV01TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV01(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV01ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV01(idl: Partial<IdlV01ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: `${name}: ${msg}`,\n        message: msg,\n        name,\n    });\n}\n","import {\n    CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    AccountNode,\n    accountValueNode,\n    argumentValueNode,\n    camelCase,\n    constantPdaSeedNodeFromBytes,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionArgumentNode,\n    pdaNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    PdaValueNode,\n    pdaValueNode,\n    publicKeyTypeNode,\n    PublicKeyValueNode,\n    publicKeyValueNode,\n    resolveNestedTypeNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\nimport { getBase58Codec } from '@solana/codecs';\n\nimport { hex } from '../utils';\nimport { IdlV01InstructionAccount, IdlV01InstructionAccountItem, IdlV01Seed } from './idl';\n\nexport function instructionAccountNodesFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts)\n            : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccount,\n): InstructionAccountNode {\n    const isOptional = idl.optional ?? false;\n    const docs = idl.docs ?? [];\n    const isSigner = idl.signer ?? false;\n    const isWritable = idl.writable ?? false;\n    const name = idl.name ?? '';\n    let defaultValue: PdaValueNode | PublicKeyValueNode | undefined;\n\n    if (idl.address) {\n        defaultValue = publicKeyValueNode(idl.address, name);\n    } else if (idl.pda) {\n        // TODO: Handle seeds with nested paths.\n        // Currently, we gracefully ignore PDA default values if we encounter seeds with nested paths.\n        const seedsWithNestedPaths = idl.pda.seeds.some(seed => 'path' in seed && seed.path.includes('.'));\n        if (!seedsWithNestedPaths) {\n            const [seeds, lookups] = idl.pda.seeds.reduce(\n                ([seeds, lookups], seed: IdlV01Seed) => {\n                    const kind = seed.kind;\n\n                    switch (kind) {\n                        case 'const':\n                            return [[...seeds, constantPdaSeedNodeFromBytes('base16', hex(seed.value))], lookups];\n                        case 'account': {\n                            const path = seed.path.split('.');\n                            if (path.length === 1) {\n                                return [\n                                    [...seeds, variablePdaSeedNode(seed.path, publicKeyTypeNode())],\n                                    [...lookups, pdaSeedValueNode(seed.path, accountValueNode(seed.path))],\n                                ];\n                            } else if (path.length === 2) {\n                                // TODO: Handle nested account paths.\n                                // Currently, this scenario is never reached.\n\n                                const accountName = camelCase(seed.account ?? '');\n                                const accountNode = allAccounts.find(({ name }) => name === accountName);\n                                if (!accountNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });\n                                }\n\n                                const fieldName = camelCase(path[1]);\n                                const accountFields = resolveNestedTypeNode(accountNode.data).fields;\n                                const fieldNode = accountFields.find(({ name }) => name === fieldName);\n                                if (!fieldNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                        idlType: seed.account,\n                                        path: seed.path,\n                                    });\n                                }\n\n                                const seedName = camelCase(seed.path);\n                                return [[...seeds, variablePdaSeedNode(seedName, fieldNode.type)], []];\n                            } else {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                    idlType: seed,\n                                    path: seed.path,\n                                });\n                            }\n                        }\n                        case 'arg': {\n                            const argumentName = camelCase(seed.path);\n                            const argumentNode = instructionArguments.find(({ name }) => name === argumentName);\n                            if (!argumentNode) {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });\n                            }\n\n                            return [\n                                [...seeds, variablePdaSeedNode(seed.path, argumentNode.type)],\n                                [...lookups, pdaSeedValueNode(seed.path, argumentValueNode(seed.path))],\n                            ];\n                        }\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });\n                    }\n                },\n                <[PdaSeedNode[], PdaSeedValueNode[]]>[[], []],\n            );\n\n            let programId: string | undefined;\n            if (idl.pda.program !== undefined) {\n                const kind = idl.pda.program.kind;\n                switch (kind) {\n                    case 'const': {\n                        programId = getBase58Codec().decode(new Uint8Array(idl.pda.program.value));\n                        break;\n                    }\n                    default: {\n                        throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                    }\n                }\n            }\n\n            defaultValue = pdaValueNode(\n                pdaNode({ name, seeds, ...(programId !== undefined ? { programId } : {}) }),\n                lookups,\n            );\n        }\n    }\n\n    return instructionAccountNode({\n        defaultValue,\n        docs,\n        isOptional,\n        isSigner,\n        isWritable,\n        name,\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV01Field } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV01(idl: IdlV01Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n","import {\n    AccountNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from '../discriminators';\nimport { IdlV01Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV01 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV01 } from './InstructionArgumentNode';\n\nexport function instructionNodeFromAnchorV01(allAccounts: AccountNode[], idl: IdlV01Instruction): InstructionNode {\n    const name = idl.name;\n    let dataArguments = idl.args.map(instructionArgumentNodeFromAnchorV01);\n\n    const discriminatorField = instructionArgumentNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n    dataArguments = [discriminatorField, ...dataArguments];\n    const discriminators = [fieldDiscriminatorNode('discriminator')];\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name: camelCase(name),\n        optionalAccountStrategy: 'programId',\n    });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV01WithTypeDefinition } from './AccountNode';\nimport { definedTypeNodeFromAnchorV01 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV01 } from './ErrorNode';\nimport { IdlV01 } from './idl';\nimport { instructionNodeFromAnchorV01 } from './InstructionNode';\n\nexport function programNodeFromAnchorV01(idl: IdlV01): ProgramNode {\n    const types = idl.types ?? [];\n    const accounts = idl.accounts ?? [];\n    const instructions = idl.instructions ?? [];\n    const errors = idl.errors ?? [];\n\n    const filteredTypes = types.filter(type => !accounts.some(account => account.name === type.name));\n    const definedTypes = filteredTypes.map(definedTypeNodeFromAnchorV01);\n    const accountNodeFromAnchorV01 = accountNodeFromAnchorV01WithTypeDefinition(types);\n    const accountNodes = accounts.map(accountNodeFromAnchorV01);\n\n    return programNode({\n        accounts: accountNodes,\n        definedTypes,\n        errors: errors.map(errorNodeFromAnchorV01),\n        instructions: instructions.map(instruction => instructionNodeFromAnchorV01(accountNodes, instruction)),\n        name: idl.metadata.name,\n        origin: 'anchor',\n        publicKey: idl.address,\n        version: idl.metadata.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV01 } from './idl';\nimport { programNodeFromAnchorV01 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV01(program: IdlV01, additionalPrograms: IdlV01[] = []): RootNode {\n    const programNode = programNodeFromAnchorV01(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);\n    return rootNode(programNode, additionalProgramNodes);\n}\n"],"mappings":"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","names":["visit","assertIsNode","bytesTypeNode","structFieldTypeNode","structTypeNode","fixedCountNode","numberTypeNode","prefixedCountNode","remainderCountNode","numberTypeNode","numberTypeNode","numberTypeNode","numberTypeNode","numberTypeNode","fixedCountNode","numberTypeNode","prefixedCountNode","remainderCountNode","remainderCountNode","fixedCountNode","prefixedCountNode","numberTypeNode","numberTypeNode","item","fixedCountNode","remainderCountNode","prefixedCountNode","numberTypeNode","assertIsNode","structFieldTypeNode","bytesTypeNode","structTypeNode","bytesTypeNode","camelCase","fieldDiscriminatorNode","fixedSizeTypeNode","instructionArgumentNode","camelCase","instructionArgumentNode","fieldDiscriminatorNode","fixedSizeTypeNode","bytesTypeNode","bytesTypeNode","camelCase","numberValueNode","stringTypeNode","camelCase","stringTypeNode","bytesTypeNode","numberValueNode","programNode","CodamaError","accountNode","assertIsNode","bytesTypeNode","camelCase","fieldDiscriminatorNode","fixedSizeTypeNode","structFieldTypeNode","structTypeNode","arrayTypeNode","fixedCountNode","numberTypeNode","prefixedCountNode","CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE","CodamaError","booleanTypeNode","bytesTypeNode","definedTypeLinkNode","numberTypeNode","publicKeyTypeNode","sizePrefixTypeNode","stringTypeNode","enumTypeNode","enumEmptyVariantTypeNode","enumStructVariantTypeNode","structTypeNode","CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE","CodamaError","structFieldTypeNode","CodamaError","CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE","structFieldTypeNode","structTypeNode","enumStructVariantTypeNode","enumTupleVariantTypeNode","tupleTypeNode","tupleTypeNode","enumTupleVariantTypeNode","isStructVariant","enumTypeNode","numberTypeNode","optionTypeNode","numberTypeNode","optionTypeNode","booleanTypeNode","publicKeyTypeNode","sizePrefixTypeNode","stringTypeNode","numberTypeNode","bytesTypeNode","CodamaError","CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE","isArrayOfSize","definedTypeLinkNode","isStructField","item","arrayTypeNode","fixedCountNode","prefixedCountNode","numberTypeNode","camelCase","name","CodamaError","assertIsNode","structFieldTypeNode","fixedSizeTypeNode","bytesTypeNode","accountNode","structTypeNode","fieldDiscriminatorNode","definedTypeNode","definedTypeNode","errorNode","CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING","CodamaError","camelCase","instructionAccountNode","pdaNode","publicKeyTypeNode","variablePdaSeedNode","seeds","lookups","variablePdaSeedNode","publicKeyTypeNode","camelCase","accountNode","name","CodamaError","CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING","pdaNode","instructionAccountNode","instructionArgumentNode","instructionArgumentNode","bytesTypeNode","camelCase","fieldDiscriminatorNode","fixedSizeTypeNode","instructionArgumentNode","instructionNode","instructionArgumentNode","fixedSizeTypeNode","bytesTypeNode","fieldDiscriminatorNode","instructionNode","camelCase","programNode","accountNodeFromAnchorV01","programNode","rootNode","programNode","rootNode","visit"]}