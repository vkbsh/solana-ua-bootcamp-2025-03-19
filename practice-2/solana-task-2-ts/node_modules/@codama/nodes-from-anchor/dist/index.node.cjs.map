{"version":3,"sources":["../src/index.ts","../src/defaultVisitor.ts","../src/v00/AccountNode.ts","../src/discriminators.ts","../../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/src/_assert.ts","../../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/src/utils.ts","../../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/src/_md.ts","../../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/src/sha256.ts","../src/utils.ts","../src/v00/typeNodes/ArrayTypeNode.ts","../src/v00/typeNodes/TypeNode.ts","../src/v00/typeNodes/EnumTypeNode.ts","../src/v00/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v00/typeNodes/EnumStructVariantTypeNode.ts","../src/v00/typeNodes/StructTypeNode.ts","../src/v00/typeNodes/StructFieldTypeNode.ts","../src/v00/typeNodes/EnumTupleVariantTypeNode.ts","../src/v00/typeNodes/TupleTypeNode.ts","../src/v00/typeNodes/MapTypeNode.ts","../src/v00/typeNodes/OptionTypeNode.ts","../src/v00/typeNodes/SetTypeNode.ts","../src/v00/DefinedTypeNode.ts","../src/v00/ErrorNode.ts","../src/v00/InstructionAccountNode.ts","../src/v00/InstructionArgumentNode.ts","../src/v00/InstructionNode.ts","../src/v00/PdaNode.ts","../src/v00/ProgramNode.ts","../src/v00/RootNode.ts","../src/v01/AccountNode.ts","../src/v01/typeNodes/ArrayTypeNode.ts","../src/v01/typeNodes/TypeNode.ts","../src/v01/typeNodes/EnumTypeNode.ts","../src/v01/typeNodes/EnumEmptyVariantTypeNode.ts","../src/v01/typeNodes/EnumStructVariantTypeNode.ts","../src/v01/typeNodes/StructTypeNode.ts","../src/v01/typeNodes/StructFieldTypeNode.ts","../src/v01/typeNodes/EnumTupleVariantTypeNode.ts","../src/v01/typeNodes/TupleTypeNode.ts","../src/v01/typeNodes/OptionTypeNode.ts","../src/v01/DefinedTypeNode.ts","../src/v01/ErrorNode.ts","../src/v01/InstructionAccountNode.ts","../src/v01/InstructionArgumentNode.ts","../src/v01/InstructionNode.ts","../src/v01/ProgramNode.ts","../src/v01/RootNode.ts"],"sourcesContent":["import { RootNode } from '@codama/nodes';\nimport { visit } from '@codama/visitors';\n\nimport { defaultVisitor } from './defaultVisitor';\nimport { IdlV00, rootNodeFromAnchorV00 } from './v00';\nimport { IdlV01, rootNodeFromAnchorV01 } from './v01';\n\nexport * from './discriminators';\nexport * from './v00';\nexport * from './v01';\n\nexport type AnchorIdl = IdlV00 | IdlV01;\n\nexport function rootNodeFromAnchor(idl: AnchorIdl): RootNode {\n    return visit(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());\n}\n\nexport function rootNodeFromAnchorWithoutDefaultVisitor(idl: AnchorIdl): RootNode {\n    if ((idl.metadata as { spec?: string })?.spec === '0.1.0') {\n        return rootNodeFromAnchorV01(idl as IdlV01);\n    }\n\n    return rootNodeFromAnchorV00(idl as IdlV00);\n}\n","import { assertIsNode, Node, RootNode } from '@codama/nodes';\nimport {\n    deduplicateIdenticalDefinedTypesVisitor,\n    flattenInstructionDataArgumentsVisitor,\n    getCommonInstructionAccountDefaultRules,\n    rootNodeVisitor,\n    setFixedAccountSizesVisitor,\n    setInstructionAccountDefaultValuesVisitor,\n    transformU8ArraysToBytesVisitor,\n    unwrapInstructionArgsDefinedTypesVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors';\n\nexport function defaultVisitor() {\n    return rootNodeVisitor(currentRoot => {\n        let root: RootNode = currentRoot;\n        const updateRoot = (visitor: Visitor<Node | null, 'rootNode'>) => {\n            const newRoot = visit(root, visitor);\n            assertIsNode(newRoot, 'rootNode');\n            root = newRoot;\n        };\n\n        // Defined types.\n        updateRoot(deduplicateIdenticalDefinedTypesVisitor());\n\n        // Accounts.\n        updateRoot(setFixedAccountSizesVisitor());\n\n        // Instructions.\n        updateRoot(setInstructionAccountDefaultValuesVisitor(getCommonInstructionAccountDefaultRules()));\n        updateRoot(unwrapInstructionArgsDefinedTypesVisitor());\n        updateRoot(flattenInstructionDataArgumentsVisitor());\n\n        // Extras.\n        updateRoot(transformU8ArraysToBytesVisitor());\n\n        return root;\n    });\n}\n","import {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    pdaLinkNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorAccountDiscriminatorV00 } from '../discriminators';\nimport { IdlV00AccountDef } from './idl';\nimport { structTypeNodeFromAnchorV00 } from './typeNodes';\n\nexport function accountNodeFromAnchorV00(\n    idl: IdlV00AccountDef,\n    origin?: 'anchor' | 'shank',\n): AccountNode<StructTypeNode> {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    const idlStruct = idl.type ?? { fields: [], kind: 'struct' };\n    let data = structTypeNodeFromAnchorV00(idlStruct);\n    assertIsNode(data, 'structTypeNode');\n    const hasSeeds = (idl.seeds ?? []).length > 0;\n\n    // Account discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (origin === 'anchor') {\n        const discriminator = structFieldTypeNode({\n            defaultValue: getAnchorAccountDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        data = structTypeNode([discriminator, ...data.fields]);\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return accountNode({\n        data,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        pda: hasSeeds ? pdaLinkNode(name) : undefined,\n        size: idl.size,\n    });\n}\n","import { BytesValueNode, bytesValueNode, pascalCase, snakeCase } from '@codama/nodes';\nimport { sha256 } from '@noble/hashes/sha256';\n\nimport { hex } from './utils';\n\nexport const getAnchorDiscriminatorV01 = (discriminator: number[]): BytesValueNode => {\n    return bytesValueNode('base16', hex(new Uint8Array(discriminator)));\n};\n\nexport const getAnchorInstructionDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`global:${snakeCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n\nexport const getAnchorAccountDiscriminatorV00 = (idlName: string): BytesValueNode => {\n    const hash = sha256(`account:${pascalCase(idlName)}`).slice(0, 8);\n    return bytesValueNode('base16', hex(hash));\n};\n","/**\n * Internal assertion helpers.\n * @module\n */\n\n/** Asserts something is positive integer. */\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Hash interface. */\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Asserts something is hash */\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, abytes, ahash, aexists, aoutput };\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n// Cast array to view\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): void {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash function */\nexport type CHash = ReturnType<typeof wrapConstructor>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof wrapConstructorWithOpts>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof wrapXOFConstructorWithOpts>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { aexists, aoutput } from './_assert.js';\nimport { type Input, Hash, createView, toBytes } from './utils.js';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.js';\nimport { type CHash, rotr, wrapConstructor } from './utils.js';\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    SHA256_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n  protected A = 0xc1059ed8 | 0;\n  protected B = 0x367cd507 | 0;\n  protected C = 0x3070dd17 | 0;\n  protected D = 0xf70e5939 | 0;\n  protected E = 0xffc00b31 | 0;\n  protected F = 0x68581511 | 0;\n  protected G = 0x64f98fa7 | 0;\n  protected H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/** SHA2-256 hash function */\nexport const sha256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","export function hex(bytes: number[] | Uint8Array): string {\n    return (bytes as number[]).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeArray, IdlV00TypeVec } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV00(idl: IdlV00TypeArray | IdlV00TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV00(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1]));\n    }\n    const item = typeNodeFromAnchorV00(idl.vec);\n    if (idl.size === 'remainder') return arrayTypeNode(item, remainderCountNode());\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode(idl.size ?? 'u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00Type, IdlV00TypeDefTy, IdlV00TypeMap, IdlV00TypeSet } from '../idl';\nimport { arrayTypeNodeFromAnchorV00 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV00 } from './EnumTypeNode';\nimport { mapTypeNodeFromAnchorV00 } from './MapTypeNode';\nimport { optionTypeNodeFromAnchorV00 } from './OptionTypeNode';\nimport { setTypeNodeFromAnchorV00 } from './SetTypeNode';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nconst IDL_V00_TYPE_LEAVES = [\n    'string',\n    'publicKey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV00 = (idlType: IdlV00Type | IdlV00TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V00_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'publicKey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Defined link.\n    if ('defined' in idlType && typeof idlType.defined === 'string') {\n        return definedTypeLinkNode(idlType.defined);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Map.\n    if (\n        ('hashMap' in idlType && isArrayOfSize(idlType.hashMap, 2)) ||\n        ('bTreeMap' in idlType && isArrayOfSize(idlType.bTreeMap, 2))\n    ) {\n        return mapTypeNodeFromAnchorV00(idlType as IdlV00TypeMap);\n    }\n\n    // Option.\n    if ('option' in idlType || 'coption' in idlType) {\n        return optionTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Set.\n    if ('hashSet' in idlType || 'bTreeSet' in idlType) {\n        return setTypeNodeFromAnchorV00(idlType as IdlV00TypeSet);\n    }\n\n    // Struct.\n    if ('kind' in idlType && 'fields' in idlType && idlType.kind === 'struct') {\n        return structTypeNodeFromAnchorV00(idlType);\n    }\n\n    // Tuple.\n    if ('tuple' in idlType && Array.isArray(idlType.tuple)) {\n        return tupleTypeNodeFromAnchorV00(idlType);\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode, numberTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumFieldsTuple, IdlV00EnumVariant, IdlV00TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV00 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV00 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV00 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV00(\n    idl: IdlV00TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV00(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV00(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV00(variant as IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple });\n    });\n    return enumTypeNode(variants, {\n        size: idl.size ? numberTypeNode(idl.size) : undefined,\n    });\n}\n\nfunction isStructVariant(variant: IdlV00EnumVariant): variant is IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV00(idl: IdlV00EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsNamed, IdlV00EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV00 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV00({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV00 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV00(idl: IdlV00TypeDefTyStruct): StructTypeNode {\n    return structTypeNode((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));\n}\n","import { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV00Field } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV00(idl: IdlV00Field): StructFieldTypeNode {\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00EnumFieldsTuple, IdlV00EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV00 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV00(\n    idl: IdlV00EnumVariant & { fields: IdlV00EnumFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeTuple } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV00(idl: IdlV00TypeTuple): TupleTypeNode {\n    return tupleTypeNode(idl.tuple.map(typeNodeFromAnchorV00));\n}\n","import {\n    CountNode,\n    fixedCountNode,\n    MapTypeNode,\n    mapTypeNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeMap } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function mapTypeNodeFromAnchorV00(idl: IdlV00TypeMap): MapTypeNode {\n    const [key, value] = 'hashMap' in idl ? idl.hashMap : idl.bTreeMap;\n    let size: CountNode | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return mapTypeNode(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeOption } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV00(idl: IdlV00TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const defaultPrefix = numberTypeNode('option' in idl ? 'u8' : 'u32');\n    const defaultFixed = !('option' in idl);\n    return optionTypeNode(typeNodeFromAnchorV00(item), {\n        fixed: idl.fixed !== undefined ? idl.fixed : defaultFixed,\n        prefix: idl.prefix ? numberTypeNode(idl.prefix) : defaultPrefix,\n    });\n}\n","import {\n    fixedCountNode,\n    numberTypeNode,\n    prefixedCountNode,\n    remainderCountNode,\n    SetTypeNode,\n    setTypeNode,\n} from '@codama/nodes';\n\nimport { IdlV00TypeSet } from '../idl';\nimport { typeNodeFromAnchorV00 } from './TypeNode';\n\nexport function setTypeNodeFromAnchorV00(idl: IdlV00TypeSet): SetTypeNode {\n    const child = 'hashSet' in idl ? idl.hashSet : idl.bTreeSet;\n    let size: SetTypeNode['count'] | undefined;\n    if (idl.size === 'remainder') {\n        size = remainderCountNode();\n    } else if (typeof idl.size === 'number') {\n        size = fixedCountNode(idl.size);\n    } else {\n        size = prefixedCountNode(numberTypeNode(idl.size ?? 'u32'));\n    }\n    return setTypeNode(typeNodeFromAnchorV00(child), size);\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV00TypeDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV00(idl: Partial<IdlV00TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV00(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV00ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV00(idl: Partial<IdlV00ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],\n        message: msg,\n        name,\n    });\n}\n","import { InstructionAccountNode, instructionAccountNode } from '@codama/nodes';\n\nimport { IdlV00Account, IdlV00AccountItem } from './idl';\n\nexport function instructionAccountNodesFromAnchorV00(idl: IdlV00AccountItem[]): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV00(account.accounts)\n            : [instructionAccountNodeFromAnchorV00(account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV00(idl: IdlV00Account): InstructionAccountNode {\n    const isOptional = idl.optional ?? idl.isOptional ?? false;\n    const desc = idl.desc ? [idl.desc] : undefined;\n    return instructionAccountNode({\n        docs: idl.docs ?? desc ?? [],\n        isOptional,\n        isSigner: idl.isOptionalSigner ? 'either' : (idl.isSigner ?? false),\n        isWritable: idl.isMut ?? false,\n        name: idl.name ?? '',\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV00Field } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV00(idl: IdlV00Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name ?? '',\n        type: typeNodeFromAnchorV00(idl.type),\n    });\n}\n","import {\n    bytesTypeNode,\n    camelCase,\n    DiscriminatorNode,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    numberValueNode,\n} from '@codama/nodes';\n\nimport { getAnchorInstructionDiscriminatorV00 } from '../discriminators';\nimport { IdlV00Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV00 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV00 } from './InstructionArgumentNode';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function instructionNodeFromAnchorV00(idl: IdlV00Instruction, origin?: 'anchor' | 'shank'): InstructionNode {\n    const idlName = idl.name ?? '';\n    const name = camelCase(idlName);\n    let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);\n\n    // Instruction discriminator.\n    let discriminators: DiscriminatorNode[] | undefined;\n    if (idl.discriminant) {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: numberValueNode(idl.discriminant.value),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: typeNodeFromAnchorV00(idl.discriminant.type),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    } else if (origin === 'anchor') {\n        const discriminatorField = instructionArgumentNode({\n            defaultValue: getAnchorInstructionDiscriminatorV00(idlName),\n            defaultValueStrategy: 'omitted',\n            name: 'discriminator',\n            type: fixedSizeTypeNode(bytesTypeNode(), 8),\n        });\n        dataArguments = [discriminatorField, ...dataArguments];\n        discriminators = [fieldDiscriminatorNode('discriminator')];\n    }\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name,\n        optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? 'omitted' : 'programId',\n    });\n}\n","import {\n    booleanValueNode,\n    bytesTypeNode,\n    camelCase,\n    constantPdaSeedNode,\n    constantPdaSeedNodeFromProgramId,\n    numberValueNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    stringTypeNode,\n    stringValueNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\n\nimport { IdlV00PdaDef } from './idl';\nimport { typeNodeFromAnchorV00 } from './typeNodes';\n\nexport function pdaNodeFromAnchorV00(idl: IdlV00PdaDef): PdaNode {\n    const name = camelCase(idl.name ?? '');\n    const seeds = (idl.seeds ?? []).map((seed): PdaSeedNode => {\n        if (seed.kind === 'constant') {\n            const type = (() => {\n                if (seed.type === 'string') return stringTypeNode('utf8');\n                if (seed.type === 'bytes') return bytesTypeNode();\n                return typeNodeFromAnchorV00(seed.type);\n            })();\n            const value = (() => {\n                if (typeof seed.value === 'string') return stringValueNode(seed.value);\n                if (typeof seed.value === 'number') return numberValueNode(seed.value);\n                return booleanValueNode(seed.value);\n            })();\n            return constantPdaSeedNode(type, value);\n        }\n        if (seed.kind === 'variable') {\n            return variablePdaSeedNode(\n                seed.name,\n                typeNodeFromAnchorV00(seed.type),\n                seed.description ? [seed.description] : [],\n            );\n        }\n        return constantPdaSeedNodeFromProgramId();\n    });\n    return pdaNode({ name, seeds });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV00 } from './AccountNode';\nimport { definedTypeNodeFromAnchorV00 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV00 } from './ErrorNode';\nimport { IdlV00 } from './idl';\nimport { instructionNodeFromAnchorV00 } from './InstructionNode';\nimport { pdaNodeFromAnchorV00 } from './PdaNode';\n\nexport function programNodeFromAnchorV00(idl: IdlV00): ProgramNode {\n    const origin = (idl?.metadata as { origin?: 'anchor' | 'shank' })?.origin ?? 'anchor';\n    const pdas = (idl.accounts ?? []).filter(account => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);\n    const accounts = (idl.accounts ?? []).map(a => accountNodeFromAnchorV00(a, origin));\n    const instructions = (idl.instructions ?? []).map(i => instructionNodeFromAnchorV00(i, origin));\n    return programNode({\n        accounts,\n        definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),\n        errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),\n        instructions,\n        name: idl?.name ?? '',\n        origin,\n        pdas,\n        publicKey: (idl?.metadata as { address?: string })?.address ?? '',\n        version: idl.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV00 } from './idl';\nimport { programNodeFromAnchorV00 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV00(program: IdlV00, additionalPrograms: IdlV00[] = []): RootNode {\n    const programNode = programNodeFromAnchorV00(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);\n    return rootNode(programNode, additionalProgramNodes);\n}\n","import { CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    accountNode,\n    assertIsNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from './../discriminators';\nimport { IdlV01Account, IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function accountNodeFromAnchorV01(idl: IdlV01Account, types: IdlV01TypeDef[]): AccountNode {\n    const name = camelCase(idl.name);\n    const type = types.find(({ name }) => name === idl.name);\n\n    if (!type) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });\n    }\n\n    const data = typeNodeFromAnchorV01(type.type);\n    assertIsNode(data, 'structTypeNode');\n\n    const discriminator = structFieldTypeNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n\n    return accountNode({\n        data: structTypeNode([discriminator, ...data.fields]),\n        discriminators: [fieldDiscriminatorNode('discriminator')],\n        name,\n    });\n}\n\nexport function accountNodeFromAnchorV01WithTypeDefinition(types: IdlV01TypeDef[]) {\n    return function (idl: IdlV01Account): AccountNode {\n        return accountNodeFromAnchorV01(idl, types);\n    };\n}\n","import { ArrayTypeNode, arrayTypeNode, fixedCountNode, numberTypeNode, prefixedCountNode } from '@codama/nodes';\n\nimport { IdlV01TypeArray, IdlV01TypeVec } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function arrayTypeNodeFromAnchorV01(idl: IdlV01TypeArray | IdlV01TypeVec): ArrayTypeNode {\n    if ('array' in idl) {\n        const item = typeNodeFromAnchorV01(idl.array[0]);\n        return arrayTypeNode(item, fixedCountNode(idl.array[1] as number));\n    }\n\n    const item = typeNodeFromAnchorV01(idl.vec);\n\n    return arrayTypeNode(item, prefixedCountNode(numberTypeNode('u32')));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport {\n    booleanTypeNode,\n    bytesTypeNode,\n    definedTypeLinkNode,\n    numberTypeNode,\n    publicKeyTypeNode,\n    sizePrefixTypeNode,\n    stringTypeNode,\n    TypeNode,\n} from '@codama/nodes';\n\nimport {\n    IdlV01DefinedFields,\n    IdlV01DefinedFieldsNamed,\n    IdlV01DefinedFieldsTuple,\n    IdlV01Field,\n    IdlV01Type,\n    IdlV01TypeDefTy,\n} from '../idl';\nimport { arrayTypeNodeFromAnchorV01 } from './ArrayTypeNode';\nimport { enumTypeNodeFromAnchorV01 } from './EnumTypeNode';\nimport { optionTypeNodeFromAnchorV01 } from './OptionTypeNode';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nconst IDL_V01_TYPE_LEAVES = [\n    'string',\n    'pubkey',\n    'bytes',\n    'bool',\n    'u8',\n    'u16',\n    'u32',\n    'u64',\n    'u128',\n    'i8',\n    'i16',\n    'i32',\n    'i64',\n    'i128',\n    'f32',\n    'f64',\n    'shortU16',\n] as const;\n\nexport const typeNodeFromAnchorV01 = (idlType: IdlV01Type | IdlV01TypeDefTy): TypeNode => {\n    // Leaf.\n    if (typeof idlType === 'string' && IDL_V01_TYPE_LEAVES.includes(idlType)) {\n        if (idlType === 'bool') return booleanTypeNode();\n        if (idlType === 'pubkey') return publicKeyTypeNode();\n        if (idlType === 'string') return sizePrefixTypeNode(stringTypeNode('utf8'), numberTypeNode('u32'));\n        if (idlType === 'bytes') return sizePrefixTypeNode(bytesTypeNode(), numberTypeNode('u32'));\n        return numberTypeNode(idlType);\n    }\n\n    // Ensure eveything else is an object.\n    if (typeof idlType !== 'object') {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idlType),\n        });\n    }\n\n    // Array.\n    if ('array' in idlType && isArrayOfSize(idlType.array, 2)) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Vec.\n    if ('vec' in idlType) {\n        return arrayTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Defined link.\n    // TODO: Support generics.\n    if ('defined' in idlType && typeof idlType.defined === 'object') {\n        return definedTypeLinkNode(idlType.defined.name);\n    }\n\n    // Enum.\n    if ('kind' in idlType && idlType.kind === 'enum' && 'variants' in idlType) {\n        return enumTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Option.\n    if ('option' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    if ('coption' in idlType) {\n        return optionTypeNodeFromAnchorV01(idlType);\n    }\n\n    // Struct and Tuple.\n    if ('kind' in idlType && idlType.kind === 'struct') {\n        const fields = idlType.fields ?? [];\n        if (isStructFieldArray(fields)) {\n            return structTypeNodeFromAnchorV01(idlType);\n        }\n        if (isTupleFieldArray(fields)) {\n            return tupleTypeNodeFromAnchorV01(fields);\n        }\n    }\n\n    throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n        idlType: JSON.stringify(idlType),\n    });\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isArrayOfSize(array: any, size: number): boolean {\n    return Array.isArray(array) && array.length === size;\n}\n\nfunction isStructFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsNamed {\n    return field.every(isStructField);\n}\n\nfunction isTupleFieldArray(field: IdlV01DefinedFields): field is IdlV01DefinedFieldsTuple {\n    return field.every(f => !isStructField(f));\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTypeNode, enumTypeNode, EnumVariantTypeNode, NumberTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01DefinedFieldsTuple, IdlV01EnumVariant, IdlV01TypeDefTyEnum } from '../idl';\nimport { enumEmptyVariantTypeNodeFromAnchorV01 } from './EnumEmptyVariantTypeNode';\nimport { enumStructVariantTypeNodeFromAnchorV01 } from './EnumStructVariantTypeNode';\nimport { enumTupleVariantTypeNodeFromAnchorV01 } from './EnumTupleVariantTypeNode';\n\nexport function enumTypeNodeFromAnchorV01(\n    idl: IdlV01TypeDefTyEnum,\n): EnumTypeNode<EnumVariantTypeNode[], NumberTypeNode> {\n    const variants = idl.variants.map((variant): EnumVariantTypeNode => {\n        if (!variant.fields || variant.fields.length <= 0) {\n            return enumEmptyVariantTypeNodeFromAnchorV01(variant);\n        }\n        if (isStructVariant(variant)) {\n            return enumStructVariantTypeNodeFromAnchorV01(variant);\n        }\n        return enumTupleVariantTypeNodeFromAnchorV01(\n            variant as IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n        );\n    });\n    return enumTypeNode(variants);\n}\n\nfunction isStructVariant(\n    variant: IdlV01EnumVariant,\n): variant is IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed } {\n    const field = variant.fields![0];\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumEmptyVariantTypeNode, enumEmptyVariantTypeNode } from '@codama/nodes';\n\nimport { IdlV01EnumVariant } from '../idl';\n\nexport function enumEmptyVariantTypeNodeFromAnchorV01(idl: IdlV01EnumVariant): EnumEmptyVariantTypeNode {\n    return enumEmptyVariantTypeNode(idl.name ?? '');\n}\n","import { EnumStructVariantTypeNode, enumStructVariantTypeNode, StructTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsNamed, IdlV01EnumVariant } from '../idl';\nimport { structTypeNodeFromAnchorV01 } from './StructTypeNode';\n\nexport function enumStructVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsNamed },\n): EnumStructVariantTypeNode<StructTypeNode> {\n    return enumStructVariantTypeNode(\n        idl.name ?? '',\n        structTypeNodeFromAnchorV01({ fields: idl.fields, kind: 'struct' }),\n    );\n}\n","import { StructTypeNode, structTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFields, IdlV01TypeDefTyStruct } from '../idl';\nimport { structFieldTypeNodeFromAnchorV01 } from './StructFieldTypeNode';\n\nexport function structTypeNodeFromAnchorV01(idl: IdlV01TypeDefTyStruct): StructTypeNode {\n    const fields: IdlV01DefinedFields = idl.fields ?? [];\n\n    return structTypeNode(fields.map(structFieldTypeNodeFromAnchorV01));\n}\n","import { CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, CodamaError } from '@codama/errors';\nimport { StructFieldTypeNode, structFieldTypeNode } from '@codama/nodes';\n\nimport { IdlV01Field, IdlV01Type } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function structFieldTypeNodeFromAnchorV01(idl: IdlV01Field | IdlV01Type): StructFieldTypeNode {\n    if (!isStructField(idl)) {\n        throw new CodamaError(CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {\n            idlType: JSON.stringify(idl),\n        });\n    }\n\n    return structFieldTypeNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n\nfunction isStructField(field: IdlV01Field | IdlV01Type): field is IdlV01Field {\n    return typeof field === 'object' && 'name' in field && 'type' in field;\n}\n","import { EnumTupleVariantTypeNode, enumTupleVariantTypeNode, TupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple, IdlV01EnumVariant } from '../idl';\nimport { tupleTypeNodeFromAnchorV01 } from './TupleTypeNode';\n\nexport function enumTupleVariantTypeNodeFromAnchorV01(\n    idl: IdlV01EnumVariant & { fields: IdlV01DefinedFieldsTuple },\n): EnumTupleVariantTypeNode<TupleTypeNode> {\n    return enumTupleVariantTypeNode(idl.name ?? '', tupleTypeNodeFromAnchorV01(idl.fields));\n}\n","import { TupleTypeNode, tupleTypeNode } from '@codama/nodes';\n\nimport { IdlV01DefinedFieldsTuple } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function tupleTypeNodeFromAnchorV01(idl: IdlV01DefinedFieldsTuple): TupleTypeNode {\n    return tupleTypeNode(idl.map(typeNodeFromAnchorV01));\n}\n","import { numberTypeNode, OptionTypeNode, optionTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeCOption, IdlV01TypeOption } from '../idl';\nimport { typeNodeFromAnchorV01 } from './TypeNode';\n\nexport function optionTypeNodeFromAnchorV01(idl: IdlV01TypeCOption | IdlV01TypeOption): OptionTypeNode {\n    const item = 'option' in idl ? idl.option : idl.coption;\n    const hasOptionField = 'option' in idl;\n\n    const prefix = numberTypeNode(hasOptionField ? 'u8' : 'u32');\n    const fixed = !hasOptionField;\n\n    return optionTypeNode(typeNodeFromAnchorV01(item), {\n        fixed,\n        prefix,\n    });\n}\n","import { DefinedTypeNode, definedTypeNode } from '@codama/nodes';\n\nimport { IdlV01TypeDef } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function definedTypeNodeFromAnchorV01(idl: Partial<IdlV01TypeDef>): DefinedTypeNode {\n    const name = idl.name ?? '';\n    const idlType = idl.type ?? { fields: [], kind: 'struct' };\n    const type = typeNodeFromAnchorV01(idlType);\n    return definedTypeNode({ docs: idl.docs, name, type });\n}\n","import { ErrorNode, errorNode } from '@codama/nodes';\n\nimport { IdlV01ErrorCode } from './idl';\n\nexport function errorNodeFromAnchorV01(idl: Partial<IdlV01ErrorCode>): ErrorNode {\n    const name = idl.name ?? '';\n    const msg = idl.msg ?? '';\n    return errorNode({\n        code: idl.code ?? -1,\n        docs: `${name}: ${msg}`,\n        message: msg,\n        name,\n    });\n}\n","import {\n    CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING,\n    CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED,\n    CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    AccountNode,\n    accountValueNode,\n    argumentValueNode,\n    camelCase,\n    constantPdaSeedNodeFromBytes,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionArgumentNode,\n    pdaNode,\n    PdaSeedNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    PdaValueNode,\n    pdaValueNode,\n    publicKeyTypeNode,\n    PublicKeyValueNode,\n    publicKeyValueNode,\n    resolveNestedTypeNode,\n    variablePdaSeedNode,\n} from '@codama/nodes';\nimport { getBase58Codec } from '@solana/codecs';\n\nimport { hex } from '../utils';\nimport { IdlV01InstructionAccount, IdlV01InstructionAccountItem, IdlV01Seed } from './idl';\n\nexport function instructionAccountNodesFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccountItem[],\n): InstructionAccountNode[] {\n    return idl.flatMap(account =>\n        'accounts' in account\n            ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts)\n            : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account)],\n    );\n}\n\nexport function instructionAccountNodeFromAnchorV01(\n    allAccounts: AccountNode[],\n    instructionArguments: InstructionArgumentNode[],\n    idl: IdlV01InstructionAccount,\n): InstructionAccountNode {\n    const isOptional = idl.optional ?? false;\n    const docs = idl.docs ?? [];\n    const isSigner = idl.signer ?? false;\n    const isWritable = idl.writable ?? false;\n    const name = idl.name ?? '';\n    let defaultValue: PdaValueNode | PublicKeyValueNode | undefined;\n\n    if (idl.address) {\n        defaultValue = publicKeyValueNode(idl.address, name);\n    } else if (idl.pda) {\n        // TODO: Handle seeds with nested paths.\n        // Currently, we gracefully ignore PDA default values if we encounter seeds with nested paths.\n        const seedsWithNestedPaths = idl.pda.seeds.some(seed => 'path' in seed && seed.path.includes('.'));\n        if (!seedsWithNestedPaths) {\n            const [seeds, lookups] = idl.pda.seeds.reduce(\n                ([seeds, lookups], seed: IdlV01Seed) => {\n                    const kind = seed.kind;\n\n                    switch (kind) {\n                        case 'const':\n                            return [[...seeds, constantPdaSeedNodeFromBytes('base16', hex(seed.value))], lookups];\n                        case 'account': {\n                            const path = seed.path.split('.');\n                            if (path.length === 1) {\n                                return [\n                                    [...seeds, variablePdaSeedNode(seed.path, publicKeyTypeNode())],\n                                    [...lookups, pdaSeedValueNode(seed.path, accountValueNode(seed.path))],\n                                ];\n                            } else if (path.length === 2) {\n                                // TODO: Handle nested account paths.\n                                // Currently, this scenario is never reached.\n\n                                const accountName = camelCase(seed.account ?? '');\n                                const accountNode = allAccounts.find(({ name }) => name === accountName);\n                                if (!accountNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });\n                                }\n\n                                const fieldName = camelCase(path[1]);\n                                const accountFields = resolveNestedTypeNode(accountNode.data).fields;\n                                const fieldNode = accountFields.find(({ name }) => name === fieldName);\n                                if (!fieldNode) {\n                                    throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                        idlType: seed.account,\n                                        path: seed.path,\n                                    });\n                                }\n\n                                const seedName = camelCase(seed.path);\n                                return [[...seeds, variablePdaSeedNode(seedName, fieldNode.type)], []];\n                            } else {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {\n                                    idlType: seed,\n                                    path: seed.path,\n                                });\n                            }\n                        }\n                        case 'arg': {\n                            const argumentName = camelCase(seed.path);\n                            const argumentNode = instructionArguments.find(({ name }) => name === argumentName);\n                            if (!argumentNode) {\n                                throw new CodamaError(CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });\n                            }\n\n                            return [\n                                [...seeds, variablePdaSeedNode(seed.path, argumentNode.type)],\n                                [...lookups, pdaSeedValueNode(seed.path, argumentValueNode(seed.path))],\n                            ];\n                        }\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });\n                    }\n                },\n                <[PdaSeedNode[], PdaSeedValueNode[]]>[[], []],\n            );\n\n            let programId: string | undefined;\n            if (idl.pda.program !== undefined) {\n                const kind = idl.pda.program.kind;\n                switch (kind) {\n                    case 'const': {\n                        programId = getBase58Codec().decode(new Uint8Array(idl.pda.program.value));\n                        break;\n                    }\n                    default: {\n                        throw new CodamaError(CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });\n                    }\n                }\n            }\n\n            defaultValue = pdaValueNode(\n                pdaNode({ name, seeds, ...(programId !== undefined ? { programId } : {}) }),\n                lookups,\n            );\n        }\n    }\n\n    return instructionAccountNode({\n        defaultValue,\n        docs,\n        isOptional,\n        isSigner,\n        isWritable,\n        name,\n    });\n}\n","import { InstructionArgumentNode, instructionArgumentNode } from '@codama/nodes';\n\nimport { IdlV01Field } from './idl';\nimport { typeNodeFromAnchorV01 } from './typeNodes';\n\nexport function instructionArgumentNodeFromAnchorV01(idl: IdlV01Field): InstructionArgumentNode {\n    return instructionArgumentNode({\n        docs: idl.docs ?? [],\n        name: idl.name,\n        type: typeNodeFromAnchorV01(idl.type),\n    });\n}\n","import {\n    AccountNode,\n    bytesTypeNode,\n    camelCase,\n    fieldDiscriminatorNode,\n    fixedSizeTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n} from '@codama/nodes';\n\nimport { getAnchorDiscriminatorV01 } from '../discriminators';\nimport { IdlV01Instruction } from './idl';\nimport { instructionAccountNodesFromAnchorV01 } from './InstructionAccountNode';\nimport { instructionArgumentNodeFromAnchorV01 } from './InstructionArgumentNode';\n\nexport function instructionNodeFromAnchorV01(allAccounts: AccountNode[], idl: IdlV01Instruction): InstructionNode {\n    const name = idl.name;\n    let dataArguments = idl.args.map(instructionArgumentNodeFromAnchorV01);\n\n    const discriminatorField = instructionArgumentNode({\n        defaultValue: getAnchorDiscriminatorV01(idl.discriminator),\n        defaultValueStrategy: 'omitted',\n        name: 'discriminator',\n        type: fixedSizeTypeNode(bytesTypeNode(), idl.discriminator.length),\n    });\n    dataArguments = [discriminatorField, ...dataArguments];\n    const discriminators = [fieldDiscriminatorNode('discriminator')];\n\n    return instructionNode({\n        accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),\n        arguments: dataArguments,\n        discriminators,\n        docs: idl.docs ?? [],\n        name: camelCase(name),\n        optionalAccountStrategy: 'programId',\n    });\n}\n","import { ProgramNode, programNode, ProgramVersion } from '@codama/nodes';\n\nimport { accountNodeFromAnchorV01WithTypeDefinition } from './AccountNode';\nimport { definedTypeNodeFromAnchorV01 } from './DefinedTypeNode';\nimport { errorNodeFromAnchorV01 } from './ErrorNode';\nimport { IdlV01 } from './idl';\nimport { instructionNodeFromAnchorV01 } from './InstructionNode';\n\nexport function programNodeFromAnchorV01(idl: IdlV01): ProgramNode {\n    const types = idl.types ?? [];\n    const accounts = idl.accounts ?? [];\n    const instructions = idl.instructions ?? [];\n    const errors = idl.errors ?? [];\n\n    const filteredTypes = types.filter(type => !accounts.some(account => account.name === type.name));\n    const definedTypes = filteredTypes.map(definedTypeNodeFromAnchorV01);\n    const accountNodeFromAnchorV01 = accountNodeFromAnchorV01WithTypeDefinition(types);\n    const accountNodes = accounts.map(accountNodeFromAnchorV01);\n\n    return programNode({\n        accounts: accountNodes,\n        definedTypes,\n        errors: errors.map(errorNodeFromAnchorV01),\n        instructions: instructions.map(instruction => instructionNodeFromAnchorV01(accountNodes, instruction)),\n        name: idl.metadata.name,\n        origin: 'anchor',\n        publicKey: idl.address,\n        version: idl.metadata.version as ProgramVersion,\n    });\n}\n","import { RootNode, rootNode } from '@codama/nodes';\n\nimport { IdlV01 } from './idl';\nimport { programNodeFromAnchorV01 } from './ProgramNode';\n\nexport function rootNodeFromAnchorV01(program: IdlV01, additionalPrograms: IdlV01[] = []): RootNode {\n    const programNode = programNodeFromAnchorV01(program);\n    const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);\n    return rootNode(programNode, additionalProgramNodes);\n}\n"],"mappings":"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","names":["import_visitors","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","item","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","programNode","import_errors","import_nodes","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","import_nodes","import_nodes","import_errors","import_nodes","import_nodes","import_nodes","isStructVariant","import_nodes","isArrayOfSize","isStructField","item","name","import_nodes","import_nodes","import_errors","import_nodes","seeds","lookups","accountNode","name","import_nodes","import_nodes","import_nodes","accountNodeFromAnchorV01","import_nodes","programNode"]}