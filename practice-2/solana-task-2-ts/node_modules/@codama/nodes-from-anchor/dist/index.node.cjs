"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  accountNodeFromAnchorV00: () => accountNodeFromAnchorV00,
  accountNodeFromAnchorV01: () => accountNodeFromAnchorV01,
  accountNodeFromAnchorV01WithTypeDefinition: () => accountNodeFromAnchorV01WithTypeDefinition,
  arrayTypeNodeFromAnchorV00: () => arrayTypeNodeFromAnchorV00,
  arrayTypeNodeFromAnchorV01: () => arrayTypeNodeFromAnchorV01,
  definedTypeNodeFromAnchorV00: () => definedTypeNodeFromAnchorV00,
  definedTypeNodeFromAnchorV01: () => definedTypeNodeFromAnchorV01,
  enumEmptyVariantTypeNodeFromAnchorV00: () => enumEmptyVariantTypeNodeFromAnchorV00,
  enumEmptyVariantTypeNodeFromAnchorV01: () => enumEmptyVariantTypeNodeFromAnchorV01,
  enumStructVariantTypeNodeFromAnchorV00: () => enumStructVariantTypeNodeFromAnchorV00,
  enumStructVariantTypeNodeFromAnchorV01: () => enumStructVariantTypeNodeFromAnchorV01,
  enumTupleVariantTypeNodeFromAnchorV00: () => enumTupleVariantTypeNodeFromAnchorV00,
  enumTupleVariantTypeNodeFromAnchorV01: () => enumTupleVariantTypeNodeFromAnchorV01,
  enumTypeNodeFromAnchorV00: () => enumTypeNodeFromAnchorV00,
  enumTypeNodeFromAnchorV01: () => enumTypeNodeFromAnchorV01,
  errorNodeFromAnchorV00: () => errorNodeFromAnchorV00,
  errorNodeFromAnchorV01: () => errorNodeFromAnchorV01,
  getAnchorAccountDiscriminatorV00: () => getAnchorAccountDiscriminatorV00,
  getAnchorDiscriminatorV01: () => getAnchorDiscriminatorV01,
  getAnchorInstructionDiscriminatorV00: () => getAnchorInstructionDiscriminatorV00,
  instructionAccountNodeFromAnchorV00: () => instructionAccountNodeFromAnchorV00,
  instructionAccountNodeFromAnchorV01: () => instructionAccountNodeFromAnchorV01,
  instructionAccountNodesFromAnchorV00: () => instructionAccountNodesFromAnchorV00,
  instructionAccountNodesFromAnchorV01: () => instructionAccountNodesFromAnchorV01,
  instructionArgumentNodeFromAnchorV00: () => instructionArgumentNodeFromAnchorV00,
  instructionArgumentNodeFromAnchorV01: () => instructionArgumentNodeFromAnchorV01,
  instructionNodeFromAnchorV00: () => instructionNodeFromAnchorV00,
  instructionNodeFromAnchorV01: () => instructionNodeFromAnchorV01,
  mapTypeNodeFromAnchorV00: () => mapTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV00: () => optionTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV01: () => optionTypeNodeFromAnchorV01,
  pdaNodeFromAnchorV00: () => pdaNodeFromAnchorV00,
  programNodeFromAnchorV00: () => programNodeFromAnchorV00,
  programNodeFromAnchorV01: () => programNodeFromAnchorV01,
  rootNodeFromAnchor: () => rootNodeFromAnchor,
  rootNodeFromAnchorV00: () => rootNodeFromAnchorV00,
  rootNodeFromAnchorV01: () => rootNodeFromAnchorV01,
  rootNodeFromAnchorWithoutDefaultVisitor: () => rootNodeFromAnchorWithoutDefaultVisitor,
  setTypeNodeFromAnchorV00: () => setTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV00: () => structFieldTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV01: () => structFieldTypeNodeFromAnchorV01,
  structTypeNodeFromAnchorV00: () => structTypeNodeFromAnchorV00,
  structTypeNodeFromAnchorV01: () => structTypeNodeFromAnchorV01,
  tupleTypeNodeFromAnchorV00: () => tupleTypeNodeFromAnchorV00,
  tupleTypeNodeFromAnchorV01: () => tupleTypeNodeFromAnchorV01,
  typeNodeFromAnchorV00: () => typeNodeFromAnchorV00,
  typeNodeFromAnchorV01: () => typeNodeFromAnchorV01
});
module.exports = __toCommonJS(index_exports);
var import_visitors2 = require("@codama/visitors");

// src/defaultVisitor.ts
var import_nodes = require("@codama/nodes");
var import_visitors = require("@codama/visitors");
function defaultVisitor() {
  return (0, import_visitors.rootNodeVisitor)((currentRoot) => {
    let root = currentRoot;
    const updateRoot = (visitor) => {
      const newRoot = (0, import_visitors.visit)(root, visitor);
      (0, import_nodes.assertIsNode)(newRoot, "rootNode");
      root = newRoot;
    };
    updateRoot((0, import_visitors.deduplicateIdenticalDefinedTypesVisitor)());
    updateRoot((0, import_visitors.setFixedAccountSizesVisitor)());
    updateRoot((0, import_visitors.setInstructionAccountDefaultValuesVisitor)((0, import_visitors.getCommonInstructionAccountDefaultRules)()));
    updateRoot((0, import_visitors.unwrapInstructionArgsDefinedTypesVisitor)());
    updateRoot((0, import_visitors.flattenInstructionDataArgumentsVisitor)());
    updateRoot((0, import_visitors.transformU8ArraysToBytesVisitor)());
    return root;
  });
}

// src/v00/AccountNode.ts
var import_nodes15 = require("@codama/nodes");

// src/discriminators.ts
var import_nodes2 = require("@codama/nodes");

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_assert.js
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/utils.js
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE ? 4 : 0;
  const l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// src/utils.ts
function hex(bytes) {
  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
}

// src/discriminators.ts
var getAnchorDiscriminatorV01 = (discriminator) => {
  return (0, import_nodes2.bytesValueNode)("base16", hex(new Uint8Array(discriminator)));
};
var getAnchorInstructionDiscriminatorV00 = (idlName) => {
  const hash = sha256(`global:${(0, import_nodes2.snakeCase)(idlName)}`).slice(0, 8);
  return (0, import_nodes2.bytesValueNode)("base16", hex(hash));
};
var getAnchorAccountDiscriminatorV00 = (idlName) => {
  const hash = sha256(`account:${(0, import_nodes2.pascalCase)(idlName)}`).slice(0, 8);
  return (0, import_nodes2.bytesValueNode)("base16", hex(hash));
};

// src/v00/typeNodes/ArrayTypeNode.ts
var import_nodes14 = require("@codama/nodes");

// src/v00/typeNodes/TypeNode.ts
var import_errors = require("@codama/errors");
var import_nodes13 = require("@codama/nodes");

// src/v00/typeNodes/EnumTypeNode.ts
var import_nodes9 = require("@codama/nodes");

// src/v00/typeNodes/EnumEmptyVariantTypeNode.ts
var import_nodes3 = require("@codama/nodes");
function enumEmptyVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes3.enumEmptyVariantTypeNode)(idl.name ?? "");
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
var import_nodes6 = require("@codama/nodes");

// src/v00/typeNodes/StructTypeNode.ts
var import_nodes5 = require("@codama/nodes");

// src/v00/typeNodes/StructFieldTypeNode.ts
var import_nodes4 = require("@codama/nodes");
function structFieldTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes4.structFieldTypeNode)({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes5.structTypeNode)((idl.fields ?? []).map(structFieldTypeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes6.enumStructVariantTypeNode)(
    idl.name ?? "",
    structTypeNodeFromAnchorV00({ fields: idl.fields, kind: "struct" })
  );
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
var import_nodes8 = require("@codama/nodes");

// src/v00/typeNodes/TupleTypeNode.ts
var import_nodes7 = require("@codama/nodes");
function tupleTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes7.tupleTypeNode)(idl.tuple.map(typeNodeFromAnchorV00));
}

// src/v00/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV00(idl) {
  return (0, import_nodes8.enumTupleVariantTypeNode)(idl.name ?? "", tupleTypeNodeFromAnchorV00({ tuple: idl.fields }));
}

// src/v00/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV00(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV00(variant);
    }
    if (isStructVariant(variant)) {
      return enumStructVariantTypeNodeFromAnchorV00(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV00(variant);
  });
  return (0, import_nodes9.enumTypeNode)(variants, {
    size: idl.size ? (0, import_nodes9.numberTypeNode)(idl.size) : void 0
  });
}
function isStructVariant(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v00/typeNodes/MapTypeNode.ts
var import_nodes10 = require("@codama/nodes");
function mapTypeNodeFromAnchorV00(idl) {
  const [key, value] = "hashMap" in idl ? idl.hashMap : idl.bTreeMap;
  let size;
  if (idl.size === "remainder") {
    size = (0, import_nodes10.remainderCountNode)();
  } else if (typeof idl.size === "number") {
    size = (0, import_nodes10.fixedCountNode)(idl.size);
  } else {
    size = (0, import_nodes10.prefixedCountNode)((0, import_nodes10.numberTypeNode)(idl.size ?? "u32"));
  }
  return (0, import_nodes10.mapTypeNode)(typeNodeFromAnchorV00(key), typeNodeFromAnchorV00(value), size);
}

// src/v00/typeNodes/OptionTypeNode.ts
var import_nodes11 = require("@codama/nodes");
function optionTypeNodeFromAnchorV00(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const defaultPrefix = (0, import_nodes11.numberTypeNode)("option" in idl ? "u8" : "u32");
  const defaultFixed = !("option" in idl);
  return (0, import_nodes11.optionTypeNode)(typeNodeFromAnchorV00(item), {
    fixed: idl.fixed !== void 0 ? idl.fixed : defaultFixed,
    prefix: idl.prefix ? (0, import_nodes11.numberTypeNode)(idl.prefix) : defaultPrefix
  });
}

// src/v00/typeNodes/SetTypeNode.ts
var import_nodes12 = require("@codama/nodes");
function setTypeNodeFromAnchorV00(idl) {
  const child = "hashSet" in idl ? idl.hashSet : idl.bTreeSet;
  let size;
  if (idl.size === "remainder") {
    size = (0, import_nodes12.remainderCountNode)();
  } else if (typeof idl.size === "number") {
    size = (0, import_nodes12.fixedCountNode)(idl.size);
  } else {
    size = (0, import_nodes12.prefixedCountNode)((0, import_nodes12.numberTypeNode)(idl.size ?? "u32"));
  }
  return (0, import_nodes12.setTypeNode)(typeNodeFromAnchorV00(child), size);
}

// src/v00/typeNodes/TypeNode.ts
var IDL_V00_TYPE_LEAVES = [
  "string",
  "publicKey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV00 = (idlType) => {
  if (typeof idlType === "string" && IDL_V00_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return (0, import_nodes13.booleanTypeNode)();
    if (idlType === "publicKey") return (0, import_nodes13.publicKeyTypeNode)();
    if (idlType === "string") return (0, import_nodes13.sizePrefixTypeNode)((0, import_nodes13.stringTypeNode)("utf8"), (0, import_nodes13.numberTypeNode)("u32"));
    if (idlType === "bytes") return (0, import_nodes13.sizePrefixTypeNode)((0, import_nodes13.bytesTypeNode)(), (0, import_nodes13.numberTypeNode)("u32"));
    return (0, import_nodes13.numberTypeNode)(idlType);
  }
  if (typeof idlType !== "object") {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV00(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "string") {
    return (0, import_nodes13.definedTypeLinkNode)(idlType.defined);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV00(idlType);
  }
  if ("hashMap" in idlType && isArrayOfSize(idlType.hashMap, 2) || "bTreeMap" in idlType && isArrayOfSize(idlType.bTreeMap, 2)) {
    return mapTypeNodeFromAnchorV00(idlType);
  }
  if ("option" in idlType || "coption" in idlType) {
    return optionTypeNodeFromAnchorV00(idlType);
  }
  if ("hashSet" in idlType || "bTreeSet" in idlType) {
    return setTypeNodeFromAnchorV00(idlType);
  }
  if ("kind" in idlType && "fields" in idlType && idlType.kind === "struct") {
    return structTypeNodeFromAnchorV00(idlType);
  }
  if ("tuple" in idlType && Array.isArray(idlType.tuple)) {
    return tupleTypeNodeFromAnchorV00(idlType);
  }
  throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize(array, size) {
  return Array.isArray(array) && array.length === size;
}

// src/v00/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV00(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV00(idl.array[0]);
    return (0, import_nodes14.arrayTypeNode)(item2, (0, import_nodes14.fixedCountNode)(idl.array[1]));
  }
  const item = typeNodeFromAnchorV00(idl.vec);
  if (idl.size === "remainder") return (0, import_nodes14.arrayTypeNode)(item, (0, import_nodes14.remainderCountNode)());
  return (0, import_nodes14.arrayTypeNode)(item, (0, import_nodes14.prefixedCountNode)((0, import_nodes14.numberTypeNode)(idl.size ?? "u32")));
}

// src/v00/AccountNode.ts
function accountNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = (0, import_nodes15.camelCase)(idlName);
  const idlStruct = idl.type ?? { fields: [], kind: "struct" };
  let data = structTypeNodeFromAnchorV00(idlStruct);
  (0, import_nodes15.assertIsNode)(data, "structTypeNode");
  const hasSeeds = (idl.seeds ?? []).length > 0;
  let discriminators;
  if (origin === "anchor") {
    const discriminator = (0, import_nodes15.structFieldTypeNode)({
      defaultValue: getAnchorAccountDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: (0, import_nodes15.fixedSizeTypeNode)((0, import_nodes15.bytesTypeNode)(), 8)
    });
    data = (0, import_nodes15.structTypeNode)([discriminator, ...data.fields]);
    discriminators = [(0, import_nodes15.fieldDiscriminatorNode)("discriminator")];
  }
  return (0, import_nodes15.accountNode)({
    data,
    discriminators,
    docs: idl.docs ?? [],
    name,
    pda: hasSeeds ? (0, import_nodes15.pdaLinkNode)(name) : void 0,
    size: idl.size
  });
}

// src/v00/DefinedTypeNode.ts
var import_nodes16 = require("@codama/nodes");
function definedTypeNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV00(idlType);
  return (0, import_nodes16.definedTypeNode)({ docs: idl.docs, name, type });
}

// src/v00/ErrorNode.ts
var import_nodes17 = require("@codama/nodes");
function errorNodeFromAnchorV00(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return (0, import_nodes17.errorNode)({
    code: idl.code ?? -1,
    docs: idl.docs ?? [msg ? `${name}: ${msg}` : `${name}`],
    message: msg,
    name
  });
}

// src/v00/InstructionAccountNode.ts
var import_nodes18 = require("@codama/nodes");
function instructionAccountNodesFromAnchorV00(idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV00(account.accounts) : [instructionAccountNodeFromAnchorV00(account)]
  );
}
function instructionAccountNodeFromAnchorV00(idl) {
  const isOptional = idl.optional ?? idl.isOptional ?? false;
  const desc = idl.desc ? [idl.desc] : void 0;
  return (0, import_nodes18.instructionAccountNode)({
    docs: idl.docs ?? desc ?? [],
    isOptional,
    isSigner: idl.isOptionalSigner ? "either" : idl.isSigner ?? false,
    isWritable: idl.isMut ?? false,
    name: idl.name ?? ""
  });
}

// src/v00/InstructionArgumentNode.ts
var import_nodes19 = require("@codama/nodes");
function instructionArgumentNodeFromAnchorV00(idl) {
  return (0, import_nodes19.instructionArgumentNode)({
    docs: idl.docs ?? [],
    name: idl.name ?? "",
    type: typeNodeFromAnchorV00(idl.type)
  });
}

// src/v00/InstructionNode.ts
var import_nodes20 = require("@codama/nodes");
function instructionNodeFromAnchorV00(idl, origin) {
  const idlName = idl.name ?? "";
  const name = (0, import_nodes20.camelCase)(idlName);
  let dataArguments = (idl.args ?? []).map(instructionArgumentNodeFromAnchorV00);
  let discriminators;
  if (idl.discriminant) {
    const discriminatorField = (0, import_nodes20.instructionArgumentNode)({
      defaultValue: (0, import_nodes20.numberValueNode)(idl.discriminant.value),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: typeNodeFromAnchorV00(idl.discriminant.type)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [(0, import_nodes20.fieldDiscriminatorNode)("discriminator")];
  } else if (origin === "anchor") {
    const discriminatorField = (0, import_nodes20.instructionArgumentNode)({
      defaultValue: getAnchorInstructionDiscriminatorV00(idlName),
      defaultValueStrategy: "omitted",
      name: "discriminator",
      type: (0, import_nodes20.fixedSizeTypeNode)((0, import_nodes20.bytesTypeNode)(), 8)
    });
    dataArguments = [discriminatorField, ...dataArguments];
    discriminators = [(0, import_nodes20.fieldDiscriminatorNode)("discriminator")];
  }
  return (0, import_nodes20.instructionNode)({
    accounts: instructionAccountNodesFromAnchorV00(idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name,
    optionalAccountStrategy: idl.legacyOptionalAccountsStrategy ? "omitted" : "programId"
  });
}

// src/v00/PdaNode.ts
var import_nodes21 = require("@codama/nodes");
function pdaNodeFromAnchorV00(idl) {
  const name = (0, import_nodes21.camelCase)(idl.name ?? "");
  const seeds = (idl.seeds ?? []).map((seed) => {
    if (seed.kind === "constant") {
      const type = (() => {
        if (seed.type === "string") return (0, import_nodes21.stringTypeNode)("utf8");
        if (seed.type === "bytes") return (0, import_nodes21.bytesTypeNode)();
        return typeNodeFromAnchorV00(seed.type);
      })();
      const value = (() => {
        if (typeof seed.value === "string") return (0, import_nodes21.stringValueNode)(seed.value);
        if (typeof seed.value === "number") return (0, import_nodes21.numberValueNode)(seed.value);
        return (0, import_nodes21.booleanValueNode)(seed.value);
      })();
      return (0, import_nodes21.constantPdaSeedNode)(type, value);
    }
    if (seed.kind === "variable") {
      return (0, import_nodes21.variablePdaSeedNode)(
        seed.name,
        typeNodeFromAnchorV00(seed.type),
        seed.description ? [seed.description] : []
      );
    }
    return (0, import_nodes21.constantPdaSeedNodeFromProgramId)();
  });
  return (0, import_nodes21.pdaNode)({ name, seeds });
}

// src/v00/ProgramNode.ts
var import_nodes22 = require("@codama/nodes");
function programNodeFromAnchorV00(idl) {
  const origin = idl?.metadata?.origin ?? "anchor";
  const pdas = (idl.accounts ?? []).filter((account) => (account.seeds ?? []).length > 0).map(pdaNodeFromAnchorV00);
  const accounts = (idl.accounts ?? []).map((a) => accountNodeFromAnchorV00(a, origin));
  const instructions = (idl.instructions ?? []).map((i) => instructionNodeFromAnchorV00(i, origin));
  return (0, import_nodes22.programNode)({
    accounts,
    definedTypes: (idl?.types ?? []).map(definedTypeNodeFromAnchorV00),
    errors: (idl?.errors ?? []).map(errorNodeFromAnchorV00),
    instructions,
    name: idl?.name ?? "",
    origin,
    pdas,
    publicKey: idl?.metadata?.address ?? "",
    version: idl.version
  });
}

// src/v00/RootNode.ts
var import_nodes23 = require("@codama/nodes");
function rootNodeFromAnchorV00(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV00(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV00);
  return (0, import_nodes23.rootNode)(programNode3, additionalProgramNodes);
}

// src/v01/AccountNode.ts
var import_errors4 = require("@codama/errors");
var import_nodes34 = require("@codama/nodes");

// src/v01/typeNodes/ArrayTypeNode.ts
var import_nodes33 = require("@codama/nodes");

// src/v01/typeNodes/TypeNode.ts
var import_errors3 = require("@codama/errors");
var import_nodes32 = require("@codama/nodes");

// src/v01/typeNodes/EnumTypeNode.ts
var import_nodes30 = require("@codama/nodes");

// src/v01/typeNodes/EnumEmptyVariantTypeNode.ts
var import_nodes24 = require("@codama/nodes");
function enumEmptyVariantTypeNodeFromAnchorV01(idl) {
  return (0, import_nodes24.enumEmptyVariantTypeNode)(idl.name ?? "");
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
var import_nodes27 = require("@codama/nodes");

// src/v01/typeNodes/StructTypeNode.ts
var import_nodes26 = require("@codama/nodes");

// src/v01/typeNodes/StructFieldTypeNode.ts
var import_errors2 = require("@codama/errors");
var import_nodes25 = require("@codama/nodes");
function structFieldTypeNodeFromAnchorV01(idl) {
  if (!isStructField(idl)) {
    throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idl)
    });
  }
  return (0, import_nodes25.structFieldTypeNode)({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type)
  });
}
function isStructField(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/StructTypeNode.ts
function structTypeNodeFromAnchorV01(idl) {
  const fields = idl.fields ?? [];
  return (0, import_nodes26.structTypeNode)(fields.map(structFieldTypeNodeFromAnchorV01));
}

// src/v01/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNodeFromAnchorV01(idl) {
  return (0, import_nodes27.enumStructVariantTypeNode)(
    idl.name ?? "",
    structTypeNodeFromAnchorV01({ fields: idl.fields, kind: "struct" })
  );
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
var import_nodes29 = require("@codama/nodes");

// src/v01/typeNodes/TupleTypeNode.ts
var import_nodes28 = require("@codama/nodes");
function tupleTypeNodeFromAnchorV01(idl) {
  return (0, import_nodes28.tupleTypeNode)(idl.map(typeNodeFromAnchorV01));
}

// src/v01/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNodeFromAnchorV01(idl) {
  return (0, import_nodes29.enumTupleVariantTypeNode)(idl.name ?? "", tupleTypeNodeFromAnchorV01(idl.fields));
}

// src/v01/typeNodes/EnumTypeNode.ts
function enumTypeNodeFromAnchorV01(idl) {
  const variants = idl.variants.map((variant) => {
    if (!variant.fields || variant.fields.length <= 0) {
      return enumEmptyVariantTypeNodeFromAnchorV01(variant);
    }
    if (isStructVariant2(variant)) {
      return enumStructVariantTypeNodeFromAnchorV01(variant);
    }
    return enumTupleVariantTypeNodeFromAnchorV01(
      variant
    );
  });
  return (0, import_nodes30.enumTypeNode)(variants);
}
function isStructVariant2(variant) {
  const field = variant.fields[0];
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/OptionTypeNode.ts
var import_nodes31 = require("@codama/nodes");
function optionTypeNodeFromAnchorV01(idl) {
  const item = "option" in idl ? idl.option : idl.coption;
  const hasOptionField = "option" in idl;
  const prefix = (0, import_nodes31.numberTypeNode)(hasOptionField ? "u8" : "u32");
  const fixed = !hasOptionField;
  return (0, import_nodes31.optionTypeNode)(typeNodeFromAnchorV01(item), {
    fixed,
    prefix
  });
}

// src/v01/typeNodes/TypeNode.ts
var IDL_V01_TYPE_LEAVES = [
  "string",
  "pubkey",
  "bytes",
  "bool",
  "u8",
  "u16",
  "u32",
  "u64",
  "u128",
  "i8",
  "i16",
  "i32",
  "i64",
  "i128",
  "f32",
  "f64",
  "shortU16"
];
var typeNodeFromAnchorV01 = (idlType) => {
  if (typeof idlType === "string" && IDL_V01_TYPE_LEAVES.includes(idlType)) {
    if (idlType === "bool") return (0, import_nodes32.booleanTypeNode)();
    if (idlType === "pubkey") return (0, import_nodes32.publicKeyTypeNode)();
    if (idlType === "string") return (0, import_nodes32.sizePrefixTypeNode)((0, import_nodes32.stringTypeNode)("utf8"), (0, import_nodes32.numberTypeNode)("u32"));
    if (idlType === "bytes") return (0, import_nodes32.sizePrefixTypeNode)((0, import_nodes32.bytesTypeNode)(), (0, import_nodes32.numberTypeNode)("u32"));
    return (0, import_nodes32.numberTypeNode)(idlType);
  }
  if (typeof idlType !== "object") {
    throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
      idlType: JSON.stringify(idlType)
    });
  }
  if ("array" in idlType && isArrayOfSize2(idlType.array, 2)) {
    return arrayTypeNodeFromAnchorV01(idlType);
  }
  if ("vec" in idlType) {
    return arrayTypeNodeFromAnchorV01(idlType);
  }
  if ("defined" in idlType && typeof idlType.defined === "object") {
    return (0, import_nodes32.definedTypeLinkNode)(idlType.defined.name);
  }
  if ("kind" in idlType && idlType.kind === "enum" && "variants" in idlType) {
    return enumTypeNodeFromAnchorV01(idlType);
  }
  if ("option" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType);
  }
  if ("coption" in idlType) {
    return optionTypeNodeFromAnchorV01(idlType);
  }
  if ("kind" in idlType && idlType.kind === "struct") {
    const fields = idlType.fields ?? [];
    if (isStructFieldArray(fields)) {
      return structTypeNodeFromAnchorV01(idlType);
    }
    if (isTupleFieldArray(fields)) {
      return tupleTypeNodeFromAnchorV01(fields);
    }
  }
  throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__ANCHOR__UNRECOGNIZED_IDL_TYPE, {
    idlType: JSON.stringify(idlType)
  });
};
function isArrayOfSize2(array, size) {
  return Array.isArray(array) && array.length === size;
}
function isStructFieldArray(field) {
  return field.every(isStructField2);
}
function isTupleFieldArray(field) {
  return field.every((f) => !isStructField2(f));
}
function isStructField2(field) {
  return typeof field === "object" && "name" in field && "type" in field;
}

// src/v01/typeNodes/ArrayTypeNode.ts
function arrayTypeNodeFromAnchorV01(idl) {
  if ("array" in idl) {
    const item2 = typeNodeFromAnchorV01(idl.array[0]);
    return (0, import_nodes33.arrayTypeNode)(item2, (0, import_nodes33.fixedCountNode)(idl.array[1]));
  }
  const item = typeNodeFromAnchorV01(idl.vec);
  return (0, import_nodes33.arrayTypeNode)(item, (0, import_nodes33.prefixedCountNode)((0, import_nodes33.numberTypeNode)("u32")));
}

// src/v01/AccountNode.ts
function accountNodeFromAnchorV01(idl, types) {
  const name = (0, import_nodes34.camelCase)(idl.name);
  const type = types.find(({ name: name2 }) => name2 === idl.name);
  if (!type) {
    throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { name: idl.name });
  }
  const data = typeNodeFromAnchorV01(type.type);
  (0, import_nodes34.assertIsNode)(data, "structTypeNode");
  const discriminator = (0, import_nodes34.structFieldTypeNode)({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: (0, import_nodes34.fixedSizeTypeNode)((0, import_nodes34.bytesTypeNode)(), idl.discriminator.length)
  });
  return (0, import_nodes34.accountNode)({
    data: (0, import_nodes34.structTypeNode)([discriminator, ...data.fields]),
    discriminators: [(0, import_nodes34.fieldDiscriminatorNode)("discriminator")],
    name
  });
}
function accountNodeFromAnchorV01WithTypeDefinition(types) {
  return function(idl) {
    return accountNodeFromAnchorV01(idl, types);
  };
}

// src/v01/DefinedTypeNode.ts
var import_nodes35 = require("@codama/nodes");
function definedTypeNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const idlType = idl.type ?? { fields: [], kind: "struct" };
  const type = typeNodeFromAnchorV01(idlType);
  return (0, import_nodes35.definedTypeNode)({ docs: idl.docs, name, type });
}

// src/v01/ErrorNode.ts
var import_nodes36 = require("@codama/nodes");
function errorNodeFromAnchorV01(idl) {
  const name = idl.name ?? "";
  const msg = idl.msg ?? "";
  return (0, import_nodes36.errorNode)({
    code: idl.code ?? -1,
    docs: `${name}: ${msg}`,
    message: msg,
    name
  });
}

// src/v01/InstructionAccountNode.ts
var import_errors5 = require("@codama/errors");
var import_nodes37 = require("@codama/nodes");
var import_codecs = require("@solana/codecs");
function instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, idl) {
  return idl.flatMap(
    (account) => "accounts" in account ? instructionAccountNodesFromAnchorV01(allAccounts, instructionArguments, account.accounts) : [instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, account)]
  );
}
function instructionAccountNodeFromAnchorV01(allAccounts, instructionArguments, idl) {
  const isOptional = idl.optional ?? false;
  const docs = idl.docs ?? [];
  const isSigner = idl.signer ?? false;
  const isWritable = idl.writable ?? false;
  const name = idl.name ?? "";
  let defaultValue;
  if (idl.address) {
    defaultValue = (0, import_nodes37.publicKeyValueNode)(idl.address, name);
  } else if (idl.pda) {
    const seedsWithNestedPaths = idl.pda.seeds.some((seed) => "path" in seed && seed.path.includes("."));
    if (!seedsWithNestedPaths) {
      const [seeds, lookups] = idl.pda.seeds.reduce(
        ([seeds2, lookups2], seed) => {
          const kind = seed.kind;
          switch (kind) {
            case "const":
              return [[...seeds2, (0, import_nodes37.constantPdaSeedNodeFromBytes)("base16", hex(seed.value))], lookups2];
            case "account": {
              const path = seed.path.split(".");
              if (path.length === 1) {
                return [
                  [...seeds2, (0, import_nodes37.variablePdaSeedNode)(seed.path, (0, import_nodes37.publicKeyTypeNode)())],
                  [...lookups2, (0, import_nodes37.pdaSeedValueNode)(seed.path, (0, import_nodes37.accountValueNode)(seed.path))]
                ];
              } else if (path.length === 2) {
                const accountName = (0, import_nodes37.camelCase)(seed.account ?? "");
                const accountNode3 = allAccounts.find(({ name: name2 }) => name2 === accountName);
                if (!accountNode3) {
                  throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__ACCOUNT_TYPE_MISSING, { kind });
                }
                const fieldName = (0, import_nodes37.camelCase)(path[1]);
                const accountFields = (0, import_nodes37.resolveNestedTypeNode)(accountNode3.data).fields;
                const fieldNode = accountFields.find(({ name: name2 }) => name2 === fieldName);
                if (!fieldNode) {
                  throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                    idlType: seed.account,
                    path: seed.path
                  });
                }
                const seedName = (0, import_nodes37.camelCase)(seed.path);
                return [[...seeds2, (0, import_nodes37.variablePdaSeedNode)(seedName, fieldNode.type)], []];
              } else {
                throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__TYPE_PATH_MISSING, {
                  idlType: seed,
                  path: seed.path
                });
              }
            }
            case "arg": {
              const argumentName = (0, import_nodes37.camelCase)(seed.path);
              const argumentNode = instructionArguments.find(({ name: name2 }) => name2 === argumentName);
              if (!argumentNode) {
                throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__ARGUMENT_TYPE_MISSING, { name: seed.path });
              }
              return [
                [...seeds2, (0, import_nodes37.variablePdaSeedNode)(seed.path, argumentNode.type)],
                [...lookups2, (0, import_nodes37.pdaSeedValueNode)(seed.path, (0, import_nodes37.argumentValueNode)(seed.path))]
              ];
            }
            default:
              throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__SEED_KIND_UNIMPLEMENTED, { kind });
          }
        },
        [[], []]
      );
      let programId;
      if (idl.pda.program !== void 0) {
        const kind = idl.pda.program.kind;
        switch (kind) {
          case "const": {
            programId = (0, import_codecs.getBase58Codec)().decode(new Uint8Array(idl.pda.program.value));
            break;
          }
          default: {
            throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__ANCHOR__PROGRAM_ID_KIND_UNIMPLEMENTED, { kind });
          }
        }
      }
      defaultValue = (0, import_nodes37.pdaValueNode)(
        (0, import_nodes37.pdaNode)({ name, seeds, ...programId !== void 0 ? { programId } : {} }),
        lookups
      );
    }
  }
  return (0, import_nodes37.instructionAccountNode)({
    defaultValue,
    docs,
    isOptional,
    isSigner,
    isWritable,
    name
  });
}

// src/v01/InstructionArgumentNode.ts
var import_nodes38 = require("@codama/nodes");
function instructionArgumentNodeFromAnchorV01(idl) {
  return (0, import_nodes38.instructionArgumentNode)({
    docs: idl.docs ?? [],
    name: idl.name,
    type: typeNodeFromAnchorV01(idl.type)
  });
}

// src/v01/InstructionNode.ts
var import_nodes39 = require("@codama/nodes");
function instructionNodeFromAnchorV01(allAccounts, idl) {
  const name = idl.name;
  let dataArguments = idl.args.map(instructionArgumentNodeFromAnchorV01);
  const discriminatorField = (0, import_nodes39.instructionArgumentNode)({
    defaultValue: getAnchorDiscriminatorV01(idl.discriminator),
    defaultValueStrategy: "omitted",
    name: "discriminator",
    type: (0, import_nodes39.fixedSizeTypeNode)((0, import_nodes39.bytesTypeNode)(), idl.discriminator.length)
  });
  dataArguments = [discriminatorField, ...dataArguments];
  const discriminators = [(0, import_nodes39.fieldDiscriminatorNode)("discriminator")];
  return (0, import_nodes39.instructionNode)({
    accounts: instructionAccountNodesFromAnchorV01(allAccounts, dataArguments, idl.accounts ?? []),
    arguments: dataArguments,
    discriminators,
    docs: idl.docs ?? [],
    name: (0, import_nodes39.camelCase)(name),
    optionalAccountStrategy: "programId"
  });
}

// src/v01/ProgramNode.ts
var import_nodes40 = require("@codama/nodes");
function programNodeFromAnchorV01(idl) {
  const types = idl.types ?? [];
  const accounts = idl.accounts ?? [];
  const instructions = idl.instructions ?? [];
  const errors = idl.errors ?? [];
  const filteredTypes = types.filter((type) => !accounts.some((account) => account.name === type.name));
  const definedTypes = filteredTypes.map(definedTypeNodeFromAnchorV01);
  const accountNodeFromAnchorV012 = accountNodeFromAnchorV01WithTypeDefinition(types);
  const accountNodes = accounts.map(accountNodeFromAnchorV012);
  return (0, import_nodes40.programNode)({
    accounts: accountNodes,
    definedTypes,
    errors: errors.map(errorNodeFromAnchorV01),
    instructions: instructions.map((instruction) => instructionNodeFromAnchorV01(accountNodes, instruction)),
    name: idl.metadata.name,
    origin: "anchor",
    publicKey: idl.address,
    version: idl.metadata.version
  });
}

// src/v01/RootNode.ts
var import_nodes41 = require("@codama/nodes");
function rootNodeFromAnchorV01(program, additionalPrograms = []) {
  const programNode3 = programNodeFromAnchorV01(program);
  const additionalProgramNodes = additionalPrograms.map(programNodeFromAnchorV01);
  return (0, import_nodes41.rootNode)(programNode3, additionalProgramNodes);
}

// src/index.ts
function rootNodeFromAnchor(idl) {
  return (0, import_visitors2.visit)(rootNodeFromAnchorWithoutDefaultVisitor(idl), defaultVisitor());
}
function rootNodeFromAnchorWithoutDefaultVisitor(idl) {
  if (idl.metadata?.spec === "0.1.0") {
    return rootNodeFromAnchorV01(idl);
  }
  return rootNodeFromAnchorV00(idl);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  accountNodeFromAnchorV00,
  accountNodeFromAnchorV01,
  accountNodeFromAnchorV01WithTypeDefinition,
  arrayTypeNodeFromAnchorV00,
  arrayTypeNodeFromAnchorV01,
  definedTypeNodeFromAnchorV00,
  definedTypeNodeFromAnchorV01,
  enumEmptyVariantTypeNodeFromAnchorV00,
  enumEmptyVariantTypeNodeFromAnchorV01,
  enumStructVariantTypeNodeFromAnchorV00,
  enumStructVariantTypeNodeFromAnchorV01,
  enumTupleVariantTypeNodeFromAnchorV00,
  enumTupleVariantTypeNodeFromAnchorV01,
  enumTypeNodeFromAnchorV00,
  enumTypeNodeFromAnchorV01,
  errorNodeFromAnchorV00,
  errorNodeFromAnchorV01,
  getAnchorAccountDiscriminatorV00,
  getAnchorDiscriminatorV01,
  getAnchorInstructionDiscriminatorV00,
  instructionAccountNodeFromAnchorV00,
  instructionAccountNodeFromAnchorV01,
  instructionAccountNodesFromAnchorV00,
  instructionAccountNodesFromAnchorV01,
  instructionArgumentNodeFromAnchorV00,
  instructionArgumentNodeFromAnchorV01,
  instructionNodeFromAnchorV00,
  instructionNodeFromAnchorV01,
  mapTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV00,
  optionTypeNodeFromAnchorV01,
  pdaNodeFromAnchorV00,
  programNodeFromAnchorV00,
  programNodeFromAnchorV01,
  rootNodeFromAnchor,
  rootNodeFromAnchorV00,
  rootNodeFromAnchorV01,
  rootNodeFromAnchorWithoutDefaultVisitor,
  setTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV00,
  structFieldTypeNodeFromAnchorV01,
  structTypeNodeFromAnchorV00,
  structTypeNodeFromAnchorV01,
  tupleTypeNodeFromAnchorV00,
  tupleTypeNodeFromAnchorV01,
  typeNodeFromAnchorV00,
  typeNodeFromAnchorV01
});
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.node.cjs.map