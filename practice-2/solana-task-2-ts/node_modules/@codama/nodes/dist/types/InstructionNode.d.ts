import type { DiscriminatorNode, InstructionAccountNode, InstructionArgumentNode, InstructionByteDeltaNode, InstructionNode, InstructionRemainingAccountsNode, OptionalAccountStrategy, ProgramNode, RootNode } from '@codama/node-types';
import { DocsInput } from './shared';
type SubInstructionNode = InstructionNode;
export type InstructionNodeInput<TAccounts extends InstructionAccountNode[] = InstructionAccountNode[], TArguments extends InstructionArgumentNode[] = InstructionArgumentNode[], TExtraArguments extends InstructionArgumentNode[] | undefined = InstructionArgumentNode[] | undefined, TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined = InstructionRemainingAccountsNode[] | undefined, TByteDeltas extends InstructionByteDeltaNode[] | undefined = InstructionByteDeltaNode[] | undefined, TDiscriminators extends DiscriminatorNode[] | undefined = DiscriminatorNode[] | undefined, TSubInstructions extends SubInstructionNode[] | undefined = SubInstructionNode[] | undefined> = Omit<Partial<InstructionNode<TAccounts, TArguments, TExtraArguments, TRemainingAccounts, TByteDeltas, TDiscriminators, TSubInstructions>>, 'docs' | 'kind' | 'name'> & {
    readonly docs?: DocsInput;
    readonly name: string;
};
export declare function instructionNode<const TAccounts extends InstructionAccountNode[] = [], const TArguments extends InstructionArgumentNode[] = [], const TExtraArguments extends InstructionArgumentNode[] | undefined = undefined, const TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined = undefined, const TByteDeltas extends InstructionByteDeltaNode[] | undefined = undefined, const TDiscriminators extends DiscriminatorNode[] | undefined = undefined, const TSubInstructions extends SubInstructionNode[] | undefined = undefined>(input: InstructionNodeInput<TAccounts, TArguments, TExtraArguments, TRemainingAccounts, TByteDeltas, TDiscriminators, TSubInstructions>): InstructionNode<TAccounts, TArguments, TExtraArguments, TRemainingAccounts, TByteDeltas, TDiscriminators, TSubInstructions>;
export declare function parseOptionalAccountStrategy(optionalAccountStrategy: OptionalAccountStrategy | undefined): OptionalAccountStrategy;
export declare function getAllInstructionArguments(node: InstructionNode): InstructionArgumentNode[];
export declare function getAllInstructionsWithSubs(node: InstructionNode | ProgramNode | RootNode, config?: {
    leavesOnly?: boolean;
    subInstructionsFirst?: boolean;
}): InstructionNode[];
export {};
//# sourceMappingURL=InstructionNode.d.ts.map