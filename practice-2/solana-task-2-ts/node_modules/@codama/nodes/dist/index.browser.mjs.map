{"version":3,"sources":["../src/index.ts","../src/shared/docs.ts","../src/shared/stringCases.ts","../src/contextualValueNodes/AccountBumpValueNode.ts","../src/contextualValueNodes/AccountValueNode.ts","../src/contextualValueNodes/ArgumentValueNode.ts","../src/contextualValueNodes/ConditionalValueNode.ts","../src/valueNodes/ValueNode.ts","../src/contextualValueNodes/ContextualValueNode.ts","../src/contextualValueNodes/IdentityValueNode.ts","../src/contextualValueNodes/PayerValueNode.ts","../src/contextualValueNodes/PdaSeedValueNode.ts","../src/linkNodes/ProgramLinkNode.ts","../src/linkNodes/AccountLinkNode.ts","../src/linkNodes/DefinedTypeLinkNode.ts","../src/linkNodes/InstructionLinkNode.ts","../src/linkNodes/InstructionAccountLinkNode.ts","../src/linkNodes/InstructionArgumentLinkNode.ts","../src/linkNodes/LinkNode.ts","../src/linkNodes/PdaLinkNode.ts","../src/contextualValueNodes/PdaValueNode.ts","../src/contextualValueNodes/ProgramIdValueNode.ts","../src/contextualValueNodes/ResolverValueNode.ts","../src/countNodes/CountNode.ts","../src/countNodes/FixedCountNode.ts","../src/countNodes/PrefixedCountNode.ts","../src/countNodes/RemainderCountNode.ts","../src/discriminatorNodes/ConstantDiscriminatorNode.ts","../src/discriminatorNodes/DiscriminatorNode.ts","../src/discriminatorNodes/FieldDiscriminatorNode.ts","../src/discriminatorNodes/SizeDiscriminatorNode.ts","../src/typeNodes/BytesTypeNode.ts","../src/typeNodes/PublicKeyTypeNode.ts","../src/typeNodes/StringTypeNode.ts","../src/valueNodes/BytesValueNode.ts","../src/valueNodes/StringValueNode.ts","../src/pdaSeedNodes/ConstantPdaSeedNode.ts","../src/pdaSeedNodes/PdaSeedNode.ts","../src/pdaSeedNodes/VariablePdaSeedNode.ts","../src/typeNodes/AmountTypeNode.ts","../src/typeNodes/ArrayTypeNode.ts","../src/typeNodes/NumberTypeNode.ts","../src/typeNodes/BooleanTypeNode.ts","../src/typeNodes/DateTimeTypeNode.ts","../src/typeNodes/EnumEmptyVariantTypeNode.ts","../src/typeNodes/EnumStructVariantTypeNode.ts","../src/typeNodes/EnumTupleVariantTypeNode.ts","../src/typeNodes/EnumTypeNode.ts","../src/typeNodes/EnumVariantTypeNode.ts","../src/typeNodes/FixedSizeTypeNode.ts","../src/typeNodes/HiddenPrefixTypeNode.ts","../src/typeNodes/HiddenSuffixTypeNode.ts","../src/typeNodes/MapTypeNode.ts","../src/typeNodes/NestedTypeNode.ts","../src/Node.ts","../src/typeNodes/TypeNode.ts","../src/typeNodes/OptionTypeNode.ts","../src/typeNodes/PostOffsetTypeNode.ts","../src/typeNodes/PreOffsetTypeNode.ts","../src/typeNodes/RemainderOptionTypeNode.ts","../src/typeNodes/SentinelTypeNode.ts","../src/typeNodes/SetTypeNode.ts","../src/typeNodes/SizePrefixTypeNode.ts","../src/typeNodes/SolAmountTypeNode.ts","../src/typeNodes/StructFieldTypeNode.ts","../src/typeNodes/StructTypeNode.ts","../src/typeNodes/TupleTypeNode.ts","../src/typeNodes/ZeroableOptionTypeNode.ts","../src/valueNodes/ArrayValueNode.ts","../src/valueNodes/BooleanValueNode.ts","../src/valueNodes/ConstantValueNode.ts","../src/valueNodes/EnumValueNode.ts","../src/valueNodes/MapEntryValueNode.ts","../src/valueNodes/MapValueNode.ts","../src/valueNodes/NoneValueNode.ts","../src/valueNodes/NumberValueNode.ts","../src/valueNodes/PublicKeyValueNode.ts","../src/valueNodes/SetValueNode.ts","../src/valueNodes/SomeValueNode.ts","../src/valueNodes/StructFieldValueNode.ts","../src/valueNodes/StructValueNode.ts","../src/valueNodes/TupleValueNode.ts","../src/AccountNode.ts","../src/DefinedTypeNode.ts","../src/ErrorNode.ts","../src/InstructionAccountNode.ts","../src/InstructionArgumentNode.ts","../src/InstructionByteDeltaNode.ts","../src/ProgramNode.ts","../src/InstructionNode.ts","../src/InstructionRemainingAccountsNode.ts","../src/PdaNode.ts","../src/RootNode.ts"],"sourcesContent":["export * from '@codama/node-types';\n\nexport * from './contextualValueNodes';\nexport * from './countNodes';\nexport * from './discriminatorNodes';\nexport * from './linkNodes';\nexport * from './pdaSeedNodes';\nexport * from './typeNodes';\nexport * from './valueNodes';\n\nexport * from './shared';\n\nexport * from './AccountNode';\nexport * from './DefinedTypeNode';\nexport * from './ErrorNode';\nexport * from './InstructionAccountNode';\nexport * from './InstructionArgumentNode';\nexport * from './InstructionByteDeltaNode';\nexport * from './InstructionNode';\nexport * from './InstructionRemainingAccountsNode';\nexport * from './Node';\nexport * from './PdaNode';\nexport * from './ProgramNode';\nexport * from './RootNode';\n","import type { Docs } from '@codama/node-types';\n\nexport type DocsInput = string[] | string;\n\nexport function parseDocs(docs: DocsInput | null | undefined): Docs {\n    if (docs === null || docs === undefined) return [];\n    return Array.isArray(docs) ? docs : [docs];\n}\n","import type {\n    CamelCaseString,\n    KebabCaseString,\n    PascalCaseString,\n    SnakeCaseString,\n    TitleCaseString,\n} from '@codama/node-types';\n\nexport function capitalize(str: string): string {\n    if (str.length === 0) return str;\n    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n}\n\nexport function titleCase(str: string): TitleCaseString {\n    return str\n        .replace(/([A-Z])/g, ' $1')\n        .split(/[^a-zA-Z0-9]+/)\n        .filter(word => word.length > 0)\n        .map(capitalize)\n        .join(' ') as TitleCaseString;\n}\n\nexport function pascalCase(str: string): PascalCaseString {\n    return titleCase(str).split(' ').join('') as PascalCaseString;\n}\n\nexport function camelCase(str: string): CamelCaseString {\n    if (str.length === 0) return str as CamelCaseString;\n    const pascalStr = pascalCase(str);\n    return (pascalStr.charAt(0).toLowerCase() + pascalStr.slice(1)) as CamelCaseString;\n}\n\nexport function kebabCase(str: string): KebabCaseString {\n    return titleCase(str).split(' ').join('-').toLowerCase() as KebabCaseString;\n}\n\nexport function snakeCase(str: string): SnakeCaseString {\n    return titleCase(str).split(' ').join('_').toLowerCase() as SnakeCaseString;\n}\n","import type { AccountBumpValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function accountBumpValueNode(name: string): AccountBumpValueNode {\n    return Object.freeze({\n        kind: 'accountBumpValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { AccountValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function accountValueNode(name: string): AccountValueNode {\n    return Object.freeze({\n        kind: 'accountValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { ArgumentValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function argumentValueNode(name: string): ArgumentValueNode {\n    return Object.freeze({\n        kind: 'argumentValueNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type {\n    AccountValueNode,\n    ArgumentValueNode,\n    ConditionalValueNode,\n    InstructionInputValueNode,\n    ResolverValueNode,\n    ValueNode,\n} from '@codama/node-types';\n\ntype ConditionNode = AccountValueNode | ArgumentValueNode | ResolverValueNode;\n\nexport function conditionalValueNode<\n    TCondition extends ConditionNode,\n    TValue extends ValueNode | undefined = undefined,\n    TIfTrue extends InstructionInputValueNode | undefined = undefined,\n    TIfFalse extends InstructionInputValueNode | undefined = undefined,\n>(input: {\n    condition: TCondition;\n    ifFalse?: TIfFalse;\n    ifTrue?: TIfTrue;\n    value?: TValue;\n}): ConditionalValueNode<TCondition, TValue, TIfTrue, TIfFalse> {\n    return Object.freeze({\n        kind: 'conditionalValueNode',\n\n        // Children.\n        condition: input.condition,\n        ...(input.value !== undefined && { value: input.value }),\n        ...(input.ifTrue !== undefined && { ifTrue: input.ifTrue }),\n        ...(input.ifFalse !== undefined && { ifFalse: input.ifFalse }),\n    });\n}\n","// Standalone Value Node Registration.\nexport const STANDALONE_VALUE_NODE_KINDS = [\n    'arrayValueNode' as const,\n    'bytesValueNode' as const,\n    'booleanValueNode' as const,\n    'constantValueNode' as const,\n    'enumValueNode' as const,\n    'mapValueNode' as const,\n    'noneValueNode' as const,\n    'numberValueNode' as const,\n    'setValueNode' as const,\n    'someValueNode' as const,\n    'structValueNode' as const,\n    'tupleValueNode' as const,\n    'publicKeyValueNode' as const,\n    'stringValueNode' as const,\n];\n\n// Value Node Registration.\nexport const REGISTERED_VALUE_NODE_KINDS = [\n    ...STANDALONE_VALUE_NODE_KINDS,\n    'mapEntryValueNode' as const,\n    'structFieldValueNode' as const,\n];\n\n// Value Node Helpers.\nexport const VALUE_NODES = STANDALONE_VALUE_NODE_KINDS;\n","import { VALUE_NODES } from '../valueNodes/ValueNode';\n\n// Standalone Contextual Value Node Registration.\nexport const STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS = [\n    'accountBumpValueNode' as const,\n    'accountValueNode' as const,\n    'argumentValueNode' as const,\n    'conditionalValueNode' as const,\n    'identityValueNode' as const,\n    'payerValueNode' as const,\n    'pdaValueNode' as const,\n    'programIdValueNode' as const,\n    'resolverValueNode' as const,\n];\n\n// Contextual Value Node Registration.\nexport const REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS = [\n    ...STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS,\n    'pdaSeedValueNode' as const,\n];\n\n// Contextual Value Node Helpers.\nexport const CONTEXTUAL_VALUE_NODES = STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS;\nexport const INSTRUCTION_INPUT_VALUE_NODES = [...VALUE_NODES, ...CONTEXTUAL_VALUE_NODES, 'programLinkNode' as const];\n","import type { IdentityValueNode } from '@codama/node-types';\n\nexport function identityValueNode(): IdentityValueNode {\n    return Object.freeze({ kind: 'identityValueNode' });\n}\n","import type { PayerValueNode } from '@codama/node-types';\n\nexport function payerValueNode(): PayerValueNode {\n    return Object.freeze({ kind: 'payerValueNode' });\n}\n","import type { AccountValueNode, ArgumentValueNode, PdaSeedValueNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function pdaSeedValueNode<\n    TValue extends AccountValueNode | ArgumentValueNode | ValueNode = AccountValueNode | ArgumentValueNode | ValueNode,\n>(name: string, value: TValue): PdaSeedValueNode<TValue> {\n    return Object.freeze({\n        kind: 'pdaSeedValueNode',\n\n        // Data.\n        name: camelCase(name),\n\n        // Children.\n        value,\n    });\n}\n","import type { ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function programLinkNode(name: string): ProgramLinkNode {\n    return Object.freeze({\n        kind: 'programLinkNode',\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { AccountLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function accountLinkNode(name: string, program?: ProgramLinkNode | string): AccountLinkNode {\n    return Object.freeze({\n        kind: 'accountLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { DefinedTypeLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function definedTypeLinkNode(name: string, program?: ProgramLinkNode | string): DefinedTypeLinkNode {\n    return Object.freeze({\n        kind: 'definedTypeLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function instructionLinkNode(name: string, program?: ProgramLinkNode | string): InstructionLinkNode {\n    return Object.freeze({\n        kind: 'instructionLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionAccountLinkNode, InstructionLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { instructionLinkNode } from './InstructionLinkNode';\n\nexport function instructionAccountLinkNode(\n    name: string,\n    instruction?: InstructionLinkNode | string,\n): InstructionAccountLinkNode {\n    return Object.freeze({\n        kind: 'instructionAccountLinkNode',\n\n        // Children.\n        ...(instruction === undefined\n            ? {}\n            : { instruction: typeof instruction === 'string' ? instructionLinkNode(instruction) : instruction }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { InstructionArgumentLinkNode, InstructionLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { instructionLinkNode } from './InstructionLinkNode';\n\nexport function instructionArgumentLinkNode(\n    name: string,\n    instruction?: InstructionLinkNode | string,\n): InstructionArgumentLinkNode {\n    return Object.freeze({\n        kind: 'instructionArgumentLinkNode',\n\n        // Children.\n        ...(instruction === undefined\n            ? {}\n            : { instruction: typeof instruction === 'string' ? instructionLinkNode(instruction) : instruction }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","// Link Node Registration.\nexport const REGISTERED_LINK_NODE_KINDS = [\n    'accountLinkNode' as const,\n    'definedTypeLinkNode' as const,\n    'instructionAccountLinkNode' as const,\n    'instructionArgumentLinkNode' as const,\n    'instructionLinkNode' as const,\n    'pdaLinkNode' as const,\n    'programLinkNode' as const,\n];\n\n// Link Node Helpers.\nexport const LINK_NODES = REGISTERED_LINK_NODE_KINDS;\n","import type { PdaLinkNode, ProgramLinkNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\nimport { programLinkNode } from './ProgramLinkNode';\n\nexport function pdaLinkNode(name: string, program?: ProgramLinkNode | string): PdaLinkNode {\n    return Object.freeze({\n        kind: 'pdaLinkNode',\n\n        // Children.\n        ...(program === undefined ? {} : { program: typeof program === 'string' ? programLinkNode(program) : program }),\n\n        // Data.\n        name: camelCase(name),\n    });\n}\n","import type { PdaLinkNode, PdaNode, PdaSeedValueNode, PdaValueNode } from '@codama/node-types';\n\nimport { pdaLinkNode } from '../linkNodes';\n\nexport function pdaValueNode<const TSeeds extends PdaSeedValueNode[] = []>(\n    pda: PdaLinkNode | PdaNode | string,\n    seeds: TSeeds = [] as PdaSeedValueNode[] as TSeeds,\n): PdaValueNode<TSeeds> {\n    return Object.freeze({\n        kind: 'pdaValueNode',\n\n        // Children.\n        pda: typeof pda === 'string' ? pdaLinkNode(pda) : pda,\n        seeds,\n    });\n}\n","import type { ProgramIdValueNode } from '@codama/node-types';\n\nexport function programIdValueNode(): ProgramIdValueNode {\n    return Object.freeze({ kind: 'programIdValueNode' });\n}\n","import type { AccountValueNode, ArgumentValueNode, ResolverValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport function resolverValueNode<const TDependsOn extends (AccountValueNode | ArgumentValueNode)[] = []>(\n    name: string,\n    options: {\n        dependsOn?: TDependsOn;\n        docs?: DocsInput;\n    } = {},\n): ResolverValueNode<TDependsOn> {\n    return Object.freeze({\n        kind: 'resolverValueNode',\n\n        // Data.\n        name: camelCase(name),\n        docs: parseDocs(options.docs),\n\n        // Children.\n        dependsOn: options.dependsOn,\n    });\n}\n","// Count Node Registration.\nexport const REGISTERED_COUNT_NODE_KINDS = [\n    'fixedCountNode' as const,\n    'remainderCountNode' as const,\n    'prefixedCountNode' as const,\n];\n\n// Count Node Helpers.\nexport const COUNT_NODES = REGISTERED_COUNT_NODE_KINDS;\n","import type { FixedCountNode } from '@codama/node-types';\n\nexport function fixedCountNode(value: number): FixedCountNode {\n    return Object.freeze({\n        kind: 'fixedCountNode',\n\n        // Data.\n        value,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, PrefixedCountNode } from '@codama/node-types';\n\nexport function prefixedCountNode<TPrefix extends NestedTypeNode<NumberTypeNode>>(\n    prefix: TPrefix,\n): PrefixedCountNode<TPrefix> {\n    return Object.freeze({\n        kind: 'prefixedCountNode',\n\n        // Children.\n        prefix,\n    });\n}\n","import type { RemainderCountNode } from '@codama/node-types';\n\nexport function remainderCountNode(): RemainderCountNode {\n    return Object.freeze({ kind: 'remainderCountNode' });\n}\n","import type { ConstantDiscriminatorNode, ConstantValueNode } from '@codama/node-types';\n\nexport function constantDiscriminatorNode<TConstant extends ConstantValueNode>(\n    constant: TConstant,\n    offset: number = 0,\n): ConstantDiscriminatorNode {\n    return Object.freeze({\n        kind: 'constantDiscriminatorNode',\n\n        // Data.\n        offset,\n\n        // Children.\n        constant,\n    });\n}\n","// Discriminator Node Registration.\nexport const REGISTERED_DISCRIMINATOR_NODE_KINDS = [\n    'constantDiscriminatorNode' as const,\n    'fieldDiscriminatorNode' as const,\n    'sizeDiscriminatorNode' as const,\n];\n\n// Discriminator Node Helpers.\nexport const DISCRIMINATOR_NODES = REGISTERED_DISCRIMINATOR_NODE_KINDS;\n","import type { FieldDiscriminatorNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function fieldDiscriminatorNode(name: string, offset: number = 0): FieldDiscriminatorNode {\n    return Object.freeze({\n        kind: 'fieldDiscriminatorNode',\n\n        // Data.\n        name: camelCase(name),\n        offset,\n    });\n}\n","import type { SizeDiscriminatorNode } from '@codama/node-types';\n\nexport function sizeDiscriminatorNode(size: number): SizeDiscriminatorNode {\n    return Object.freeze({\n        kind: 'sizeDiscriminatorNode',\n\n        // Data.\n        size,\n    });\n}\n","import type { BytesTypeNode } from '@codama/node-types';\n\nexport function bytesTypeNode(): BytesTypeNode {\n    return Object.freeze({ kind: 'bytesTypeNode' });\n}\n","import type { PublicKeyTypeNode } from '@codama/node-types';\n\nexport function publicKeyTypeNode(): PublicKeyTypeNode {\n    return Object.freeze({ kind: 'publicKeyTypeNode' });\n}\n","import type { BytesEncoding, StringTypeNode } from '@codama/node-types';\n\nexport function stringTypeNode<TEncoding extends BytesEncoding>(encoding: TEncoding): StringTypeNode<TEncoding> {\n    return Object.freeze({\n        kind: 'stringTypeNode',\n\n        // Data.\n        encoding,\n    });\n}\n","import type { BytesEncoding, BytesValueNode } from '@codama/node-types';\n\nexport function bytesValueNode(encoding: BytesEncoding, data: string): BytesValueNode {\n    return Object.freeze({\n        kind: 'bytesValueNode',\n\n        // Data.\n        data,\n        encoding,\n    });\n}\n","import type { StringValueNode } from '@codama/node-types';\n\nexport function stringValueNode(string: string): StringValueNode {\n    return Object.freeze({\n        kind: 'stringValueNode',\n\n        // Data.\n        string,\n    });\n}\n","import type { BytesEncoding, ConstantPdaSeedNode, ProgramIdValueNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { programIdValueNode } from '../contextualValueNodes/ProgramIdValueNode';\nimport { bytesTypeNode } from '../typeNodes/BytesTypeNode';\nimport { publicKeyTypeNode } from '../typeNodes/PublicKeyTypeNode';\nimport { stringTypeNode } from '../typeNodes/StringTypeNode';\nimport { bytesValueNode } from '../valueNodes/BytesValueNode';\nimport { stringValueNode } from '../valueNodes/StringValueNode';\n\nexport function constantPdaSeedNode<TType extends TypeNode, TValue extends ProgramIdValueNode | ValueNode>(\n    type: TType,\n    value: TValue,\n): ConstantPdaSeedNode<TType, TValue> {\n    return Object.freeze({\n        kind: 'constantPdaSeedNode',\n\n        // Children.\n        type,\n        value,\n    });\n}\n\nexport function constantPdaSeedNodeFromProgramId() {\n    return constantPdaSeedNode(publicKeyTypeNode(), programIdValueNode());\n}\n\nexport function constantPdaSeedNodeFromString<TEncoding extends BytesEncoding>(encoding: TEncoding, string: string) {\n    return constantPdaSeedNode(stringTypeNode(encoding), stringValueNode(string));\n}\n\nexport function constantPdaSeedNodeFromBytes<TEncoding extends BytesEncoding>(encoding: TEncoding, data: string) {\n    return constantPdaSeedNode(bytesTypeNode(), bytesValueNode(encoding, data));\n}\n","// Pda Seed Node Registration.\nexport const REGISTERED_PDA_SEED_NODE_KINDS = ['constantPdaSeedNode' as const, 'variablePdaSeedNode' as const];\n\n// Pda Seed Node Helpers.\nexport const PDA_SEED_NODES = REGISTERED_PDA_SEED_NODE_KINDS;\n","import type { TypeNode, VariablePdaSeedNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport function variablePdaSeedNode<TType extends TypeNode>(\n    name: string,\n    type: TType,\n    docs?: DocsInput,\n): VariablePdaSeedNode<TType> {\n    return Object.freeze({\n        kind: 'variablePdaSeedNode',\n\n        // Data.\n        name: camelCase(name),\n        docs: parseDocs(docs),\n\n        // Children.\n        type,\n    });\n}\n","import type { AmountTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nexport function amountTypeNode<TNumber extends NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n    decimals: number,\n    unit?: string,\n): AmountTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'amountTypeNode',\n\n        // Data.\n        decimals,\n        ...(unit !== undefined && { unit }),\n\n        // Children.\n        number,\n    });\n}\n","import type { ArrayTypeNode, CountNode, TypeNode } from '@codama/node-types';\n\nexport function arrayTypeNode<TItem extends TypeNode, TCount extends CountNode>(\n    item: TItem,\n    count: TCount,\n): ArrayTypeNode<TItem, TCount> {\n    return Object.freeze({\n        kind: 'arrayTypeNode',\n\n        // Children.\n        item,\n        count,\n    });\n}\n","import type { NumberFormat, NumberTypeNode } from '@codama/node-types';\n\nexport function numberTypeNode<TFormat extends NumberFormat = NumberFormat>(\n    format: TFormat,\n    endian: 'be' | 'le' = 'le',\n): NumberTypeNode<TFormat> {\n    return Object.freeze({\n        kind: 'numberTypeNode',\n\n        // Data.\n        format,\n        endian,\n    });\n}\n\nexport function isSignedInteger(node: NumberTypeNode): boolean {\n    return node.format.startsWith('i');\n}\n\nexport function isUnsignedInteger(node: NumberTypeNode): boolean {\n    return node.format.startsWith('u') || node.format === 'shortU16';\n}\n\nexport function isInteger(node: NumberTypeNode): boolean {\n    return !node.format.startsWith('f');\n}\n\nexport function isDecimal(node: NumberTypeNode): boolean {\n    return node.format.startsWith('f');\n}\n","import type { BooleanTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function booleanTypeNode<TSize extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>>(\n    size?: TSize,\n): BooleanTypeNode<TSize> {\n    return Object.freeze({\n        kind: 'booleanTypeNode',\n\n        // Children.\n        size: (size ?? numberTypeNode('u8')) as TSize,\n    });\n}\n","import type { DateTimeTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nexport function dateTimeTypeNode<TNumber extends NestedTypeNode<NumberTypeNode> = NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n): DateTimeTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'dateTimeTypeNode',\n\n        // Children.\n        number,\n    });\n}\n","import type { EnumEmptyVariantTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumEmptyVariantTypeNode(name: string, discriminator?: number): EnumEmptyVariantTypeNode {\n    return Object.freeze({\n        kind: 'enumEmptyVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        discriminator,\n    });\n}\n","import type { EnumStructVariantTypeNode, NestedTypeNode, StructTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumStructVariantTypeNode<TStruct extends NestedTypeNode<StructTypeNode>>(\n    name: string,\n    struct: TStruct,\n    discriminator?: number,\n): EnumStructVariantTypeNode<TStruct> {\n    return Object.freeze({\n        kind: 'enumStructVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        ...(discriminator !== undefined && { discriminator }),\n\n        // Children.\n        struct,\n    });\n}\n","import type { EnumTupleVariantTypeNode, NestedTypeNode, TupleTypeNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function enumTupleVariantTypeNode<TTuple extends NestedTypeNode<TupleTypeNode>>(\n    name: string,\n    tuple: TTuple,\n    discriminator?: number,\n): EnumTupleVariantTypeNode<TTuple> {\n    return Object.freeze({\n        kind: 'enumTupleVariantTypeNode',\n\n        // Data.\n        name: camelCase(name),\n        ...(discriminator !== undefined && { discriminator }),\n\n        // Children.\n        tuple,\n    });\n}\n","import type { EnumTypeNode, EnumVariantTypeNode, NestedTypeNode, NumberTypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function enumTypeNode<\n    const TVariants extends EnumVariantTypeNode[],\n    TSize extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>,\n>(variants: TVariants, options: { size?: TSize } = {}): EnumTypeNode<TVariants, TSize> {\n    return Object.freeze({\n        kind: 'enumTypeNode',\n\n        // Children.\n        variants,\n        size: (options.size ?? numberTypeNode('u8')) as TSize,\n    });\n}\n\nexport function isScalarEnum(node: EnumTypeNode): boolean {\n    return node.variants.every(variant => variant.kind === 'enumEmptyVariantTypeNode');\n}\n\nexport function isDataEnum(node: EnumTypeNode): boolean {\n    return !isScalarEnum(node);\n}\n","export const ENUM_VARIANT_TYPE_NODES = [\n    'enumEmptyVariantTypeNode' as const,\n    'enumStructVariantTypeNode' as const,\n    'enumTupleVariantTypeNode' as const,\n];\n","import type { FixedSizeTypeNode, TypeNode } from '@codama/node-types';\n\nexport function fixedSizeTypeNode<TType extends TypeNode>(type: TType, size: number): FixedSizeTypeNode<TType> {\n    return Object.freeze({\n        kind: 'fixedSizeTypeNode',\n\n        // Data.\n        size,\n\n        // Children.\n        type,\n    });\n}\n","import type { ConstantValueNode, HiddenPrefixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function hiddenPrefixTypeNode<TType extends TypeNode, const TPrefix extends ConstantValueNode[]>(\n    type: TType,\n    prefix: TPrefix,\n): HiddenPrefixTypeNode<TType, TPrefix> {\n    return Object.freeze({\n        kind: 'hiddenPrefixTypeNode',\n\n        // Children.\n        type,\n        prefix,\n    });\n}\n","import type { ConstantValueNode, HiddenSuffixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function hiddenSuffixTypeNode<TType extends TypeNode, const TSuffix extends ConstantValueNode[]>(\n    type: TType,\n    suffix: TSuffix,\n): HiddenSuffixTypeNode<TType, TSuffix> {\n    return Object.freeze({\n        kind: 'hiddenSuffixTypeNode',\n\n        // Children.\n        type,\n        suffix,\n    });\n}\n","import type { CountNode, MapTypeNode, TypeNode } from '@codama/node-types';\n\nexport function mapTypeNode<TKey extends TypeNode, TValue extends TypeNode, TCount extends CountNode>(\n    key: TKey,\n    value: TValue,\n    count: TCount,\n): MapTypeNode<TKey, TValue, TCount> {\n    return Object.freeze({\n        kind: 'mapTypeNode',\n\n        // Children.\n        key,\n        value,\n        count,\n    });\n}\n","import { CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport type { NestedTypeNode, Node, TypeNode } from '@codama/node-types';\n\nimport { isNode } from '../Node';\nimport { TYPE_NODES } from './TypeNode';\n\nexport function resolveNestedTypeNode<TType extends TypeNode>(typeNode: NestedTypeNode<TType>): TType {\n    switch (typeNode.kind) {\n        case 'fixedSizeTypeNode':\n        case 'hiddenPrefixTypeNode':\n        case 'hiddenSuffixTypeNode':\n        case 'postOffsetTypeNode':\n        case 'preOffsetTypeNode':\n        case 'sentinelTypeNode':\n        case 'sizePrefixTypeNode':\n            return resolveNestedTypeNode<TType>(typeNode.type as NestedTypeNode<TType>);\n        default:\n            return typeNode;\n    }\n}\n\nexport function transformNestedTypeNode<TFrom extends TypeNode, TTo extends TypeNode>(\n    typeNode: NestedTypeNode<TFrom>,\n    map: (type: TFrom) => TTo,\n): NestedTypeNode<TTo> {\n    switch (typeNode.kind) {\n        case 'fixedSizeTypeNode':\n        case 'hiddenPrefixTypeNode':\n        case 'hiddenSuffixTypeNode':\n        case 'postOffsetTypeNode':\n        case 'preOffsetTypeNode':\n        case 'sentinelTypeNode':\n        case 'sizePrefixTypeNode':\n            return Object.freeze({\n                ...typeNode,\n                type: transformNestedTypeNode(typeNode.type as NestedTypeNode<TFrom>, map),\n            } as NestedTypeNode<TTo>);\n        default:\n            return map(typeNode);\n    }\n}\n\nexport function isNestedTypeNode<TKind extends TypeNode['kind']>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): node is NestedTypeNode<Extract<TypeNode, { kind: TKind }>> {\n    if (!isNode(node, TYPE_NODES)) return false;\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    const resolved = resolveNestedTypeNode(node);\n    return !!node && kinds.includes(resolved.kind as TKind);\n}\n\nexport function assertIsNestedTypeNode<TKind extends TypeNode['kind']>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): asserts node is NestedTypeNode<Extract<TypeNode, { kind: TKind }>> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    if (!isNestedTypeNode(node, kinds)) {\n        throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, {\n            expectedKinds: kinds,\n            kind: node?.kind ?? null,\n            node,\n        });\n    }\n}\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport type { GetNodeFromKind, Node, NodeKind } from '@codama/node-types';\n\nimport { REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS } from './contextualValueNodes/ContextualValueNode';\nimport { REGISTERED_COUNT_NODE_KINDS } from './countNodes/CountNode';\nimport { REGISTERED_DISCRIMINATOR_NODE_KINDS } from './discriminatorNodes/DiscriminatorNode';\nimport { REGISTERED_LINK_NODE_KINDS } from './linkNodes/LinkNode';\nimport { REGISTERED_PDA_SEED_NODE_KINDS } from './pdaSeedNodes/PdaSeedNode';\nimport { REGISTERED_TYPE_NODE_KINDS } from './typeNodes/TypeNode';\nimport { REGISTERED_VALUE_NODE_KINDS } from './valueNodes/ValueNode';\n\n// Node Registration.\nexport const REGISTERED_NODE_KINDS = [\n    ...REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS,\n    ...REGISTERED_DISCRIMINATOR_NODE_KINDS,\n    ...REGISTERED_LINK_NODE_KINDS,\n    ...REGISTERED_PDA_SEED_NODE_KINDS,\n    ...REGISTERED_COUNT_NODE_KINDS,\n    ...REGISTERED_TYPE_NODE_KINDS,\n    ...REGISTERED_VALUE_NODE_KINDS,\n    'rootNode' as const,\n    'programNode' as const,\n    'pdaNode' as const,\n    'accountNode' as const,\n    'instructionAccountNode' as const,\n    'instructionArgumentNode' as const,\n    'instructionByteDeltaNode' as const,\n    'instructionNode' as const,\n    'instructionRemainingAccountsNode' as const,\n    'errorNode' as const,\n    'definedTypeNode' as const,\n];\n\n// Node Helpers.\n\nexport function isNode<TKind extends NodeKind>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): node is GetNodeFromKind<TKind> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    return !!node && (kinds as NodeKind[]).includes(node.kind);\n}\n\nexport function assertIsNode<TKind extends NodeKind>(\n    node: Node | null | undefined,\n    kind: TKind | TKind[],\n): asserts node is GetNodeFromKind<TKind> {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    if (!isNode(node, kinds)) {\n        throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n            expectedKinds: kinds,\n            kind: node?.kind ?? null,\n            node,\n        });\n    }\n}\n\nexport function isNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => isNode(node, kind);\n}\n\nexport function assertIsNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => {\n        assertIsNode(node, kind);\n        return true;\n    };\n}\n\nexport function removeNullAndAssertIsNodeFilter<TKind extends NodeKind>(\n    kind: TKind | TKind[],\n): (node: Node | null | undefined) => node is GetNodeFromKind<TKind> {\n    return (node): node is GetNodeFromKind<TKind> => {\n        if (node) assertIsNode(node, kind);\n        return node != null;\n    };\n}\n","// Standalone Type Node Registration.\nexport const STANDALONE_TYPE_NODE_KINDS = [\n    'amountTypeNode' as const,\n    'arrayTypeNode' as const,\n    'booleanTypeNode' as const,\n    'bytesTypeNode' as const,\n    'dateTimeTypeNode' as const,\n    'enumTypeNode' as const,\n    'fixedSizeTypeNode' as const,\n    'hiddenPrefixTypeNode' as const,\n    'hiddenSuffixTypeNode' as const,\n    'mapTypeNode' as const,\n    'numberTypeNode' as const,\n    'optionTypeNode' as const,\n    'postOffsetTypeNode' as const,\n    'preOffsetTypeNode' as const,\n    'publicKeyTypeNode' as const,\n    'remainderOptionTypeNode' as const,\n    'sentinelTypeNode' as const,\n    'setTypeNode' as const,\n    'sizePrefixTypeNode' as const,\n    'solAmountTypeNode' as const,\n    'stringTypeNode' as const,\n    'structTypeNode' as const,\n    'tupleTypeNode' as const,\n    'zeroableOptionTypeNode' as const,\n];\n\n// Type Node Registration.\nexport const REGISTERED_TYPE_NODE_KINDS = [\n    ...STANDALONE_TYPE_NODE_KINDS,\n    'structFieldTypeNode' as const,\n    'enumEmptyVariantTypeNode' as const,\n    'enumStructVariantTypeNode' as const,\n    'enumTupleVariantTypeNode' as const,\n];\n\n/**\n * Type Node Helpers.\n * This only includes type nodes that can be used as standalone types.\n * E.g. this excludes structFieldTypeNode, enumEmptyVariantTypeNode, etc.\n * It also includes the definedTypeLinkNode to compose types.\n */\nexport const TYPE_NODES = [...STANDALONE_TYPE_NODE_KINDS, 'definedTypeLinkNode' as const];\n","import type { NestedTypeNode, NumberTypeNode, OptionTypeNode, TypeNode } from '@codama/node-types';\n\nimport { numberTypeNode } from './NumberTypeNode';\n\nexport function optionTypeNode<\n    TItem extends TypeNode,\n    TPrefix extends NestedTypeNode<NumberTypeNode> = NumberTypeNode<'u8'>,\n>(\n    item: TItem,\n    options: {\n        readonly fixed?: boolean;\n        readonly prefix?: TPrefix;\n    } = {},\n): OptionTypeNode<TItem, TPrefix> {\n    return Object.freeze({\n        kind: 'optionTypeNode',\n\n        // Data.\n        fixed: options.fixed ?? false,\n\n        // Children.\n        item,\n        prefix: (options.prefix ?? numberTypeNode('u8')) as TPrefix,\n    });\n}\n","import type { PostOffsetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function postOffsetTypeNode<TType extends TypeNode>(\n    type: TType,\n    offset: number,\n    strategy?: PostOffsetTypeNode['strategy'],\n): PostOffsetTypeNode<TType> {\n    return Object.freeze({\n        kind: 'postOffsetTypeNode',\n\n        // Data.\n        offset,\n        strategy: strategy ?? 'relative',\n\n        // Children.\n        type,\n    });\n}\n","import type { PreOffsetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function preOffsetTypeNode<TType extends TypeNode>(\n    type: TType,\n    offset: number,\n    strategy?: PreOffsetTypeNode['strategy'],\n): PreOffsetTypeNode<TType> {\n    return Object.freeze({\n        kind: 'preOffsetTypeNode',\n\n        // Data.\n        offset,\n        strategy: strategy ?? 'relative',\n\n        // Children.\n        type,\n    });\n}\n","import type { RemainderOptionTypeNode, TypeNode } from '@codama/node-types';\n\nexport function remainderOptionTypeNode<TItem extends TypeNode>(item: TItem): RemainderOptionTypeNode<TItem> {\n    return Object.freeze({\n        kind: 'remainderOptionTypeNode',\n\n        // Children.\n        item,\n    });\n}\n","import type { ConstantValueNode, SentinelTypeNode, TypeNode } from '@codama/node-types';\n\nexport function sentinelTypeNode<TType extends TypeNode, TSentinel extends ConstantValueNode>(\n    type: TType,\n    sentinel: TSentinel,\n): SentinelTypeNode<TType, TSentinel> {\n    return Object.freeze({\n        kind: 'sentinelTypeNode',\n\n        // Children.\n        type,\n        sentinel,\n    });\n}\n","import type { CountNode, SetTypeNode, TypeNode } from '@codama/node-types';\n\nexport function setTypeNode<TItem extends TypeNode, TCount extends CountNode>(\n    item: TItem,\n    count: TCount,\n): SetTypeNode<TItem, TCount> {\n    return Object.freeze({\n        kind: 'setTypeNode',\n\n        // Children.\n        item,\n        count,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, SizePrefixTypeNode, TypeNode } from '@codama/node-types';\n\nexport function sizePrefixTypeNode<\n    TType extends TypeNode = TypeNode,\n    TPrefix extends NestedTypeNode<NumberTypeNode> = NestedTypeNode<NumberTypeNode>,\n>(type: TType, prefix: TPrefix): SizePrefixTypeNode<TType, TPrefix> {\n    return Object.freeze({\n        kind: 'sizePrefixTypeNode',\n\n        // Children.\n        type,\n        prefix,\n    });\n}\n","import type { NestedTypeNode, NumberTypeNode, SolAmountTypeNode } from '@codama/node-types';\n\nexport function solAmountTypeNode<TNumber extends NestedTypeNode<NumberTypeNode>>(\n    number: TNumber,\n): SolAmountTypeNode<TNumber> {\n    return Object.freeze({\n        kind: 'solAmountTypeNode',\n\n        // Children.\n        number,\n    });\n}\n","import type { StructFieldTypeNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from '../shared';\n\nexport type StructFieldTypeNodeInput<\n    TType extends TypeNode = TypeNode,\n    TDefaultValue extends ValueNode | undefined = ValueNode | undefined,\n> = Omit<StructFieldTypeNode<TType, TDefaultValue>, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function structFieldTypeNode<TType extends TypeNode, TDefaultValue extends ValueNode | undefined = undefined>(\n    input: StructFieldTypeNodeInput<TType, TDefaultValue>,\n): StructFieldTypeNode<TType, TDefaultValue> {\n    return Object.freeze({\n        kind: 'structFieldTypeNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.defaultValueStrategy !== undefined && { defaultValueStrategy: input.defaultValueStrategy }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n","import type { StructFieldTypeNode, StructTypeNode } from '@codama/node-types';\n\nexport function structTypeNode<const TFields extends StructFieldTypeNode[] = StructFieldTypeNode[]>(\n    fields: TFields,\n): StructTypeNode<TFields> {\n    return Object.freeze({\n        kind: 'structTypeNode',\n\n        // Children.\n        fields,\n    });\n}\n","import type { TupleTypeNode, TypeNode } from '@codama/node-types';\n\nexport function tupleTypeNode<const TItems extends TypeNode[] = TypeNode[]>(items: TItems): TupleTypeNode<TItems> {\n    return Object.freeze({\n        kind: 'tupleTypeNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { ConstantValueNode, TypeNode, ZeroableOptionTypeNode } from '@codama/node-types';\n\nexport function zeroableOptionTypeNode<TItem extends TypeNode, TZeroValue extends ConstantValueNode | undefined>(\n    item: TItem,\n    zeroValue?: TZeroValue,\n): ZeroableOptionTypeNode<TItem, TZeroValue> {\n    return Object.freeze({\n        kind: 'zeroableOptionTypeNode',\n\n        // Children.\n        item,\n        ...(zeroValue !== undefined && { zeroValue }),\n    });\n}\n","import type { ArrayValueNode, ValueNode } from '@codama/node-types';\n\nexport function arrayValueNode<const TItems extends ValueNode[]>(items: TItems): ArrayValueNode<TItems> {\n    return Object.freeze({\n        kind: 'arrayValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import { BooleanValueNode } from '@codama/node-types';\n\nexport function booleanValueNode(boolean: boolean): BooleanValueNode {\n    return Object.freeze({\n        kind: 'booleanValueNode',\n\n        // Data.\n        boolean,\n    });\n}\n","import type { BytesEncoding, ConstantValueNode, TypeNode, ValueNode } from '@codama/node-types';\n\nimport { bytesTypeNode, stringTypeNode } from '../typeNodes';\nimport { bytesValueNode } from './BytesValueNode';\nimport { stringValueNode } from './StringValueNode';\n\nexport function constantValueNode<TType extends TypeNode, TValue extends ValueNode>(\n    type: TType,\n    value: TValue,\n): ConstantValueNode<TType, TValue> {\n    return Object.freeze({\n        kind: 'constantValueNode',\n\n        // Children.\n        type,\n        value,\n    });\n}\n\nexport function constantValueNodeFromString<TEncoding extends BytesEncoding>(encoding: TEncoding, string: string) {\n    return constantValueNode(stringTypeNode(encoding), stringValueNode(string));\n}\n\nexport function constantValueNodeFromBytes<TEncoding extends BytesEncoding>(encoding: TEncoding, data: string) {\n    return constantValueNode(bytesTypeNode(), bytesValueNode(encoding, data));\n}\n","import type { DefinedTypeLinkNode, EnumValueNode, StructValueNode, TupleValueNode } from '@codama/node-types';\n\nimport { definedTypeLinkNode } from '../linkNodes';\nimport { camelCase } from '../shared';\n\nexport function enumValueNode<\n    TEnum extends DefinedTypeLinkNode = DefinedTypeLinkNode,\n    TValue extends StructValueNode | TupleValueNode | undefined = undefined,\n>(enumLink: TEnum | string, variant: string, value?: TValue): EnumValueNode<TEnum, TValue> {\n    return Object.freeze({\n        kind: 'enumValueNode',\n\n        // Data.\n        variant: camelCase(variant),\n\n        // Children.\n        enum: (typeof enumLink === 'string' ? definedTypeLinkNode(enumLink) : enumLink) as TEnum,\n        ...(value !== undefined && { value }),\n    });\n}\n","import type { MapEntryValueNode, ValueNode } from '@codama/node-types';\n\nexport function mapEntryValueNode<TKey extends ValueNode, TValue extends ValueNode>(\n    key: TKey,\n    value: TValue,\n): MapEntryValueNode<TKey, TValue> {\n    return Object.freeze({\n        kind: 'mapEntryValueNode',\n\n        // Children.\n        key,\n        value,\n    });\n}\n","import type { MapEntryValueNode, MapValueNode } from '@codama/node-types';\n\nexport function mapValueNode<const TEntries extends MapEntryValueNode[]>(entries: TEntries): MapValueNode<TEntries> {\n    return Object.freeze({\n        kind: 'mapValueNode',\n\n        // Children.\n        entries,\n    });\n}\n","import type { NoneValueNode } from '@codama/node-types';\n\nexport function noneValueNode(): NoneValueNode {\n    return Object.freeze({ kind: 'noneValueNode' });\n}\n","import type { NumberValueNode } from '@codama/node-types';\n\nexport function numberValueNode(number: number): NumberValueNode {\n    return Object.freeze({\n        kind: 'numberValueNode',\n\n        // Data.\n        number,\n    });\n}\n","import type { PublicKeyValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function publicKeyValueNode(publicKey: string, identifier?: string): PublicKeyValueNode {\n    return Object.freeze({\n        kind: 'publicKeyValueNode',\n\n        // Data.\n        publicKey,\n        ...(identifier !== undefined && { identifier: camelCase(identifier) }),\n    });\n}\n","import type { SetValueNode, ValueNode } from '@codama/node-types';\n\nexport function setValueNode<const TItems extends ValueNode[]>(items: TItems): SetValueNode<TItems> {\n    return Object.freeze({\n        kind: 'setValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { SomeValueNode, ValueNode } from '@codama/node-types';\n\nexport function someValueNode<TValue extends ValueNode>(value: TValue): SomeValueNode<TValue> {\n    return Object.freeze({\n        kind: 'someValueNode',\n\n        // Children.\n        value,\n    });\n}\n","import type { StructFieldValueNode, ValueNode } from '@codama/node-types';\n\nimport { camelCase } from '../shared';\n\nexport function structFieldValueNode<TValue extends ValueNode>(\n    name: string,\n    value: TValue,\n): StructFieldValueNode<TValue> {\n    return Object.freeze({\n        kind: 'structFieldValueNode',\n\n        // Data.\n        name: camelCase(name),\n\n        // Children.\n        value,\n    });\n}\n","import type { StructFieldValueNode, StructValueNode } from '@codama/node-types';\n\nexport function structValueNode<const TFields extends StructFieldValueNode[]>(\n    fields: TFields,\n): StructValueNode<TFields> {\n    return Object.freeze({\n        kind: 'structValueNode',\n\n        // Children.\n        fields,\n    });\n}\n","import type { TupleValueNode, ValueNode } from '@codama/node-types';\n\nexport function tupleValueNode<const TItems extends ValueNode[]>(items: TItems): TupleValueNode<TItems> {\n    return Object.freeze({\n        kind: 'tupleValueNode',\n\n        // Children.\n        items,\n    });\n}\n","import type { AccountNode, DiscriminatorNode, NestedTypeNode, PdaLinkNode, StructTypeNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\nimport { structTypeNode } from './typeNodes';\n\nexport type AccountNodeInput<\n    TData extends NestedTypeNode<StructTypeNode> = NestedTypeNode<StructTypeNode>,\n    TPda extends PdaLinkNode | undefined = PdaLinkNode | undefined,\n    TDiscriminators extends DiscriminatorNode[] | undefined = DiscriminatorNode[] | undefined,\n> = Omit<AccountNode<TData, TPda, TDiscriminators>, 'data' | 'docs' | 'kind' | 'name'> & {\n    readonly data?: TData;\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function accountNode<\n    TData extends NestedTypeNode<StructTypeNode> = StructTypeNode<[]>,\n    TPda extends PdaLinkNode | undefined = undefined,\n    const TDiscriminators extends DiscriminatorNode[] | undefined = undefined,\n>(input: AccountNodeInput<TData, TPda, TDiscriminators>): AccountNode<TData, TPda, TDiscriminators> {\n    return Object.freeze({\n        kind: 'accountNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.size === undefined ? {} : { size: input.size }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        data: (input.data ?? structTypeNode([])) as TData,\n        ...(input.pda !== undefined && { pda: input.pda }),\n        ...(input.discriminators !== undefined && { discriminators: input.discriminators }),\n    });\n}\n","import type { DefinedTypeNode, TypeNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type DefinedTypeNodeInput<TType extends TypeNode = TypeNode> = Omit<\n    DefinedTypeNode<TType>,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function definedTypeNode<TType extends TypeNode>(input: DefinedTypeNodeInput<TType>): DefinedTypeNode<TType> {\n    return Object.freeze({\n        kind: 'definedTypeNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n    });\n}\n","import type { ErrorNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type ErrorNodeInput = Omit<ErrorNode, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function errorNode(input: ErrorNodeInput): ErrorNode {\n    return Object.freeze({\n        kind: 'errorNode',\n\n        // Data.\n        name: camelCase(input.name),\n        code: input.code,\n        message: input.message,\n        docs: parseDocs(input.docs),\n    });\n}\n","import type { InstructionAccountNode, InstructionInputValueNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type InstructionAccountNodeInput<\n    TDefaultValue extends InstructionInputValueNode | undefined = InstructionInputValueNode | undefined,\n> = Omit<InstructionAccountNode<TDefaultValue>, 'docs' | 'isOptional' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly isOptional?: boolean;\n    readonly name: string;\n};\n\nexport function instructionAccountNode<TDefaultValue extends InstructionInputValueNode | undefined = undefined>(\n    input: InstructionAccountNodeInput<TDefaultValue>,\n): InstructionAccountNode<TDefaultValue> {\n    return Object.freeze({\n        kind: 'instructionAccountNode',\n\n        // Data.\n        name: camelCase(input.name),\n        isWritable: input.isWritable,\n        isSigner: input.isSigner,\n        isOptional: input.isOptional ?? false,\n        docs: parseDocs(input.docs),\n\n        // Children.\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n","import type { InstructionArgumentNode, InstructionInputValueNode } from '@codama/node-types';\n\nimport { isNode } from './Node';\nimport { camelCase, DocsInput, parseDocs } from './shared';\nimport { structFieldTypeNode } from './typeNodes/StructFieldTypeNode';\nimport { structTypeNode } from './typeNodes/StructTypeNode';\nimport { VALUE_NODES } from './valueNodes';\n\nexport type InstructionArgumentNodeInput<\n    TDefaultValue extends InstructionInputValueNode | undefined = InstructionInputValueNode | undefined,\n> = Omit<InstructionArgumentNode<TDefaultValue>, 'docs' | 'kind' | 'name'> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function instructionArgumentNode<TDefaultValue extends InstructionInputValueNode | undefined = undefined>(\n    input: InstructionArgumentNodeInput<TDefaultValue>,\n): InstructionArgumentNode<TDefaultValue> {\n    return Object.freeze({\n        kind: 'instructionArgumentNode',\n\n        // Data.\n        name: camelCase(input.name),\n        ...(input.defaultValueStrategy !== undefined && { defaultValueStrategy: input.defaultValueStrategy }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        type: input.type,\n        ...(input.defaultValue !== undefined && { defaultValue: input.defaultValue }),\n    });\n}\n\nexport function structTypeNodeFromInstructionArgumentNodes(nodes: InstructionArgumentNode[]) {\n    return structTypeNode(nodes.map(structFieldTypeNodeFromInstructionArgumentNode));\n}\n\nexport function structFieldTypeNodeFromInstructionArgumentNode(node: InstructionArgumentNode) {\n    if (isNode(node.defaultValue, VALUE_NODES)) {\n        return structFieldTypeNode({ ...node, defaultValue: node.defaultValue });\n    }\n    return structFieldTypeNode({\n        ...node,\n        defaultValue: undefined,\n        defaultValueStrategy: undefined,\n    });\n}\n","import type { InstructionByteDeltaNode } from '@codama/node-types';\n\nimport { isNode } from './Node';\n\nexport function instructionByteDeltaNode<TValue extends InstructionByteDeltaNode['value']>(\n    value: TValue,\n    options: {\n        subtract?: boolean;\n        withHeader?: boolean;\n    } = {},\n): InstructionByteDeltaNode<TValue> {\n    return Object.freeze({\n        kind: 'instructionByteDeltaNode',\n\n        // Data.\n        withHeader: options.withHeader ?? !isNode(value, 'resolverValueNode'),\n        ...(options.subtract !== undefined && { subtract: options.subtract }),\n\n        // Children.\n        value,\n    });\n}\n","import type {\n    AccountNode,\n    DefinedTypeNode,\n    ErrorNode,\n    InstructionNode,\n    PdaNode,\n    ProgramNode,\n    RootNode,\n} from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type ProgramNodeInput<\n    TPdas extends PdaNode[] = PdaNode[],\n    TAccounts extends AccountNode[] = AccountNode[],\n    TInstructions extends InstructionNode[] = InstructionNode[],\n    TDefinedTypes extends DefinedTypeNode[] = DefinedTypeNode[],\n    TErrors extends ErrorNode[] = ErrorNode[],\n> = Omit<\n    Partial<ProgramNode<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors>>,\n    'docs' | 'kind' | 'name' | 'publicKey'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n    readonly publicKey: ProgramNode['publicKey'];\n};\n\nexport function programNode<\n    const TPdas extends PdaNode[] = [],\n    const TAccounts extends AccountNode[] = [],\n    const TInstructions extends InstructionNode[] = [],\n    const TDefinedTypes extends DefinedTypeNode[] = [],\n    const TErrors extends ErrorNode[] = [],\n>(\n    input: ProgramNodeInput<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors>,\n): ProgramNode<TPdas, TAccounts, TInstructions, TDefinedTypes, TErrors> {\n    return Object.freeze({\n        kind: 'programNode',\n\n        // Data.\n        name: camelCase(input.name),\n        publicKey: input.publicKey,\n        version: input.version ?? '0.0.0',\n        ...(input.origin !== undefined && { origin: input.origin }),\n        docs: parseDocs(input.docs),\n\n        // Children.\n        accounts: (input.accounts ?? []) as TAccounts,\n        instructions: (input.instructions ?? []) as TInstructions,\n        definedTypes: (input.definedTypes ?? []) as TDefinedTypes,\n        pdas: (input.pdas ?? []) as TPdas,\n        errors: (input.errors ?? []) as TErrors,\n    });\n}\n\nexport function getAllPrograms(node: ProgramNode | ProgramNode[] | RootNode): ProgramNode[] {\n    if (Array.isArray(node)) return node;\n    if (node.kind === 'programNode') return [node];\n    return [node.program, ...node.additionalPrograms];\n}\n\nexport function getAllPdas(node: ProgramNode | ProgramNode[] | RootNode): PdaNode[] {\n    return getAllPrograms(node).flatMap(program => program.pdas);\n}\n\nexport function getAllAccounts(node: ProgramNode | ProgramNode[] | RootNode): AccountNode[] {\n    return getAllPrograms(node).flatMap(program => program.accounts);\n}\n\nexport function getAllDefinedTypes(node: ProgramNode | ProgramNode[] | RootNode): DefinedTypeNode[] {\n    return getAllPrograms(node).flatMap(program => program.definedTypes);\n}\n\nexport function getAllInstructions(node: ProgramNode | ProgramNode[] | RootNode): InstructionNode[] {\n    return getAllPrograms(node).flatMap(program => program.instructions);\n}\n\nexport function getAllErrors(node: ProgramNode | ProgramNode[] | RootNode): ErrorNode[] {\n    return getAllPrograms(node).flatMap(program => program.errors);\n}\n","import type {\n    DiscriminatorNode,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionByteDeltaNode,\n    InstructionNode,\n    InstructionRemainingAccountsNode,\n    OptionalAccountStrategy,\n    ProgramNode,\n    RootNode,\n} from '@codama/node-types';\n\nimport { isNode } from './Node';\nimport { getAllInstructions } from './ProgramNode';\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\ntype SubInstructionNode = InstructionNode;\n\nexport type InstructionNodeInput<\n    TAccounts extends InstructionAccountNode[] = InstructionAccountNode[],\n    TArguments extends InstructionArgumentNode[] = InstructionArgumentNode[],\n    TExtraArguments extends InstructionArgumentNode[] | undefined = InstructionArgumentNode[] | undefined,\n    TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined =\n        | InstructionRemainingAccountsNode[]\n        | undefined,\n    TByteDeltas extends InstructionByteDeltaNode[] | undefined = InstructionByteDeltaNode[] | undefined,\n    TDiscriminators extends DiscriminatorNode[] | undefined = DiscriminatorNode[] | undefined,\n    TSubInstructions extends SubInstructionNode[] | undefined = SubInstructionNode[] | undefined,\n> = Omit<\n    Partial<\n        InstructionNode<\n            TAccounts,\n            TArguments,\n            TExtraArguments,\n            TRemainingAccounts,\n            TByteDeltas,\n            TDiscriminators,\n            TSubInstructions\n        >\n    >,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function instructionNode<\n    const TAccounts extends InstructionAccountNode[] = [],\n    const TArguments extends InstructionArgumentNode[] = [],\n    const TExtraArguments extends InstructionArgumentNode[] | undefined = undefined,\n    const TRemainingAccounts extends InstructionRemainingAccountsNode[] | undefined = undefined,\n    const TByteDeltas extends InstructionByteDeltaNode[] | undefined = undefined,\n    const TDiscriminators extends DiscriminatorNode[] | undefined = undefined,\n    const TSubInstructions extends SubInstructionNode[] | undefined = undefined,\n>(\n    input: InstructionNodeInput<\n        TAccounts,\n        TArguments,\n        TExtraArguments,\n        TRemainingAccounts,\n        TByteDeltas,\n        TDiscriminators,\n        TSubInstructions\n    >,\n): InstructionNode<\n    TAccounts,\n    TArguments,\n    TExtraArguments,\n    TRemainingAccounts,\n    TByteDeltas,\n    TDiscriminators,\n    TSubInstructions\n> {\n    return Object.freeze({\n        kind: 'instructionNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n        optionalAccountStrategy: parseOptionalAccountStrategy(input.optionalAccountStrategy),\n\n        // Children.\n        accounts: (input.accounts ?? []) as TAccounts,\n        arguments: (input.arguments ?? []) as TArguments,\n        extraArguments: input.extraArguments,\n        remainingAccounts: input.remainingAccounts,\n        byteDeltas: input.byteDeltas,\n        discriminators: input.discriminators,\n        subInstructions: input.subInstructions,\n    });\n}\n\nexport function parseOptionalAccountStrategy(\n    optionalAccountStrategy: OptionalAccountStrategy | undefined,\n): OptionalAccountStrategy {\n    return optionalAccountStrategy ?? 'programId';\n}\n\nexport function getAllInstructionArguments(node: InstructionNode): InstructionArgumentNode[] {\n    return [...node.arguments, ...(node.extraArguments ?? [])];\n}\n\nexport function getAllInstructionsWithSubs(\n    node: InstructionNode | ProgramNode | RootNode,\n    config: { leavesOnly?: boolean; subInstructionsFirst?: boolean } = {},\n): InstructionNode[] {\n    const { leavesOnly = false, subInstructionsFirst = false } = config;\n    if (isNode(node, 'instructionNode')) {\n        if (!node.subInstructions || node.subInstructions.length === 0) return [node];\n        const subInstructions = node.subInstructions.flatMap(sub => getAllInstructionsWithSubs(sub, config));\n        if (leavesOnly) return subInstructions;\n        return subInstructionsFirst ? [...subInstructions, node] : [node, ...subInstructions];\n    }\n\n    const instructions = isNode(node, 'programNode') ? node.instructions : getAllInstructions(node);\n\n    return instructions.flatMap(instruction => getAllInstructionsWithSubs(instruction, config));\n}\n","import type { ArgumentValueNode, InstructionRemainingAccountsNode, ResolverValueNode } from '@codama/node-types';\n\nimport { DocsInput, parseDocs } from './shared';\n\nexport function instructionRemainingAccountsNode<TValue extends ArgumentValueNode | ResolverValueNode>(\n    value: TValue,\n    options: {\n        docs?: DocsInput;\n        isOptional?: boolean;\n        isSigner?: boolean | 'either';\n        isWritable?: boolean;\n    } = {},\n): InstructionRemainingAccountsNode<TValue> {\n    return Object.freeze({\n        kind: 'instructionRemainingAccountsNode',\n\n        // Data.\n        ...(options.isOptional !== undefined && { isOptional: options.isOptional }),\n        ...(options.isSigner !== undefined && { isSigner: options.isSigner }),\n        ...(options.isWritable !== undefined && { isWritable: options.isWritable }),\n        docs: parseDocs(options.docs),\n\n        // Children.\n        value,\n    });\n}\n","import type { PdaNode, PdaSeedNode } from '@codama/node-types';\n\nimport { camelCase, DocsInput, parseDocs } from './shared';\n\nexport type PdaNodeInput<TSeeds extends PdaSeedNode[] = PdaSeedNode[]> = Omit<\n    PdaNode<TSeeds>,\n    'docs' | 'kind' | 'name'\n> & {\n    readonly docs?: DocsInput;\n    readonly name: string;\n};\n\nexport function pdaNode<const TSeeds extends PdaSeedNode[]>(input: PdaNodeInput<TSeeds>): PdaNode<TSeeds> {\n    return Object.freeze({\n        kind: 'pdaNode',\n\n        // Data.\n        name: camelCase(input.name),\n        docs: parseDocs(input.docs),\n        ...(input.programId && { programId: input.programId }),\n\n        // Children.\n        seeds: input.seeds,\n    });\n}\n","import type { CodamaVersion, ProgramNode, RootNode } from '@codama/node-types';\n\nexport function rootNode<TProgram extends ProgramNode, const TAdditionalPrograms extends ProgramNode[] = []>(\n    program: TProgram,\n    additionalPrograms?: TAdditionalPrograms,\n): RootNode<TProgram, TAdditionalPrograms> {\n    return Object.freeze({\n        kind: 'rootNode',\n\n        // Data.\n        standard: 'codama',\n        version: __VERSION__ as CodamaVersion,\n\n        // Children.\n        program,\n        additionalPrograms: (additionalPrograms ?? []) as TAdditionalPrograms,\n    });\n}\n"],"mappings":"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","names":["CodamaError","CodamaError"]}