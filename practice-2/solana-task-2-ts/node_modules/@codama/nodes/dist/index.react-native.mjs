// src/index.ts
export * from "@codama/node-types";

// src/shared/docs.ts
function parseDocs(docs) {
  if (docs === null || docs === void 0) return [];
  return Array.isArray(docs) ? docs : [docs];
}

// src/shared/stringCases.ts
function capitalize(str) {
  if (str.length === 0) return str;
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
function titleCase(str) {
  return str.replace(/([A-Z])/g, " $1").split(/[^a-zA-Z0-9]+/).filter((word) => word.length > 0).map(capitalize).join(" ");
}
function pascalCase(str) {
  return titleCase(str).split(" ").join("");
}
function camelCase(str) {
  if (str.length === 0) return str;
  const pascalStr = pascalCase(str);
  return pascalStr.charAt(0).toLowerCase() + pascalStr.slice(1);
}
function kebabCase(str) {
  return titleCase(str).split(" ").join("-").toLowerCase();
}
function snakeCase(str) {
  return titleCase(str).split(" ").join("_").toLowerCase();
}

// src/contextualValueNodes/AccountBumpValueNode.ts
function accountBumpValueNode(name) {
  return Object.freeze({
    kind: "accountBumpValueNode",
    // Data.
    name: camelCase(name)
  });
}

// src/contextualValueNodes/AccountValueNode.ts
function accountValueNode(name) {
  return Object.freeze({
    kind: "accountValueNode",
    // Data.
    name: camelCase(name)
  });
}

// src/contextualValueNodes/ArgumentValueNode.ts
function argumentValueNode(name) {
  return Object.freeze({
    kind: "argumentValueNode",
    // Data.
    name: camelCase(name)
  });
}

// src/contextualValueNodes/ConditionalValueNode.ts
function conditionalValueNode(input) {
  return Object.freeze({
    kind: "conditionalValueNode",
    // Children.
    condition: input.condition,
    ...input.value !== void 0 && { value: input.value },
    ...input.ifTrue !== void 0 && { ifTrue: input.ifTrue },
    ...input.ifFalse !== void 0 && { ifFalse: input.ifFalse }
  });
}

// src/valueNodes/ValueNode.ts
var STANDALONE_VALUE_NODE_KINDS = [
  "arrayValueNode",
  "bytesValueNode",
  "booleanValueNode",
  "constantValueNode",
  "enumValueNode",
  "mapValueNode",
  "noneValueNode",
  "numberValueNode",
  "setValueNode",
  "someValueNode",
  "structValueNode",
  "tupleValueNode",
  "publicKeyValueNode",
  "stringValueNode"
];
var REGISTERED_VALUE_NODE_KINDS = [
  ...STANDALONE_VALUE_NODE_KINDS,
  "mapEntryValueNode",
  "structFieldValueNode"
];
var VALUE_NODES = STANDALONE_VALUE_NODE_KINDS;

// src/contextualValueNodes/ContextualValueNode.ts
var STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS = [
  "accountBumpValueNode",
  "accountValueNode",
  "argumentValueNode",
  "conditionalValueNode",
  "identityValueNode",
  "payerValueNode",
  "pdaValueNode",
  "programIdValueNode",
  "resolverValueNode"
];
var REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS = [
  ...STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS,
  "pdaSeedValueNode"
];
var CONTEXTUAL_VALUE_NODES = STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS;
var INSTRUCTION_INPUT_VALUE_NODES = [...VALUE_NODES, ...CONTEXTUAL_VALUE_NODES, "programLinkNode"];

// src/contextualValueNodes/IdentityValueNode.ts
function identityValueNode() {
  return Object.freeze({ kind: "identityValueNode" });
}

// src/contextualValueNodes/PayerValueNode.ts
function payerValueNode() {
  return Object.freeze({ kind: "payerValueNode" });
}

// src/contextualValueNodes/PdaSeedValueNode.ts
function pdaSeedValueNode(name, value) {
  return Object.freeze({
    kind: "pdaSeedValueNode",
    // Data.
    name: camelCase(name),
    // Children.
    value
  });
}

// src/linkNodes/ProgramLinkNode.ts
function programLinkNode(name) {
  return Object.freeze({
    kind: "programLinkNode",
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/AccountLinkNode.ts
function accountLinkNode(name, program) {
  return Object.freeze({
    kind: "accountLinkNode",
    // Children.
    ...program === void 0 ? {} : { program: typeof program === "string" ? programLinkNode(program) : program },
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/DefinedTypeLinkNode.ts
function definedTypeLinkNode(name, program) {
  return Object.freeze({
    kind: "definedTypeLinkNode",
    // Children.
    ...program === void 0 ? {} : { program: typeof program === "string" ? programLinkNode(program) : program },
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/InstructionLinkNode.ts
function instructionLinkNode(name, program) {
  return Object.freeze({
    kind: "instructionLinkNode",
    // Children.
    ...program === void 0 ? {} : { program: typeof program === "string" ? programLinkNode(program) : program },
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/InstructionAccountLinkNode.ts
function instructionAccountLinkNode(name, instruction) {
  return Object.freeze({
    kind: "instructionAccountLinkNode",
    // Children.
    ...instruction === void 0 ? {} : { instruction: typeof instruction === "string" ? instructionLinkNode(instruction) : instruction },
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/InstructionArgumentLinkNode.ts
function instructionArgumentLinkNode(name, instruction) {
  return Object.freeze({
    kind: "instructionArgumentLinkNode",
    // Children.
    ...instruction === void 0 ? {} : { instruction: typeof instruction === "string" ? instructionLinkNode(instruction) : instruction },
    // Data.
    name: camelCase(name)
  });
}

// src/linkNodes/LinkNode.ts
var REGISTERED_LINK_NODE_KINDS = [
  "accountLinkNode",
  "definedTypeLinkNode",
  "instructionAccountLinkNode",
  "instructionArgumentLinkNode",
  "instructionLinkNode",
  "pdaLinkNode",
  "programLinkNode"
];
var LINK_NODES = REGISTERED_LINK_NODE_KINDS;

// src/linkNodes/PdaLinkNode.ts
function pdaLinkNode(name, program) {
  return Object.freeze({
    kind: "pdaLinkNode",
    // Children.
    ...program === void 0 ? {} : { program: typeof program === "string" ? programLinkNode(program) : program },
    // Data.
    name: camelCase(name)
  });
}

// src/contextualValueNodes/PdaValueNode.ts
function pdaValueNode(pda, seeds = []) {
  return Object.freeze({
    kind: "pdaValueNode",
    // Children.
    pda: typeof pda === "string" ? pdaLinkNode(pda) : pda,
    seeds
  });
}

// src/contextualValueNodes/ProgramIdValueNode.ts
function programIdValueNode() {
  return Object.freeze({ kind: "programIdValueNode" });
}

// src/contextualValueNodes/ResolverValueNode.ts
function resolverValueNode(name, options = {}) {
  return Object.freeze({
    kind: "resolverValueNode",
    // Data.
    name: camelCase(name),
    docs: parseDocs(options.docs),
    // Children.
    dependsOn: options.dependsOn
  });
}

// src/countNodes/CountNode.ts
var REGISTERED_COUNT_NODE_KINDS = [
  "fixedCountNode",
  "remainderCountNode",
  "prefixedCountNode"
];
var COUNT_NODES = REGISTERED_COUNT_NODE_KINDS;

// src/countNodes/FixedCountNode.ts
function fixedCountNode(value) {
  return Object.freeze({
    kind: "fixedCountNode",
    // Data.
    value
  });
}

// src/countNodes/PrefixedCountNode.ts
function prefixedCountNode(prefix) {
  return Object.freeze({
    kind: "prefixedCountNode",
    // Children.
    prefix
  });
}

// src/countNodes/RemainderCountNode.ts
function remainderCountNode() {
  return Object.freeze({ kind: "remainderCountNode" });
}

// src/discriminatorNodes/ConstantDiscriminatorNode.ts
function constantDiscriminatorNode(constant, offset = 0) {
  return Object.freeze({
    kind: "constantDiscriminatorNode",
    // Data.
    offset,
    // Children.
    constant
  });
}

// src/discriminatorNodes/DiscriminatorNode.ts
var REGISTERED_DISCRIMINATOR_NODE_KINDS = [
  "constantDiscriminatorNode",
  "fieldDiscriminatorNode",
  "sizeDiscriminatorNode"
];
var DISCRIMINATOR_NODES = REGISTERED_DISCRIMINATOR_NODE_KINDS;

// src/discriminatorNodes/FieldDiscriminatorNode.ts
function fieldDiscriminatorNode(name, offset = 0) {
  return Object.freeze({
    kind: "fieldDiscriminatorNode",
    // Data.
    name: camelCase(name),
    offset
  });
}

// src/discriminatorNodes/SizeDiscriminatorNode.ts
function sizeDiscriminatorNode(size) {
  return Object.freeze({
    kind: "sizeDiscriminatorNode",
    // Data.
    size
  });
}

// src/typeNodes/BytesTypeNode.ts
function bytesTypeNode() {
  return Object.freeze({ kind: "bytesTypeNode" });
}

// src/typeNodes/PublicKeyTypeNode.ts
function publicKeyTypeNode() {
  return Object.freeze({ kind: "publicKeyTypeNode" });
}

// src/typeNodes/StringTypeNode.ts
function stringTypeNode(encoding) {
  return Object.freeze({
    kind: "stringTypeNode",
    // Data.
    encoding
  });
}

// src/valueNodes/BytesValueNode.ts
function bytesValueNode(encoding, data) {
  return Object.freeze({
    kind: "bytesValueNode",
    // Data.
    data,
    encoding
  });
}

// src/valueNodes/StringValueNode.ts
function stringValueNode(string) {
  return Object.freeze({
    kind: "stringValueNode",
    // Data.
    string
  });
}

// src/pdaSeedNodes/ConstantPdaSeedNode.ts
function constantPdaSeedNode(type, value) {
  return Object.freeze({
    kind: "constantPdaSeedNode",
    // Children.
    type,
    value
  });
}
function constantPdaSeedNodeFromProgramId() {
  return constantPdaSeedNode(publicKeyTypeNode(), programIdValueNode());
}
function constantPdaSeedNodeFromString(encoding, string) {
  return constantPdaSeedNode(stringTypeNode(encoding), stringValueNode(string));
}
function constantPdaSeedNodeFromBytes(encoding, data) {
  return constantPdaSeedNode(bytesTypeNode(), bytesValueNode(encoding, data));
}

// src/pdaSeedNodes/PdaSeedNode.ts
var REGISTERED_PDA_SEED_NODE_KINDS = ["constantPdaSeedNode", "variablePdaSeedNode"];
var PDA_SEED_NODES = REGISTERED_PDA_SEED_NODE_KINDS;

// src/pdaSeedNodes/VariablePdaSeedNode.ts
function variablePdaSeedNode(name, type, docs) {
  return Object.freeze({
    kind: "variablePdaSeedNode",
    // Data.
    name: camelCase(name),
    docs: parseDocs(docs),
    // Children.
    type
  });
}

// src/typeNodes/AmountTypeNode.ts
function amountTypeNode(number, decimals, unit) {
  return Object.freeze({
    kind: "amountTypeNode",
    // Data.
    decimals,
    ...unit !== void 0 && { unit },
    // Children.
    number
  });
}

// src/typeNodes/ArrayTypeNode.ts
function arrayTypeNode(item, count) {
  return Object.freeze({
    kind: "arrayTypeNode",
    // Children.
    item,
    count
  });
}

// src/typeNodes/NumberTypeNode.ts
function numberTypeNode(format, endian = "le") {
  return Object.freeze({
    kind: "numberTypeNode",
    // Data.
    format,
    endian
  });
}
function isSignedInteger(node) {
  return node.format.startsWith("i");
}
function isUnsignedInteger(node) {
  return node.format.startsWith("u") || node.format === "shortU16";
}
function isInteger(node) {
  return !node.format.startsWith("f");
}
function isDecimal(node) {
  return node.format.startsWith("f");
}

// src/typeNodes/BooleanTypeNode.ts
function booleanTypeNode(size) {
  return Object.freeze({
    kind: "booleanTypeNode",
    // Children.
    size: size ?? numberTypeNode("u8")
  });
}

// src/typeNodes/DateTimeTypeNode.ts
function dateTimeTypeNode(number) {
  return Object.freeze({
    kind: "dateTimeTypeNode",
    // Children.
    number
  });
}

// src/typeNodes/EnumEmptyVariantTypeNode.ts
function enumEmptyVariantTypeNode(name, discriminator) {
  return Object.freeze({
    kind: "enumEmptyVariantTypeNode",
    // Data.
    name: camelCase(name),
    discriminator
  });
}

// src/typeNodes/EnumStructVariantTypeNode.ts
function enumStructVariantTypeNode(name, struct, discriminator) {
  return Object.freeze({
    kind: "enumStructVariantTypeNode",
    // Data.
    name: camelCase(name),
    ...discriminator !== void 0 && { discriminator },
    // Children.
    struct
  });
}

// src/typeNodes/EnumTupleVariantTypeNode.ts
function enumTupleVariantTypeNode(name, tuple, discriminator) {
  return Object.freeze({
    kind: "enumTupleVariantTypeNode",
    // Data.
    name: camelCase(name),
    ...discriminator !== void 0 && { discriminator },
    // Children.
    tuple
  });
}

// src/typeNodes/EnumTypeNode.ts
function enumTypeNode(variants, options = {}) {
  return Object.freeze({
    kind: "enumTypeNode",
    // Children.
    variants,
    size: options.size ?? numberTypeNode("u8")
  });
}
function isScalarEnum(node) {
  return node.variants.every((variant) => variant.kind === "enumEmptyVariantTypeNode");
}
function isDataEnum(node) {
  return !isScalarEnum(node);
}

// src/typeNodes/EnumVariantTypeNode.ts
var ENUM_VARIANT_TYPE_NODES = [
  "enumEmptyVariantTypeNode",
  "enumStructVariantTypeNode",
  "enumTupleVariantTypeNode"
];

// src/typeNodes/FixedSizeTypeNode.ts
function fixedSizeTypeNode(type, size) {
  return Object.freeze({
    kind: "fixedSizeTypeNode",
    // Data.
    size,
    // Children.
    type
  });
}

// src/typeNodes/HiddenPrefixTypeNode.ts
function hiddenPrefixTypeNode(type, prefix) {
  return Object.freeze({
    kind: "hiddenPrefixTypeNode",
    // Children.
    type,
    prefix
  });
}

// src/typeNodes/HiddenSuffixTypeNode.ts
function hiddenSuffixTypeNode(type, suffix) {
  return Object.freeze({
    kind: "hiddenSuffixTypeNode",
    // Children.
    type,
    suffix
  });
}

// src/typeNodes/MapTypeNode.ts
function mapTypeNode(key, value, count) {
  return Object.freeze({
    kind: "mapTypeNode",
    // Children.
    key,
    value,
    count
  });
}

// src/typeNodes/NestedTypeNode.ts
import { CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, CodamaError as CodamaError2 } from "@codama/errors";

// src/Node.ts
import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from "@codama/errors";

// src/typeNodes/TypeNode.ts
var STANDALONE_TYPE_NODE_KINDS = [
  "amountTypeNode",
  "arrayTypeNode",
  "booleanTypeNode",
  "bytesTypeNode",
  "dateTimeTypeNode",
  "enumTypeNode",
  "fixedSizeTypeNode",
  "hiddenPrefixTypeNode",
  "hiddenSuffixTypeNode",
  "mapTypeNode",
  "numberTypeNode",
  "optionTypeNode",
  "postOffsetTypeNode",
  "preOffsetTypeNode",
  "publicKeyTypeNode",
  "remainderOptionTypeNode",
  "sentinelTypeNode",
  "setTypeNode",
  "sizePrefixTypeNode",
  "solAmountTypeNode",
  "stringTypeNode",
  "structTypeNode",
  "tupleTypeNode",
  "zeroableOptionTypeNode"
];
var REGISTERED_TYPE_NODE_KINDS = [
  ...STANDALONE_TYPE_NODE_KINDS,
  "structFieldTypeNode",
  "enumEmptyVariantTypeNode",
  "enumStructVariantTypeNode",
  "enumTupleVariantTypeNode"
];
var TYPE_NODES = [...STANDALONE_TYPE_NODE_KINDS, "definedTypeLinkNode"];

// src/Node.ts
var REGISTERED_NODE_KINDS = [
  ...REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS,
  ...REGISTERED_DISCRIMINATOR_NODE_KINDS,
  ...REGISTERED_LINK_NODE_KINDS,
  ...REGISTERED_PDA_SEED_NODE_KINDS,
  ...REGISTERED_COUNT_NODE_KINDS,
  ...REGISTERED_TYPE_NODE_KINDS,
  ...REGISTERED_VALUE_NODE_KINDS,
  "rootNode",
  "programNode",
  "pdaNode",
  "accountNode",
  "instructionAccountNode",
  "instructionArgumentNode",
  "instructionByteDeltaNode",
  "instructionNode",
  "instructionRemainingAccountsNode",
  "errorNode",
  "definedTypeNode"
];
function isNode(node, kind) {
  const kinds = Array.isArray(kind) ? kind : [kind];
  return !!node && kinds.includes(node.kind);
}
function assertIsNode(node, kind) {
  const kinds = Array.isArray(kind) ? kind : [kind];
  if (!isNode(node, kinds)) {
    throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {
      expectedKinds: kinds,
      kind: node?.kind ?? null,
      node
    });
  }
}
function isNodeFilter(kind) {
  return (node) => isNode(node, kind);
}
function assertIsNodeFilter(kind) {
  return (node) => {
    assertIsNode(node, kind);
    return true;
  };
}
function removeNullAndAssertIsNodeFilter(kind) {
  return (node) => {
    if (node) assertIsNode(node, kind);
    return node != null;
  };
}

// src/typeNodes/NestedTypeNode.ts
function resolveNestedTypeNode(typeNode) {
  switch (typeNode.kind) {
    case "fixedSizeTypeNode":
    case "hiddenPrefixTypeNode":
    case "hiddenSuffixTypeNode":
    case "postOffsetTypeNode":
    case "preOffsetTypeNode":
    case "sentinelTypeNode":
    case "sizePrefixTypeNode":
      return resolveNestedTypeNode(typeNode.type);
    default:
      return typeNode;
  }
}
function transformNestedTypeNode(typeNode, map) {
  switch (typeNode.kind) {
    case "fixedSizeTypeNode":
    case "hiddenPrefixTypeNode":
    case "hiddenSuffixTypeNode":
    case "postOffsetTypeNode":
    case "preOffsetTypeNode":
    case "sentinelTypeNode":
    case "sizePrefixTypeNode":
      return Object.freeze({
        ...typeNode,
        type: transformNestedTypeNode(typeNode.type, map)
      });
    default:
      return map(typeNode);
  }
}
function isNestedTypeNode(node, kind) {
  if (!isNode(node, TYPE_NODES)) return false;
  const kinds = Array.isArray(kind) ? kind : [kind];
  const resolved = resolveNestedTypeNode(node);
  return !!node && kinds.includes(resolved.kind);
}
function assertIsNestedTypeNode(node, kind) {
  const kinds = Array.isArray(kind) ? kind : [kind];
  if (!isNestedTypeNode(node, kinds)) {
    throw new CodamaError2(CODAMA_ERROR__UNEXPECTED_NESTED_NODE_KIND, {
      expectedKinds: kinds,
      kind: node?.kind ?? null,
      node
    });
  }
}

// src/typeNodes/OptionTypeNode.ts
function optionTypeNode(item, options = {}) {
  return Object.freeze({
    kind: "optionTypeNode",
    // Data.
    fixed: options.fixed ?? false,
    // Children.
    item,
    prefix: options.prefix ?? numberTypeNode("u8")
  });
}

// src/typeNodes/PostOffsetTypeNode.ts
function postOffsetTypeNode(type, offset, strategy) {
  return Object.freeze({
    kind: "postOffsetTypeNode",
    // Data.
    offset,
    strategy: strategy ?? "relative",
    // Children.
    type
  });
}

// src/typeNodes/PreOffsetTypeNode.ts
function preOffsetTypeNode(type, offset, strategy) {
  return Object.freeze({
    kind: "preOffsetTypeNode",
    // Data.
    offset,
    strategy: strategy ?? "relative",
    // Children.
    type
  });
}

// src/typeNodes/RemainderOptionTypeNode.ts
function remainderOptionTypeNode(item) {
  return Object.freeze({
    kind: "remainderOptionTypeNode",
    // Children.
    item
  });
}

// src/typeNodes/SentinelTypeNode.ts
function sentinelTypeNode(type, sentinel) {
  return Object.freeze({
    kind: "sentinelTypeNode",
    // Children.
    type,
    sentinel
  });
}

// src/typeNodes/SetTypeNode.ts
function setTypeNode(item, count) {
  return Object.freeze({
    kind: "setTypeNode",
    // Children.
    item,
    count
  });
}

// src/typeNodes/SizePrefixTypeNode.ts
function sizePrefixTypeNode(type, prefix) {
  return Object.freeze({
    kind: "sizePrefixTypeNode",
    // Children.
    type,
    prefix
  });
}

// src/typeNodes/SolAmountTypeNode.ts
function solAmountTypeNode(number) {
  return Object.freeze({
    kind: "solAmountTypeNode",
    // Children.
    number
  });
}

// src/typeNodes/StructFieldTypeNode.ts
function structFieldTypeNode(input) {
  return Object.freeze({
    kind: "structFieldTypeNode",
    // Data.
    name: camelCase(input.name),
    ...input.defaultValueStrategy !== void 0 && { defaultValueStrategy: input.defaultValueStrategy },
    docs: parseDocs(input.docs),
    // Children.
    type: input.type,
    ...input.defaultValue !== void 0 && { defaultValue: input.defaultValue }
  });
}

// src/typeNodes/StructTypeNode.ts
function structTypeNode(fields) {
  return Object.freeze({
    kind: "structTypeNode",
    // Children.
    fields
  });
}

// src/typeNodes/TupleTypeNode.ts
function tupleTypeNode(items) {
  return Object.freeze({
    kind: "tupleTypeNode",
    // Children.
    items
  });
}

// src/typeNodes/ZeroableOptionTypeNode.ts
function zeroableOptionTypeNode(item, zeroValue) {
  return Object.freeze({
    kind: "zeroableOptionTypeNode",
    // Children.
    item,
    ...zeroValue !== void 0 && { zeroValue }
  });
}

// src/valueNodes/ArrayValueNode.ts
function arrayValueNode(items) {
  return Object.freeze({
    kind: "arrayValueNode",
    // Children.
    items
  });
}

// src/valueNodes/BooleanValueNode.ts
function booleanValueNode(boolean) {
  return Object.freeze({
    kind: "booleanValueNode",
    // Data.
    boolean
  });
}

// src/valueNodes/ConstantValueNode.ts
function constantValueNode(type, value) {
  return Object.freeze({
    kind: "constantValueNode",
    // Children.
    type,
    value
  });
}
function constantValueNodeFromString(encoding, string) {
  return constantValueNode(stringTypeNode(encoding), stringValueNode(string));
}
function constantValueNodeFromBytes(encoding, data) {
  return constantValueNode(bytesTypeNode(), bytesValueNode(encoding, data));
}

// src/valueNodes/EnumValueNode.ts
function enumValueNode(enumLink, variant, value) {
  return Object.freeze({
    kind: "enumValueNode",
    // Data.
    variant: camelCase(variant),
    // Children.
    enum: typeof enumLink === "string" ? definedTypeLinkNode(enumLink) : enumLink,
    ...value !== void 0 && { value }
  });
}

// src/valueNodes/MapEntryValueNode.ts
function mapEntryValueNode(key, value) {
  return Object.freeze({
    kind: "mapEntryValueNode",
    // Children.
    key,
    value
  });
}

// src/valueNodes/MapValueNode.ts
function mapValueNode(entries) {
  return Object.freeze({
    kind: "mapValueNode",
    // Children.
    entries
  });
}

// src/valueNodes/NoneValueNode.ts
function noneValueNode() {
  return Object.freeze({ kind: "noneValueNode" });
}

// src/valueNodes/NumberValueNode.ts
function numberValueNode(number) {
  return Object.freeze({
    kind: "numberValueNode",
    // Data.
    number
  });
}

// src/valueNodes/PublicKeyValueNode.ts
function publicKeyValueNode(publicKey, identifier) {
  return Object.freeze({
    kind: "publicKeyValueNode",
    // Data.
    publicKey,
    ...identifier !== void 0 && { identifier: camelCase(identifier) }
  });
}

// src/valueNodes/SetValueNode.ts
function setValueNode(items) {
  return Object.freeze({
    kind: "setValueNode",
    // Children.
    items
  });
}

// src/valueNodes/SomeValueNode.ts
function someValueNode(value) {
  return Object.freeze({
    kind: "someValueNode",
    // Children.
    value
  });
}

// src/valueNodes/StructFieldValueNode.ts
function structFieldValueNode(name, value) {
  return Object.freeze({
    kind: "structFieldValueNode",
    // Data.
    name: camelCase(name),
    // Children.
    value
  });
}

// src/valueNodes/StructValueNode.ts
function structValueNode(fields) {
  return Object.freeze({
    kind: "structValueNode",
    // Children.
    fields
  });
}

// src/valueNodes/TupleValueNode.ts
function tupleValueNode(items) {
  return Object.freeze({
    kind: "tupleValueNode",
    // Children.
    items
  });
}

// src/AccountNode.ts
function accountNode(input) {
  return Object.freeze({
    kind: "accountNode",
    // Data.
    name: camelCase(input.name),
    ...input.size === void 0 ? {} : { size: input.size },
    docs: parseDocs(input.docs),
    // Children.
    data: input.data ?? structTypeNode([]),
    ...input.pda !== void 0 && { pda: input.pda },
    ...input.discriminators !== void 0 && { discriminators: input.discriminators }
  });
}

// src/DefinedTypeNode.ts
function definedTypeNode(input) {
  return Object.freeze({
    kind: "definedTypeNode",
    // Data.
    name: camelCase(input.name),
    docs: parseDocs(input.docs),
    // Children.
    type: input.type
  });
}

// src/ErrorNode.ts
function errorNode(input) {
  return Object.freeze({
    kind: "errorNode",
    // Data.
    name: camelCase(input.name),
    code: input.code,
    message: input.message,
    docs: parseDocs(input.docs)
  });
}

// src/InstructionAccountNode.ts
function instructionAccountNode(input) {
  return Object.freeze({
    kind: "instructionAccountNode",
    // Data.
    name: camelCase(input.name),
    isWritable: input.isWritable,
    isSigner: input.isSigner,
    isOptional: input.isOptional ?? false,
    docs: parseDocs(input.docs),
    // Children.
    ...input.defaultValue !== void 0 && { defaultValue: input.defaultValue }
  });
}

// src/InstructionArgumentNode.ts
function instructionArgumentNode(input) {
  return Object.freeze({
    kind: "instructionArgumentNode",
    // Data.
    name: camelCase(input.name),
    ...input.defaultValueStrategy !== void 0 && { defaultValueStrategy: input.defaultValueStrategy },
    docs: parseDocs(input.docs),
    // Children.
    type: input.type,
    ...input.defaultValue !== void 0 && { defaultValue: input.defaultValue }
  });
}
function structTypeNodeFromInstructionArgumentNodes(nodes) {
  return structTypeNode(nodes.map(structFieldTypeNodeFromInstructionArgumentNode));
}
function structFieldTypeNodeFromInstructionArgumentNode(node) {
  if (isNode(node.defaultValue, VALUE_NODES)) {
    return structFieldTypeNode({ ...node, defaultValue: node.defaultValue });
  }
  return structFieldTypeNode({
    ...node,
    defaultValue: void 0,
    defaultValueStrategy: void 0
  });
}

// src/InstructionByteDeltaNode.ts
function instructionByteDeltaNode(value, options = {}) {
  return Object.freeze({
    kind: "instructionByteDeltaNode",
    // Data.
    withHeader: options.withHeader ?? !isNode(value, "resolverValueNode"),
    ...options.subtract !== void 0 && { subtract: options.subtract },
    // Children.
    value
  });
}

// src/ProgramNode.ts
function programNode(input) {
  return Object.freeze({
    kind: "programNode",
    // Data.
    name: camelCase(input.name),
    publicKey: input.publicKey,
    version: input.version ?? "0.0.0",
    ...input.origin !== void 0 && { origin: input.origin },
    docs: parseDocs(input.docs),
    // Children.
    accounts: input.accounts ?? [],
    instructions: input.instructions ?? [],
    definedTypes: input.definedTypes ?? [],
    pdas: input.pdas ?? [],
    errors: input.errors ?? []
  });
}
function getAllPrograms(node) {
  if (Array.isArray(node)) return node;
  if (node.kind === "programNode") return [node];
  return [node.program, ...node.additionalPrograms];
}
function getAllPdas(node) {
  return getAllPrograms(node).flatMap((program) => program.pdas);
}
function getAllAccounts(node) {
  return getAllPrograms(node).flatMap((program) => program.accounts);
}
function getAllDefinedTypes(node) {
  return getAllPrograms(node).flatMap((program) => program.definedTypes);
}
function getAllInstructions(node) {
  return getAllPrograms(node).flatMap((program) => program.instructions);
}
function getAllErrors(node) {
  return getAllPrograms(node).flatMap((program) => program.errors);
}

// src/InstructionNode.ts
function instructionNode(input) {
  return Object.freeze({
    kind: "instructionNode",
    // Data.
    name: camelCase(input.name),
    docs: parseDocs(input.docs),
    optionalAccountStrategy: parseOptionalAccountStrategy(input.optionalAccountStrategy),
    // Children.
    accounts: input.accounts ?? [],
    arguments: input.arguments ?? [],
    extraArguments: input.extraArguments,
    remainingAccounts: input.remainingAccounts,
    byteDeltas: input.byteDeltas,
    discriminators: input.discriminators,
    subInstructions: input.subInstructions
  });
}
function parseOptionalAccountStrategy(optionalAccountStrategy) {
  return optionalAccountStrategy ?? "programId";
}
function getAllInstructionArguments(node) {
  return [...node.arguments, ...node.extraArguments ?? []];
}
function getAllInstructionsWithSubs(node, config = {}) {
  const { leavesOnly = false, subInstructionsFirst = false } = config;
  if (isNode(node, "instructionNode")) {
    if (!node.subInstructions || node.subInstructions.length === 0) return [node];
    const subInstructions = node.subInstructions.flatMap((sub) => getAllInstructionsWithSubs(sub, config));
    if (leavesOnly) return subInstructions;
    return subInstructionsFirst ? [...subInstructions, node] : [node, ...subInstructions];
  }
  const instructions = isNode(node, "programNode") ? node.instructions : getAllInstructions(node);
  return instructions.flatMap((instruction) => getAllInstructionsWithSubs(instruction, config));
}

// src/InstructionRemainingAccountsNode.ts
function instructionRemainingAccountsNode(value, options = {}) {
  return Object.freeze({
    kind: "instructionRemainingAccountsNode",
    // Data.
    ...options.isOptional !== void 0 && { isOptional: options.isOptional },
    ...options.isSigner !== void 0 && { isSigner: options.isSigner },
    ...options.isWritable !== void 0 && { isWritable: options.isWritable },
    docs: parseDocs(options.docs),
    // Children.
    value
  });
}

// src/PdaNode.ts
function pdaNode(input) {
  return Object.freeze({
    kind: "pdaNode",
    // Data.
    name: camelCase(input.name),
    docs: parseDocs(input.docs),
    ...input.programId && { programId: input.programId },
    // Children.
    seeds: input.seeds
  });
}

// src/RootNode.ts
function rootNode(program, additionalPrograms) {
  return Object.freeze({
    kind: "rootNode",
    // Data.
    standard: "codama",
    version: "1.2.11",
    // Children.
    program,
    additionalPrograms: additionalPrograms ?? []
  });
}
export {
  CONTEXTUAL_VALUE_NODES,
  COUNT_NODES,
  DISCRIMINATOR_NODES,
  ENUM_VARIANT_TYPE_NODES,
  INSTRUCTION_INPUT_VALUE_NODES,
  LINK_NODES,
  PDA_SEED_NODES,
  REGISTERED_CONTEXTUAL_VALUE_NODE_KINDS,
  REGISTERED_COUNT_NODE_KINDS,
  REGISTERED_DISCRIMINATOR_NODE_KINDS,
  REGISTERED_LINK_NODE_KINDS,
  REGISTERED_NODE_KINDS,
  REGISTERED_PDA_SEED_NODE_KINDS,
  REGISTERED_TYPE_NODE_KINDS,
  REGISTERED_VALUE_NODE_KINDS,
  STANDALONE_CONTEXTUAL_VALUE_NODE_KINDS,
  STANDALONE_TYPE_NODE_KINDS,
  STANDALONE_VALUE_NODE_KINDS,
  TYPE_NODES,
  VALUE_NODES,
  accountBumpValueNode,
  accountLinkNode,
  accountNode,
  accountValueNode,
  amountTypeNode,
  argumentValueNode,
  arrayTypeNode,
  arrayValueNode,
  assertIsNestedTypeNode,
  assertIsNode,
  assertIsNodeFilter,
  booleanTypeNode,
  booleanValueNode,
  bytesTypeNode,
  bytesValueNode,
  camelCase,
  capitalize,
  conditionalValueNode,
  constantDiscriminatorNode,
  constantPdaSeedNode,
  constantPdaSeedNodeFromBytes,
  constantPdaSeedNodeFromProgramId,
  constantPdaSeedNodeFromString,
  constantValueNode,
  constantValueNodeFromBytes,
  constantValueNodeFromString,
  dateTimeTypeNode,
  definedTypeLinkNode,
  definedTypeNode,
  enumEmptyVariantTypeNode,
  enumStructVariantTypeNode,
  enumTupleVariantTypeNode,
  enumTypeNode,
  enumValueNode,
  errorNode,
  fieldDiscriminatorNode,
  fixedCountNode,
  fixedSizeTypeNode,
  getAllAccounts,
  getAllDefinedTypes,
  getAllErrors,
  getAllInstructionArguments,
  getAllInstructions,
  getAllInstructionsWithSubs,
  getAllPdas,
  getAllPrograms,
  hiddenPrefixTypeNode,
  hiddenSuffixTypeNode,
  identityValueNode,
  instructionAccountLinkNode,
  instructionAccountNode,
  instructionArgumentLinkNode,
  instructionArgumentNode,
  instructionByteDeltaNode,
  instructionLinkNode,
  instructionNode,
  instructionRemainingAccountsNode,
  isDataEnum,
  isDecimal,
  isInteger,
  isNestedTypeNode,
  isNode,
  isNodeFilter,
  isScalarEnum,
  isSignedInteger,
  isUnsignedInteger,
  kebabCase,
  mapEntryValueNode,
  mapTypeNode,
  mapValueNode,
  noneValueNode,
  numberTypeNode,
  numberValueNode,
  optionTypeNode,
  parseDocs,
  parseOptionalAccountStrategy,
  pascalCase,
  payerValueNode,
  pdaLinkNode,
  pdaNode,
  pdaSeedValueNode,
  pdaValueNode,
  postOffsetTypeNode,
  preOffsetTypeNode,
  prefixedCountNode,
  programIdValueNode,
  programLinkNode,
  programNode,
  publicKeyTypeNode,
  publicKeyValueNode,
  remainderCountNode,
  remainderOptionTypeNode,
  removeNullAndAssertIsNodeFilter,
  resolveNestedTypeNode,
  resolverValueNode,
  rootNode,
  sentinelTypeNode,
  setTypeNode,
  setValueNode,
  sizeDiscriminatorNode,
  sizePrefixTypeNode,
  snakeCase,
  solAmountTypeNode,
  someValueNode,
  stringTypeNode,
  stringValueNode,
  structFieldTypeNode,
  structFieldTypeNodeFromInstructionArgumentNode,
  structFieldValueNode,
  structTypeNode,
  structTypeNodeFromInstructionArgumentNodes,
  structValueNode,
  titleCase,
  transformNestedTypeNode,
  tupleTypeNode,
  tupleValueNode,
  variablePdaSeedNode,
  zeroableOptionTypeNode
};
//# sourceMappingURL=index.react-native.mjs.map