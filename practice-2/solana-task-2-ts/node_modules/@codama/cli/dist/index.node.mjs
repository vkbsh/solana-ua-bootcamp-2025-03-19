// src/program.ts
import { createCommand } from "commander";

// src/commands/init.ts
import prompts from "prompts";

// src/utils/fs.ts
import { R_OK, W_OK } from "node:constants";
import fs from "node:fs";
import path from "node:path";
function resolveRelativePath(childPath, relativeDirectory = null) {
  return path.resolve(relativeDirectory ?? process.cwd(), childPath);
}
function resolveConfigPath(childPath, configPath) {
  const configDir = configPath ? path.dirname(configPath) : null;
  return resolveRelativePath(childPath, configDir);
}
function isLocalModulePath(modulePath) {
  return modulePath.startsWith(".") || modulePath.startsWith("/");
}
async function writeFile(filePath, content) {
  const directory = path.dirname(filePath);
  if (!await canWrite(directory)) {
    await fs.promises.mkdir(directory, { recursive: true });
  }
  await fs.promises.writeFile(filePath, content);
}
async function canRead(p) {
  try {
    await fs.promises.access(p, R_OK);
    return true;
  } catch {
    return false;
  }
}
async function canWrite(p) {
  try {
    await fs.promises.access(p, W_OK);
    return true;
  } catch {
    return false;
  }
}

// src/utils/import.ts
import { createRequire } from "node:module";
async function importModuleItem(identifier, modulePath, itemName = "default") {
  const module = await importModule(identifier, modulePath);
  const item = pickModuleItem(module, itemName);
  if (item === void 0) {
    throw new Error(`Failed to import "${itemName}" from ${identifier} at "${modulePath}".`);
  }
  return item;
}
function pickModuleItem(module, itemName) {
  if (itemName === "default") {
    return module.default?.default ?? module.default ?? module;
  }
  return module[itemName] ?? module.default?.[itemName] ?? module.default?.default?.[itemName];
}
async function importModule(identifier, modulePath) {
  if (isLocalModulePath(modulePath)) {
    return await importLocalModule(identifier, modulePath);
  }
  try {
    return await importExternalUserModule(identifier, modulePath);
  } catch {
    return await importExternalModule(identifier, modulePath);
  }
}
async function importLocalModule(identifier, modulePath) {
  if (!await canRead(modulePath)) {
    throw new Error(`Cannot access ${identifier} at "${modulePath}"`);
  }
  const dotIndex = modulePath.lastIndexOf(".");
  const extension = dotIndex === -1 ? void 0 : modulePath.slice(dotIndex);
  const modulePromise = extension === ".json" ? import(modulePath, { with: { type: "json" } }) : import(modulePath);
  return await handleImportPromise(modulePromise, identifier, modulePath);
}
async function importExternalModule(identifier, modulePath) {
  return await handleImportPromise(import(modulePath), identifier, modulePath);
}
async function importExternalUserModule(identifier, modulePath) {
  const userPackageJsonPath = resolveRelativePath("package.json");
  const userRequire = createRequire(userPackageJsonPath);
  const userModulePath = userRequire.resolve(modulePath);
  return await importExternalModule(identifier, userModulePath);
}
async function handleImportPromise(importPromise, identifier, modulePath) {
  try {
    return await importPromise;
  } catch (error) {
    let causeMessage = !!error && typeof error === "object" && "message" in error && typeof error.message === "string" ? error.message : void 0;
    causeMessage = causeMessage ? ` (caused by: ${causeMessage})` : "";
    throw new Error(`Failed to import ${identifier} at "${modulePath}" as a module${causeMessage}`, {
      cause: error
    });
  }
}

// src/utils/logs.ts
import pico from "picocolors";
function logSuccess(...args) {
  console.log(pico.green("[Success]"), ...args);
}
function logInfo(...args) {
  console.log(pico.blueBright("[Info]"), ...args);
}
function logWarning(...args) {
  console.log(pico.yellow("[Warning]"), ...args);
}
function logError(...args) {
  console.log(pico.red("[Error]"), ...args);
}
function logDebug(...args) {
  console.log(pico.magenta("[Debug]"), ...args);
}
function logBanner() {
  console.log(getBanner());
}
function getBanner() {
  const textBanner = "Welcome to Codama!";
  const gradientBanner = pico.bold(`\x1B[38;2;231;171;97m${textBanner}\x1B[0m`);
  return process.stdout.isTTY && process.stdout.getColorDepth() > 8 ? gradientBanner : textBanner;
}

// src/utils/nodes.ts
import { rootNodeFromAnchor } from "@codama/nodes-from-anchor";
function getRootNodeFromIdl(idl) {
  if (typeof idl !== "object" || idl === null) {
    throw new Error("Unexpected IDL content. Expected an object, got " + typeof idl);
  }
  if (isRootNode(idl)) {
    return idl;
  }
  return rootNodeFromAnchor(idl);
}
function isRootNode(value) {
  return typeof value === "object" && value !== null && value.standard === "codama" && value.kind === "rootNode";
}

// src/utils/promises.ts
function promisify(value) {
  return Promise.resolve(value);
}

// src/utils/visitors.ts
import { rootNodeVisitor, visit } from "@codama/visitors-core";
async function getRootNodeVisitors(visitors) {
  return await Promise.all(visitors.map(getRootNodeVisitor));
}
async function getRootNodeVisitor(visitorConfig) {
  const { args, item, path: path3 } = visitorConfig;
  const identifier = getVisitorIdentifier(visitorConfig);
  const moduleItem = await importModuleItem(identifier, path3, item);
  const visitor = await getVisitorFromModuleItem(identifier, moduleItem, args);
  return rootNodeVisitor((root) => {
    const result = visit(root, visitor);
    return isRootNode(result) ? result : root;
  });
}
async function getVisitorFromModuleItem(identifier, moduleItem, args) {
  if (isRootNodeVisitor(moduleItem)) {
    return moduleItem;
  }
  if (typeof moduleItem === "function") {
    const result = await promisify(moduleItem(...args));
    if (isRootNodeVisitor(result)) {
      return result;
    }
  }
  throw new Error(`Invalid ${identifier}. Expected a visitor or a function returning a visitor.`);
}
function isRootNodeVisitor(value) {
  return !!value && typeof value === "object" && "visitRoot" in value;
}
function getVisitorIdentifier(visitorConfig) {
  const { index, item, path: path3, script } = visitorConfig;
  const pathWithItem = item ? `${path3}#${item}` : path3;
  let identifier = `visitor of index #${index}`;
  identifier += script ? ` in script "${script}"` : "";
  identifier += ` (at path "${pathWithItem}")`;
  return identifier;
}

// src/commands/init.ts
function setInitCommand(program) {
  program.command("init").argument("[output]", "Optional path used to output the configuration file").option("-d, --default", "Bypass prompts and select all defaults options").option("--js", "Forces the output to be a JavaScript file").action(doInit);
}
async function doInit(explicitOutput, options) {
  const output = getOutputPath(explicitOutput, options);
  const useJsFile = options.js || output.endsWith(".js");
  if (await canRead(output)) {
    throw new Error(`Configuration file already exists at "${output}".`);
  }
  logBanner();
  const result = await getPromptResult(options);
  const content = getContentFromPromptResult(result, useJsFile);
  await writeFile(output, content);
  logSuccess(`Configuration file created at "${output}".`);
}
function getOutputPath(explicitOutput, options) {
  if (explicitOutput) {
    return resolveRelativePath(explicitOutput);
  }
  return resolveRelativePath(options.js ? "codama.js" : "codama.json");
}
async function getPromptResult(options) {
  const defaults = getDefaultPromptResult();
  if (options.default) {
    return defaults;
  }
  const hasScript = (script, type = "text") => (_, values) => values.scripts.includes(script) ? type : null;
  const result = await prompts(
    [
      {
        initial: defaults.idlPath,
        message: "Where is your IDL located? (Supports Codama and Anchor IDLs).",
        name: "idlPath",
        type: "text"
      },
      {
        choices: [
          { selected: true, title: "Generate JavaScript client", value: "js" },
          { selected: true, title: "Generate Rust client", value: "rust" }
        ],
        instructions: "[space] to toggle / [a] to toggle all / [enter] to submit",
        message: "Which script preset would you like to use?",
        name: "scripts",
        type: "multiselect"
      },
      {
        initial: defaults.jsPath,
        message: "[js] Where should the JavaScript code be generated?",
        name: "jsPath",
        type: hasScript("js")
      },
      {
        initial: defaults.rustCrate,
        message: "[rust] Where is the Rust client crate located?",
        name: "rustCrate",
        type: hasScript("rust")
      },
      {
        initial: (prev) => `${prev}/src/generated`,
        message: "[rust] Where should the Rust code be generated?",
        name: "rustPath",
        type: hasScript("rust")
      }
    ],
    {
      onCancel: () => {
        throw new Error("Operation cancelled.");
      }
    }
  );
  return result;
}
function getDefaultPromptResult() {
  return {
    idlPath: "program/idl.json",
    jsPath: "clients/js/src/generated",
    rustCrate: "clients/rust",
    rustPath: "clients/rust/src/generated",
    scripts: ["js", "rust"]
  };
}
function getContentFromPromptResult(result, useJsFile) {
  const scripts = {};
  if (result.scripts.includes("js")) {
    scripts.js = {
      from: "@codama/renderers-js",
      args: [result.jsPath]
    };
  }
  if (result.scripts.includes("rust")) {
    scripts.rust = {
      from: "@codama/renderers-rust",
      args: [result.rustPath, { crateFolder: result.rustCrate, formatCode: true }]
    };
  }
  const content = { idl: result.idlPath, before: [], scripts };
  if (!useJsFile) {
    return JSON.stringify(content, null, 4);
  }
  return "export default " + JSON.stringify(content, null, 4).replace(/"([^"]+)":/g, "$1:").replace(/"([^"]*)"/g, "'$1'");
}

// src/commands/run.ts
import { visit as visit2 } from "@codama/visitors-core";

// src/config.ts
import path2 from "node:path";
async function getConfig(options) {
  const configPath = options.config != null ? path2.resolve(options.config) : await getDefaultConfigPath();
  if (!configPath) {
    logWarning("No config file found. Using empty configs. Make sure you provide the `--idl` option.");
    return [{}, configPath];
  }
  const configFile = await importModuleItem("config file", configPath);
  if (!configFile || typeof configFile !== "object") {
    throw new Error(`Invalid config file at "${configPath}"`);
  }
  return [configFile, configPath];
}
async function getDefaultConfigPath() {
  const candidatePaths = ["codama.js", "codama.mjs", "codama.cjs", "codama.json"];
  for (const candidatePath of candidatePaths) {
    const resolvedPath = path2.resolve(process.cwd(), candidatePath);
    if (await canRead(resolvedPath)) {
      return resolvedPath;
    }
  }
  return null;
}

// src/parsedConfig.ts
async function getParsedConfigFromCommand(cmd) {
  return await getParsedConfig(cmd.optsWithGlobals());
}
async function getParsedConfig(options) {
  const [config, configPath] = await getConfig(options);
  return await parseConfig(config, configPath, options);
}
async function parseConfig(config, configPath, options) {
  const idlPath = parseIdlPath(config, configPath, options);
  const idlContent = await importModuleItem("IDL", idlPath);
  const rootNode = getRootNodeFromIdl(idlContent);
  const scripts = parseScripts(config.scripts ?? {}, configPath);
  const visitors = (config.before ?? []).map((v, i) => parseVisitorConfig(v, configPath, i, null));
  return { configPath, idlContent, idlPath, rootNode, scripts, before: visitors };
}
function parseIdlPath(config, configPath, options) {
  if (options.idl) {
    return resolveRelativePath(options.idl);
  }
  if (config.idl) {
    return resolveConfigPath(config.idl, configPath);
  }
  throw new Error("No IDL identified. Please provide the `--idl` option or set it in the config file.");
}
function parseScripts(scripts, configPath) {
  const entryPromises = Object.entries(scripts).map(([name, scriptConfig]) => {
    const visitors = Array.isArray(scriptConfig) ? scriptConfig : [scriptConfig];
    return [name, visitors.map((v, i) => parseVisitorConfig(v, configPath, i, name))];
  });
  return Object.fromEntries(entryPromises);
}
function parseVisitorConfig(visitorConfig, configPath, index, script) {
  const emptyArgs = [];
  const visitorPath = typeof visitorConfig === "string" ? visitorConfig : visitorConfig.from;
  const visitorArgs = typeof visitorConfig === "string" ? emptyArgs : visitorConfig.args ?? emptyArgs;
  const [path3, item] = resolveVisitorPath(visitorPath, configPath);
  return { args: visitorArgs, index, item, path: path3, script };
}
function resolveVisitorPath(visitorPath, configPath) {
  const [modulePath, itemName] = visitorPath.split("#");
  const resolveModulePath = isLocalModulePath(modulePath) ? resolveConfigPath(modulePath, configPath) : modulePath;
  return [resolveModulePath, itemName];
}

// src/commands/run.ts
function setRunCommand(program) {
  program.command("run").argument("[scripts...]", "The scripts to execute").option("-a, --all", "Run all scripts in the config file").action(doRun);
}
async function doRun(explicitScripts, { all }, cmd) {
  if (all && explicitScripts.length > 0) {
    logWarning(`CLI arguments "${explicitScripts.join(" ")}" are ignored because the "--all" option is set.`);
  }
  const parsedConfig = await getParsedConfigFromCommand(cmd);
  const scripts = all ? Object.keys(parsedConfig.scripts) : explicitScripts;
  const plans = await getPlans(parsedConfig, scripts);
  runPlans(plans, parsedConfig.rootNode);
}
async function getPlans(parsedConfig, scripts) {
  const plans = [];
  if (scripts.length === 0 && parsedConfig.before.length === 0) {
    throw new Error("There are no scripts or before visitors to run.");
  }
  const missingScripts = scripts.filter((script) => !parsedConfig.scripts[script]);
  if (missingScripts.length > 0) {
    const scriptPluralized = missingScripts.length === 1 ? "Script" : "Scripts";
    const missingScriptsIdentifier = `${scriptPluralized} "${missingScripts.join(", ")}"`;
    const message = parsedConfig.configPath ? `${missingScriptsIdentifier} not found in config file "${parsedConfig.configPath}"` : `${missingScriptsIdentifier} not found because no config file was found`;
    throw new Error(message);
  }
  if (parsedConfig.before.length > 0) {
    plans.push({ script: null, visitors: await getRootNodeVisitors(parsedConfig.before) });
  }
  for (const script of scripts) {
    plans.push({ script, visitors: await getRootNodeVisitors(parsedConfig.scripts[script]) });
  }
  return plans;
}
function runPlans(plans, rootNode) {
  for (const plan of plans) {
    const result = runPlan(plan, rootNode);
    if (!plan.script) {
      rootNode = result;
    }
  }
}
function runPlan(plan, rootNode) {
  const visitorLength = plan.visitors.length;
  const visitorPluralized = visitorLength === 1 ? "visitor" : "visitors";
  const identifier = plan.script ? `script "${plan.script}" with ${visitorLength} ${visitorPluralized}` : `${visitorLength} before ${visitorPluralized}`;
  logInfo(`Running ${identifier}...`);
  const newRoot = plan.visitors.reduce(visit2, rootNode);
  logSuccess(`Executed ${identifier}!`);
  return newRoot;
}

// src/programOptions.ts
function setProgramOptions(program) {
  program.option("--debug", "include debugging information, such as stack dump").option("-i, --idl <path>", "The path to the IDL to use.").option("-c, --config <path>", "The path to the Codama configuration file. Defaults to `codama.(js|json)`.");
}

// src/program.ts
async function codama(args, opts) {
  await createProgram({
    exitOverride: true,
    suppressOutput: opts?.suppressOutput
  }).parseAsync(args, { from: "user" });
}
function createProgram(internalOptions) {
  const program = createCommand().version("1.0.10").allowExcessArguments(false).configureHelp({ showGlobalOptions: true, sortOptions: true, sortSubcommands: true });
  setProgramOptions(program);
  setInitCommand(program);
  setRunCommand(program);
  if (internalOptions?.exitOverride) {
    program.exitOverride();
  }
  if (internalOptions?.suppressOutput) {
    program.configureOutput({
      writeErr: () => {
      },
      writeOut: () => {
      }
    });
  }
  return program;
}
export {
  codama,
  createProgram,
  logBanner,
  logDebug,
  logError,
  logInfo,
  logSuccess,
  logWarning
};
//# sourceMappingURL=index.node.mjs.map