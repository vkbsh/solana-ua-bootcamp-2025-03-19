{"version":3,"sources":["../src/index.ts","../src/ImportMap.ts","../src/getRenderMapVisitor.ts","../src/ContextMap.ts","../src/getTypeManifestVisitor.ts","../src/utils/codecs.ts","../src/utils/customData.ts","../src/utils/gpaField.ts","../src/utils/linkOverrides.ts","../src/utils/render.ts","../src/renderInstructionDefaults.ts","../src/renderVisitor.ts","../src/getValidatorBagVisitor.ts"],"sourcesContent":["export * from './ImportMap';\nexport * from './getRenderMapVisitor';\nexport * from './getTypeManifestVisitor';\nexport * from './renderVisitor';\n\nexport { renderVisitor as default } from './renderVisitor';\n","import { TypeManifest } from './getTypeManifestVisitor';\n\nconst DEFAULT_MODULE_MAP: Record<string, string> = {\n    errors: '../errors',\n    shared: '../shared',\n    types: '../types',\n    umi: '@metaplex-foundation/umi',\n    umiSerializers: '@metaplex-foundation/umi/serializers',\n};\n\nexport class ImportMap {\n    protected readonly _imports: Map<string, Set<string>> = new Map();\n\n    protected readonly _aliases: Map<string, Record<string, string>> = new Map();\n\n    add(module: string, imports: Set<string> | string[] | string): ImportMap {\n        const currentImports = this._imports.get(module) ?? new Set();\n        const newImports = typeof imports === 'string' ? [imports] : imports;\n        newImports.forEach(i => currentImports.add(i));\n        this._imports.set(module, currentImports);\n        return this;\n    }\n\n    remove(module: string, imports: Set<string> | string[] | string): ImportMap {\n        const currentImports = this._imports.get(module) ?? new Set();\n        const importsToRemove = typeof imports === 'string' ? [imports] : imports;\n        importsToRemove.forEach(i => currentImports.delete(i));\n        if (currentImports.size === 0) {\n            this._imports.delete(module);\n        } else {\n            this._imports.set(module, currentImports);\n        }\n        return this;\n    }\n\n    mergeWith(...others: ImportMap[]): ImportMap {\n        others.forEach(other => {\n            other._imports.forEach((imports, module) => {\n                this.add(module, imports);\n            });\n            other._aliases.forEach((aliases, module) => {\n                Object.entries(aliases).forEach(([name, alias]) => {\n                    this.addAlias(module, name, alias);\n                });\n            });\n        });\n        return this;\n    }\n\n    mergeWithManifest(manifest: TypeManifest): ImportMap {\n        return this.mergeWith(manifest.strictImports, manifest.looseImports, manifest.serializerImports);\n    }\n\n    addAlias(module: string, name: string, alias: string): ImportMap {\n        const currentAliases = this._aliases.get(module) ?? {};\n        currentAliases[name] = alias;\n        this._aliases.set(module, currentAliases);\n        return this;\n    }\n\n    isEmpty(): boolean {\n        return this._imports.size === 0;\n    }\n\n    toString(dependencies: Record<string, string>): string {\n        const dependencyMap = { ...DEFAULT_MODULE_MAP, ...dependencies };\n        const importStatements = [...this._imports.entries()]\n            .map(([module, imports]) => {\n                const mappedModule: string = dependencyMap[module] ?? module;\n                return [mappedModule, module, imports] as const;\n            })\n            .sort(([a], [b]) => {\n                const aIsRelative = a.startsWith('.');\n                const bIsRelative = b.startsWith('.');\n                if (aIsRelative && !bIsRelative) return 1;\n                if (!aIsRelative && bIsRelative) return -1;\n                return a.localeCompare(b);\n            })\n            .map(([mappedModule, module, imports]) => {\n                const aliasMap = this._aliases.get(module) ?? {};\n                const joinedImports = [...imports]\n                    .sort()\n                    .map(i => (aliasMap[i] ? `${i} as ${aliasMap[i]}` : i))\n                    .join(', ');\n                return `import { ${joinedImports} } from '${mappedModule}';`;\n            });\n        return importStatements.join('\\n');\n    }\n}\n","import { logWarn } from '@codama/errors';\nimport {\n    camelCase,\n    CamelCaseString,\n    definedTypeNode,\n    FieldDiscriminatorNode,\n    getAllAccounts,\n    getAllDefinedTypes,\n    getAllInstructionArguments,\n    getAllInstructionsWithSubs,\n    getAllPrograms,\n    InstructionNode,\n    isDataEnum,\n    isNode,\n    isNodeFilter,\n    parseOptionalAccountStrategy,\n    pascalCase,\n    ProgramNode,\n    resolveNestedTypeNode,\n    SizeDiscriminatorNode,\n    structTypeNodeFromInstructionArgumentNodes,\n    VALUE_NODES,\n} from '@codama/nodes';\nimport { RenderMap } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    getByteSizeVisitor,\n    getResolvedInstructionInputsVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    ResolvedInstructionAccount,\n    ResolvedInstructionInput,\n    staticVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\nimport { ContextMap } from './ContextMap';\nimport { getTypeManifestVisitor } from './getTypeManifestVisitor';\nimport { ImportMap } from './ImportMap';\nimport { renderInstructionDefaults } from './renderInstructionDefaults';\nimport {\n    CustomDataOptions,\n    getDefinedTypeNodesToExtract,\n    getGpaFieldsFromAccount,\n    getImportFromFactory,\n    LinkOverrides,\n    parseCustomDataOptions,\n    render,\n} from './utils';\n\nexport type GetRenderMapOptions = {\n    customAccountData?: CustomDataOptions[];\n    customInstructionData?: CustomDataOptions[];\n    dependencyMap?: Record<string, string>;\n    internalNodes?: string[];\n    linkOverrides?: LinkOverrides;\n    nonScalarEnums?: string[];\n    renderParentInstructions?: boolean;\n};\n\nexport function getRenderMapVisitor(options: GetRenderMapOptions = {}): Visitor<RenderMap> {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n    let program: ProgramNode | null = null;\n\n    const renderParentInstructions = options.renderParentInstructions ?? false;\n    const dependencyMap = {\n        generated: '..',\n        hooked: '../../hooked',\n        mplEssentials: '@metaplex-foundation/mpl-toolbox',\n        mplToolbox: '@metaplex-foundation/mpl-toolbox',\n        umi: '@metaplex-foundation/umi',\n        umiSerializers: '@metaplex-foundation/umi/serializers',\n        ...options.dependencyMap,\n\n        // Custom relative dependencies to link generated files together.\n        generatedAccounts: '../accounts',\n        generatedErrors: '../errors',\n        generatedInstructions: '../instructions',\n        generatedPrograms: '../programs',\n        generatedTypes: '../types',\n    };\n    const nonScalarEnums = (options.nonScalarEnums ?? []).map(camelCase);\n    const internalNodes = (options.internalNodes ?? []).map(camelCase);\n    const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], 'AccountData');\n    const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], 'InstructionData');\n    const getImportFrom = getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData);\n\n    const typeManifestVisitor = getTypeManifestVisitor({\n        customAccountData,\n        customInstructionData,\n        getImportFrom,\n        linkables,\n        nonScalarEnums,\n        stack,\n    });\n    const resolvedInstructionInputVisitor = getResolvedInstructionInputsVisitor();\n    const byteSizeVisitor = getByteSizeVisitor(linkables, { stack });\n\n    function getInstructionAccountType(account: ResolvedInstructionAccount): string {\n        if (account.isPda && account.isSigner === false) return 'Pda';\n        if (account.isSigner === 'either') return 'PublicKey | Pda | Signer';\n        return account.isSigner ? 'Signer' : 'PublicKey | Pda';\n    }\n\n    function getInstructionAccountImports(accounts: ResolvedInstructionAccount[]): ImportMap {\n        const imports = new ImportMap();\n        accounts.forEach(account => {\n            if (account.isSigner !== true && !account.isPda) imports.add('umi', 'PublicKey');\n            if (account.isSigner !== true) imports.add('umi', 'Pda');\n            if (account.isSigner !== false) imports.add('umi', 'Signer');\n        });\n        return imports;\n    }\n\n    function getMergeConflictsForInstructionAccountsAndArgs(instruction: InstructionNode): string[] {\n        const allNames = [\n            ...instruction.accounts.map(account => account.name),\n            ...instruction.arguments.map(field => field.name),\n            ...(instruction.extraArguments ?? []).map(field => field.name),\n        ];\n        const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);\n        return [...new Set(duplicates)];\n    }\n\n    return pipe(\n        staticVisitor(() => new RenderMap()),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node) {\n                    const customData = customAccountData.get(node.name);\n                    const isLinked = !!customData;\n                    const typeManifest = visit(node, typeManifestVisitor);\n                    const imports = new ImportMap().mergeWith(\n                        typeManifest.strictImports,\n                        typeManifest.serializerImports,\n                    );\n                    if (!isLinked) {\n                        imports.mergeWith(typeManifest.looseImports);\n                    }\n                    imports\n                        .add('umi', [\n                            'Account',\n                            'assertAccountExists',\n                            'Context',\n                            'deserializeAccount',\n                            'Pda',\n                            'PublicKey',\n                            'publicKey',\n                            'RpcAccount',\n                            'RpcGetAccountOptions',\n                            'RpcGetAccountsOptions',\n                        ])\n                        .add('umiSerializers', !isLinked ? ['Serializer'] : [])\n                        .addAlias('umi', 'publicKey', 'toPublicKey');\n\n                    // Discriminator.\n                    const discriminator =\n                        (node.discriminators ?? []).find(d => !isNode(d, 'constantDiscriminatorNode')) ?? null;\n                    let resolvedDiscriminator:\n                        | SizeDiscriminatorNode\n                        | (FieldDiscriminatorNode & { value: string })\n                        | null = null;\n                    if (isNode(discriminator, 'fieldDiscriminatorNode')) {\n                        const discriminatorField = resolveNestedTypeNode(node.data).fields.find(\n                            f => f.name === discriminator.name,\n                        );\n                        const discriminatorValue = discriminatorField?.defaultValue\n                            ? visit(discriminatorField.defaultValue, typeManifestVisitor)\n                            : undefined;\n                        if (discriminatorValue) {\n                            imports.mergeWith(discriminatorValue.valueImports);\n                            resolvedDiscriminator = {\n                                ...discriminator,\n                                value: discriminatorValue.value,\n                            };\n                        }\n                    } else if (isNode(discriminator, 'sizeDiscriminatorNode')) {\n                        resolvedDiscriminator = discriminator;\n                    }\n\n                    // GPA Fields.\n                    const gpaFields = getGpaFieldsFromAccount(node, byteSizeVisitor).map(gpaField => {\n                        const gpaFieldManifest = visit(gpaField.type, typeManifestVisitor);\n                        imports.mergeWith(gpaFieldManifest.looseImports, gpaFieldManifest.serializerImports);\n                        return { ...gpaField, manifest: gpaFieldManifest };\n                    });\n                    let resolvedGpaFields: { argument: string; type: string } | null = null;\n                    if (gpaFields.length > 0) {\n                        imports.add('umi', ['gpaBuilder']);\n                        resolvedGpaFields = {\n                            argument: `{ ${gpaFields\n                                .map(f => {\n                                    const offset = f.offset === null ? 'null' : `${f.offset}`;\n                                    return `'${f.name}': [${offset}, ${f.manifest.serializer}]`;\n                                })\n                                .join(', ')} }`,\n                            type: `{ ${gpaFields.map(f => `'${f.name}': ${f.manifest.looseType}`).join(', ')} }`,\n                        };\n                    }\n\n                    // Seeds.\n                    const pda = node.pda ? linkables.get([...stack.getPath(), node.pda]) : undefined;\n                    const pdaSeeds = pda?.seeds ?? [];\n                    const seeds = pdaSeeds.map(seed => {\n                        if (isNode(seed, 'variablePdaSeedNode')) {\n                            const seedManifest = visit(seed.type, typeManifestVisitor);\n                            imports.mergeWith(seedManifest.looseImports, seedManifest.serializerImports);\n                            return { ...seed, typeManifest: seedManifest };\n                        }\n                        if (isNode(seed.value, 'programIdValueNode')) {\n                            imports\n                                .add('umiSerializers', 'publicKey')\n                                .addAlias('umiSerializers', 'publicKey', 'publicKeySerializer');\n                            return seed;\n                        }\n                        const seedManifest = visit(seed.type, typeManifestVisitor);\n                        imports.mergeWith(seedManifest.serializerImports);\n                        const valueManifest = visit(seed.value, typeManifestVisitor);\n                        imports.mergeWith(valueManifest.valueImports);\n                        return { ...seed, typeManifest: seedManifest, valueManifest };\n                    });\n                    if (seeds.length > 0) {\n                        imports.add('umi', ['Pda']);\n                    }\n                    const hasVariableSeeds = pdaSeeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n\n                    return new RenderMap().add(\n                        `accounts/${camelCase(node.name)}.ts`,\n                        render('accountsPage.njk', {\n                            account: node,\n                            customData,\n                            discriminator: resolvedDiscriminator,\n                            gpaFields: resolvedGpaFields,\n                            hasVariableSeeds,\n                            imports: imports.toString(dependencyMap),\n                            program,\n                            seeds,\n                            typeManifest,\n                        }),\n                    );\n                },\n\n                visitDefinedType(node) {\n                    const pascalCaseName = pascalCase(node.name);\n                    const typeManifest = visit(node, typeManifestVisitor);\n                    const imports = new ImportMap()\n                        .mergeWithManifest(typeManifest)\n                        .add('umiSerializers', ['Serializer'])\n                        .remove('generatedTypes', [\n                            pascalCaseName,\n                            `${pascalCaseName}Args`,\n                            `get${pascalCaseName}Serializer`,\n                        ]);\n\n                    return new RenderMap().add(\n                        `types/${camelCase(node.name)}.ts`,\n                        render('definedTypesPage.njk', {\n                            definedType: node,\n                            imports: imports.toString({\n                                ...dependencyMap,\n                                generatedTypes: '.',\n                            }),\n                            isDataEnum: isNode(node.type, 'enumTypeNode') && isDataEnum(node.type),\n                            typeManifest,\n                        }),\n                    );\n                },\n\n                visitInstruction(node) {\n                    // Imports and interfaces.\n                    const interfaces = new ContextMap().add('programs');\n                    const imports = new ImportMap()\n                        .add('umi', ['Context', 'TransactionBuilder', 'transactionBuilder'])\n                        .add('shared', ['ResolvedAccount', 'ResolvedAccountsWithIndices', 'getAccountMetasAndSigners']);\n\n                    // Instruction helpers.\n                    const customData = customInstructionData.get(node.name);\n                    const linkedDataArgs = !!customData;\n                    const hasAccounts = node.accounts.length > 0;\n                    const hasData = linkedDataArgs || node.arguments.length > 0;\n                    const hasDataArgs =\n                        linkedDataArgs ||\n                        node.arguments.filter(field => field.defaultValueStrategy !== 'omitted').length > 0;\n                    const hasExtraArgs =\n                        (node.extraArguments ?? []).filter(field => field.defaultValueStrategy !== 'omitted').length >\n                        0;\n                    const hasAnyArgs = hasDataArgs || hasExtraArgs;\n                    const allArgumentsWithDefaultValue = [\n                        ...node.arguments.filter(a => a.defaultValue && !isNode(a.defaultValue, VALUE_NODES)),\n                        ...(node.extraArguments ?? []).filter(a => a.defaultValue),\n                    ];\n                    const hasArgDefaults = allArgumentsWithDefaultValue.length > 0;\n                    const hasArgResolvers = allArgumentsWithDefaultValue.some(a =>\n                        isNode(a.defaultValue, 'resolverValueNode'),\n                    );\n                    const hasAccountResolvers = node.accounts.some(a => isNode(a.defaultValue, 'resolverValueNode'));\n                    const byteDelta = node.byteDeltas?.[0] ?? undefined;\n                    const hasByteResolver = byteDelta && isNode(byteDelta.value, 'resolverValueNode');\n                    let remainingAccounts = node.remainingAccounts?.[0] ?? undefined;\n                    if (\n                        remainingAccounts &&\n                        isNode(remainingAccounts.value, 'argumentValueNode') &&\n                        getAllInstructionArguments(node).every(arg => arg.name !== remainingAccounts?.value.name)\n                    ) {\n                        remainingAccounts = undefined;\n                    }\n                    const hasRemainingAccountsResolver =\n                        remainingAccounts && isNode(remainingAccounts.value, 'resolverValueNode');\n                    const hasResolvers =\n                        hasArgResolvers || hasAccountResolvers || hasByteResolver || hasRemainingAccountsResolver;\n                    const hasResolvedArgs = hasDataArgs || hasArgDefaults || hasResolvers;\n                    if (hasResolvers) {\n                        interfaces.add(['eddsa', 'identity', 'payer']);\n                    }\n\n                    // canMergeAccountsAndArgs\n                    let canMergeAccountsAndArgs = false;\n                    if (!linkedDataArgs) {\n                        const accountsAndArgsConflicts = getMergeConflictsForInstructionAccountsAndArgs(node);\n                        if (accountsAndArgsConflicts.length > 0) {\n                            logWarn(\n                                `[JavaScript Umi] Accounts and args of instruction [${node.name}] have the following ` +\n                                    `conflicting attributes [${accountsAndArgsConflicts.join(', ')}]. ` +\n                                    `Thus, they could not be merged into a single input object. ` +\n                                    'You may want to rename the conflicting attributes.',\n                            );\n                        }\n                        canMergeAccountsAndArgs = accountsAndArgsConflicts.length === 0;\n                    }\n\n                    // Resolved inputs.\n                    let argObject = canMergeAccountsAndArgs ? 'input' : 'args';\n                    argObject = hasResolvedArgs ? 'resolvedArgs' : argObject;\n                    const resolvedInputs = visit(node, resolvedInstructionInputVisitor).map(\n                        (input: ResolvedInstructionInput) => {\n                            const renderedInput = renderInstructionDefaults(\n                                input,\n                                typeManifestVisitor,\n                                parseOptionalAccountStrategy(node.optionalAccountStrategy),\n                                argObject,\n                                getImportFrom,\n                            );\n                            imports.mergeWith(renderedInput.imports);\n                            interfaces.mergeWith(renderedInput.interfaces);\n                            return { ...input, render: renderedInput.render };\n                        },\n                    );\n                    const resolvedInputsWithDefaults = resolvedInputs.filter(\n                        input => input.defaultValue !== undefined && input.render !== '',\n                    );\n                    const argsWithDefaults = resolvedInputsWithDefaults\n                        .filter(isNodeFilter('instructionArgumentNode'))\n                        .map(input => input.name);\n\n                    // Accounts.\n                    const accounts = node.accounts.map(account => {\n                        const hasDefaultValue = !!account.defaultValue;\n                        const resolvedAccount = resolvedInputs.find(\n                            input => input.kind === 'instructionAccountNode' && input.name === account.name,\n                        ) as ResolvedInstructionAccount;\n                        return {\n                            ...resolvedAccount,\n                            hasDefaultValue,\n                            optionalSign: hasDefaultValue || account.isOptional ? '?' : '',\n                            type: getInstructionAccountType(resolvedAccount),\n                        };\n                    });\n                    imports.mergeWith(getInstructionAccountImports(accounts));\n\n                    // Data Args.\n                    const dataArgManifest = visit(node, typeManifestVisitor);\n                    if (linkedDataArgs || hasData) {\n                        imports.mergeWith(dataArgManifest.looseImports, dataArgManifest.serializerImports);\n                    }\n                    if (!linkedDataArgs) {\n                        imports.mergeWith(dataArgManifest.strictImports);\n                    }\n                    if (!linkedDataArgs && hasData) {\n                        imports.add('umiSerializers', ['Serializer']);\n                    }\n\n                    // Extra args.\n                    const extraArgStruct = definedTypeNode({\n                        name: `${node.name}InstructionExtra`,\n                        type: structTypeNodeFromInstructionArgumentNodes(node.extraArguments ?? []),\n                    });\n                    const extraArgManifest = visit(extraArgStruct, typeManifestVisitor);\n                    imports.mergeWith(extraArgManifest.looseImports);\n\n                    // Arg defaults.\n                    allArgumentsWithDefaultValue.forEach(argument => {\n                        if (isNode(argument.defaultValue, 'resolverValueNode')) {\n                            imports.add(getImportFrom(argument.defaultValue), camelCase(argument.defaultValue.name));\n                        }\n                    });\n                    if (argsWithDefaults.length > 0) {\n                        imports.add('shared', ['PickPartial']);\n                    }\n\n                    // Bytes created on chain.\n                    if (byteDelta && byteDelta.withHeader) {\n                        imports.add('umi', 'ACCOUNT_HEADER_SIZE');\n                    }\n                    if (byteDelta && isNode(byteDelta.value, 'accountLinkNode')) {\n                        const accountName = pascalCase(byteDelta.value.name);\n                        imports.add(getImportFrom(byteDelta.value), `get${accountName}Size`);\n                    } else if (byteDelta && isNode(byteDelta.value, 'resolverValueNode')) {\n                        imports.add(getImportFrom(byteDelta.value), camelCase(byteDelta.value.name));\n                    }\n\n                    // Remaining accounts.\n                    if (remainingAccounts && isNode(remainingAccounts.value, 'resolverValueNode')) {\n                        imports.add(getImportFrom(remainingAccounts.value), camelCase(remainingAccounts.value.name));\n                    }\n\n                    return new RenderMap().add(\n                        `instructions/${camelCase(node.name)}.ts`,\n                        render('instructionsPage.njk', {\n                            accounts,\n                            argsWithDefaults,\n                            byteDelta,\n                            canMergeAccountsAndArgs,\n                            customData,\n                            dataArgManifest,\n                            extraArgManifest,\n                            hasAccountResolvers,\n                            hasAccounts,\n                            hasAnyArgs,\n                            hasArgDefaults,\n                            hasArgResolvers,\n                            hasByteResolver,\n                            hasData,\n                            hasDataArgs,\n                            hasExtraArgs,\n                            hasRemainingAccountsResolver,\n                            hasResolvedArgs,\n                            hasResolvers,\n                            imports: imports.toString(dependencyMap),\n                            instruction: node,\n                            interfaces: interfaces.toString(),\n                            program,\n                            remainingAccounts,\n                            resolvedInputs,\n                            resolvedInputsWithDefaults,\n                        }),\n                    );\n                },\n\n                visitProgram(node, { self }) {\n                    program = node;\n                    const pascalCaseName = pascalCase(node.name);\n                    const customDataDefinedType = [\n                        ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),\n                        ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData),\n                    ];\n                    const renderMap = new RenderMap()\n                        .mergeWith(...node.accounts.map(a => visit(a, self)))\n                        .mergeWith(...node.definedTypes.map(t => visit(t, self)))\n                        .mergeWith(...customDataDefinedType.map(t => visit(t, self)))\n                        .mergeWith(\n                            ...getAllInstructionsWithSubs(node, {\n                                leavesOnly: !renderParentInstructions,\n                            }).map(ix => visit(ix, self)),\n                        )\n                        .add(\n                            `errors/${camelCase(node.name)}.ts`,\n                            render('errorsPage.njk', {\n                                errors: node.errors,\n                                imports: new ImportMap()\n                                    .add('umi', ['ProgramError', 'Program'])\n                                    .toString(dependencyMap),\n                                program: node,\n                            }),\n                        )\n                        .add(\n                            `programs/${camelCase(node.name)}.ts`,\n                            render('programsPage.njk', {\n                                imports: new ImportMap()\n                                    .add('umi', ['ClusterFilter', 'Context', 'Program', 'PublicKey'])\n                                    .add('errors', [\n                                        `get${pascalCaseName}ErrorFromCode`,\n                                        `get${pascalCaseName}ErrorFromName`,\n                                    ])\n                                    .toString(dependencyMap),\n                                program: node,\n                            }),\n                        );\n                    program = null;\n                    return renderMap;\n                },\n\n                visitRoot(node, { self }) {\n                    const isNotInternal = (n: { name: CamelCaseString }) => !internalNodes.includes(n.name);\n                    const programsToExport = getAllPrograms(node).filter(isNotInternal);\n                    const accountsToExport = getAllAccounts(node).filter(isNotInternal);\n                    const instructionsToExport = getAllInstructionsWithSubs(node, {\n                        leavesOnly: !renderParentInstructions,\n                    }).filter(isNotInternal);\n                    const definedTypesToExport = getAllDefinedTypes(node).filter(isNotInternal);\n                    const hasAnythingToExport =\n                        programsToExport.length > 0 ||\n                        accountsToExport.length > 0 ||\n                        instructionsToExport.length > 0 ||\n                        definedTypesToExport.length > 0;\n\n                    const ctx = {\n                        accountsToExport,\n                        definedTypesToExport,\n                        hasAnythingToExport,\n                        instructionsToExport,\n                        programsToExport,\n                        root: node,\n                    };\n\n                    const map = new RenderMap();\n                    if (hasAnythingToExport) {\n                        map.add('shared/index.ts', render('sharedPage.njk', ctx));\n                    }\n                    if (programsToExport.length > 0) {\n                        map.add('programs/index.ts', render('programsIndex.njk', ctx)).add(\n                            'errors/index.ts',\n                            render('errorsIndex.njk', ctx),\n                        );\n                    }\n                    if (accountsToExport.length > 0) {\n                        map.add('accounts/index.ts', render('accountsIndex.njk', ctx));\n                    }\n                    if (instructionsToExport.length > 0) {\n                        map.add('instructions/index.ts', render('instructionsIndex.njk', ctx));\n                    }\n                    if (definedTypesToExport.length > 0) {\n                        map.add('types/index.ts', render('definedTypesIndex.njk', ctx));\n                    }\n\n                    return map\n                        .add('index.ts', render('rootIndex.njk', ctx))\n                        .mergeWith(...getAllPrograms(node).map(p => visit(p, self)));\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","export type ContextInterface =\n    | 'downloader'\n    | 'eddsa'\n    | 'http'\n    | 'identity'\n    | 'payer'\n    | 'programs'\n    | 'rpc'\n    | 'transactions'\n    | 'uploader';\n\nexport class ContextMap {\n    protected readonly _interfaces: Set<ContextInterface> = new Set();\n\n    add(contextInterface: ContextInterface | ContextInterface[]): ContextMap {\n        if (Array.isArray(contextInterface)) {\n            contextInterface.forEach(i => this._interfaces.add(i));\n        } else {\n            this._interfaces.add(contextInterface);\n        }\n        return this;\n    }\n\n    remove(contextInterface: ContextInterface | ContextInterface[]): ContextMap {\n        if (Array.isArray(contextInterface)) {\n            contextInterface.forEach(i => this._interfaces.delete(i));\n        } else {\n            this._interfaces.delete(contextInterface);\n        }\n        return this;\n    }\n\n    mergeWith(...others: ContextMap[]): ContextMap {\n        others.forEach(other => this.add([...other._interfaces]));\n        return this;\n    }\n\n    isEmpty(): boolean {\n        return this._interfaces.size === 0;\n    }\n\n    toString(): string {\n        const contextInterfaces = [...this._interfaces]\n            .sort()\n            .map(i => `\"${i}\"`)\n            .join(' | ');\n        return `Pick<Context, ${contextInterfaces}>`;\n    }\n}\n","import { CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, CodamaError } from '@codama/errors';\nimport {\n    ArrayTypeNode,\n    camelCase,\n    CamelCaseString,\n    isInteger,\n    isNode,\n    isScalarEnum,\n    isUnsignedInteger,\n    NumberTypeNode,\n    parseDocs,\n    pascalCase,\n    REGISTERED_TYPE_NODE_KINDS,\n    REGISTERED_VALUE_NODE_KINDS,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    structTypeNodeFromInstructionArgumentNodes,\n    TypeNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\nimport { ImportMap } from './ImportMap';\nimport { getBytesFromBytesValueNode, GetImportFromFunction, jsDocblock, ParsedCustomDataOptions } from './utils';\n\nexport type TypeManifest = {\n    isEnum: boolean;\n    looseImports: ImportMap;\n    looseType: string;\n    serializer: string;\n    serializerImports: ImportMap;\n    strictImports: ImportMap;\n    strictType: string;\n    value: string;\n    valueImports: ImportMap;\n};\n\nfunction typeManifest(): TypeManifest {\n    return {\n        isEnum: false,\n        looseImports: new ImportMap(),\n        looseType: '',\n        serializer: '',\n        serializerImports: new ImportMap(),\n        strictImports: new ImportMap(),\n        strictType: '',\n        value: '',\n        valueImports: new ImportMap(),\n    };\n}\n\nexport function getTypeManifestVisitor(input: {\n    customAccountData: ParsedCustomDataOptions;\n    customInstructionData: ParsedCustomDataOptions;\n    getImportFrom: GetImportFromFunction;\n    linkables: LinkableDictionary;\n    nonScalarEnums: CamelCaseString[];\n    stack?: NodeStack;\n}) {\n    const { linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;\n    const stack = input.stack ?? new NodeStack();\n    let parentName: { loose: string; strict: string } | null = null;\n    let parentSize: NumberTypeNode | number | null = null;\n\n    return pipe(\n        staticVisitor(\n            () =>\n                ({\n                    isEnum: false,\n                    looseImports: new ImportMap(),\n                    looseType: '',\n                    serializer: '',\n                    serializerImports: new ImportMap(),\n                    strictImports: new ImportMap(),\n                    strictType: '',\n                    value: '',\n                    valueImports: new ImportMap(),\n                }) as TypeManifest,\n            {\n                keys: [\n                    ...REGISTERED_TYPE_NODE_KINDS,\n                    ...REGISTERED_VALUE_NODE_KINDS,\n                    'definedTypeLinkNode',\n                    'definedTypeNode',\n                    'accountNode',\n                    'instructionNode',\n                ],\n            },\n        ),\n        v =>\n            extendVisitor(v, {\n                visitAccount(account, { self }) {\n                    parentName = {\n                        loose: `${pascalCase(account.name)}AccountDataArgs`,\n                        strict: `${pascalCase(account.name)}AccountData`,\n                    };\n                    const link = customAccountData.get(account.name)?.linkNode;\n                    const manifest = link ? visit(link, self) : visit(account.data, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitAmountType(amountType, { self }) {\n                    const numberManifest = visit(amountType.number, self);\n                    const resolvedNode = resolveNestedTypeNode(amountType.number);\n                    if (!isUnsignedInteger(resolvedNode)) {\n                        throw new Error(\n                            `Amount wrappers can only be applied to unsigned ` +\n                                `integer types. Got format [${resolvedNode.format}].`,\n                        );\n                    }\n                    const { unit, decimals } = amountType;\n                    const idAndDecimals = `'${unit ?? 'Unknown'}', ${decimals}`;\n                    const isSolAmount = unit === 'SOL' && decimals === 9;\n                    const amountTypeString = isSolAmount ? 'SolAmount' : `Amount<${idAndDecimals}>`;\n                    const amountImport = isSolAmount ? 'SolAmount' : 'Amount';\n                    numberManifest.strictImports.add('umi', amountImport);\n                    numberManifest.looseImports.add('umi', amountImport);\n                    numberManifest.serializerImports.add('umi', 'mapAmountSerializer');\n                    return {\n                        ...numberManifest,\n                        looseType: amountTypeString,\n                        serializer: `mapAmountSerializer(${numberManifest.serializer}, ${idAndDecimals})`,\n                        strictType: amountTypeString,\n                    };\n                },\n\n                visitArrayType(arrayType, { self }) {\n                    const childManifest = visit(arrayType.item, self);\n                    childManifest.serializerImports.add('umiSerializers', 'array');\n                    const sizeOption = getArrayLikeSizeOption(arrayType.count, childManifest, self);\n                    const options = sizeOption ? `, { ${sizeOption} }` : '';\n                    return {\n                        ...childManifest,\n                        looseType: `Array<${childManifest.looseType}>`,\n                        serializer: `array(${childManifest.serializer + options})`,\n                        strictType: `Array<${childManifest.strictType}>`,\n                    };\n                },\n\n                visitArrayValue(node, { self }) {\n                    const list = node.items.map(value => visit(value, self));\n                    return {\n                        ...typeManifest(),\n                        value: `[${list.map(c => c.value).join(', ')}]`,\n                        valueImports: new ImportMap().mergeWith(...list.map(c => c.valueImports)),\n                    };\n                },\n\n                visitBooleanType(booleanType, { self }) {\n                    const looseImports = new ImportMap();\n                    const strictImports = new ImportMap();\n                    const serializerImports = new ImportMap().add('umiSerializers', 'bool');\n                    let sizeSerializer = '';\n                    const resolvedSize = resolveNestedTypeNode(booleanType.size);\n                    if (resolvedSize.format !== 'u8' || resolvedSize.endian !== 'le') {\n                        const size = visit(booleanType.size, self);\n                        looseImports.mergeWith(size.looseImports);\n                        strictImports.mergeWith(size.strictImports);\n                        serializerImports.mergeWith(size.serializerImports);\n                        sizeSerializer = `{ size: ${size.serializer} }`;\n                    }\n\n                    return {\n                        isEnum: false,\n                        looseImports,\n                        looseType: 'boolean',\n                        serializer: `bool(${sizeSerializer})`,\n                        serializerImports,\n                        strictImports,\n                        strictType: 'boolean',\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitBooleanValue(node) {\n                    return {\n                        ...typeManifest(),\n                        value: JSON.stringify(node.boolean),\n                    };\n                },\n\n                visitBytesType(_bytesType, { self }) {\n                    const strictImports = new ImportMap();\n                    const looseImports = new ImportMap();\n                    const serializerImports = new ImportMap().add('umiSerializers', 'bytes');\n                    const options: string[] = [];\n\n                    // Size option.\n                    if (typeof parentSize === 'number') {\n                        options.push(`size: ${parentSize}`);\n                    } else if (parentSize) {\n                        const prefix = visit(parentSize, self);\n                        strictImports.mergeWith(prefix.strictImports);\n                        looseImports.mergeWith(prefix.looseImports);\n                        serializerImports.mergeWith(prefix.serializerImports);\n                        options.push(`size: ${prefix.serializer}`);\n                    }\n\n                    const optionsAsString = options.length > 0 ? `{ ${options.join(', ')} }` : '';\n\n                    return {\n                        isEnum: false,\n                        looseImports,\n                        looseType: 'Uint8Array',\n                        serializer: `bytes(${optionsAsString})`,\n                        serializerImports,\n                        strictImports,\n                        strictType: 'Uint8Array',\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitBytesValue(node) {\n                    const bytes = getBytesFromBytesValueNode(node);\n                    return {\n                        ...typeManifest(),\n                        value: `new Uint8Array([${Array.from(bytes).join(', ')}])`,\n                    };\n                },\n\n                visitConstantValue(node, { self }) {\n                    if (isNode(node.type, 'bytesTypeNode') && isNode(node.value, 'bytesValueNode')) {\n                        return visit(node.value, self);\n                    }\n                    const imports = new ImportMap();\n                    const value = visit(node.value, self);\n                    imports.mergeWith(value.valueImports);\n                    const type = visit(node.type, self);\n                    imports.mergeWith(type.serializerImports);\n                    return {\n                        ...typeManifest(),\n                        value: `${type.serializer}.serialize(${value.value})`,\n                        valueImports: imports,\n                    };\n                },\n\n                visitDateTimeType(dateTimeType, { self }) {\n                    const numberManifest = visit(dateTimeType.number, self);\n                    const dateTimeNumber = resolveNestedTypeNode(dateTimeType.number);\n                    if (!isInteger(dateTimeNumber)) {\n                        throw new Error(\n                            `DateTime wrappers can only be applied to integer ` +\n                                `types. Got format [${dateTimeNumber.format}].`,\n                        );\n                    }\n                    numberManifest.strictImports.add('umi', 'DateTime');\n                    numberManifest.looseImports.add('umi', 'DateTimeInput');\n                    numberManifest.serializerImports.add('umi', 'mapDateTimeSerializer');\n                    return {\n                        ...numberManifest,\n                        looseType: `DateTimeInput`,\n                        serializer: `mapDateTimeSerializer(${numberManifest.serializer})`,\n                        strictType: `DateTime`,\n                    };\n                },\n\n                visitDefinedType(definedType, { self }) {\n                    parentName = {\n                        loose: `${pascalCase(definedType.name)}Args`,\n                        strict: pascalCase(definedType.name),\n                    };\n                    const manifest = visit(definedType.type, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const pascalCaseDefinedType = pascalCase(node.name);\n                    const serializerName = `get${pascalCaseDefinedType}Serializer`;\n                    const importFrom = getImportFrom(node);\n\n                    return {\n                        isEnum: false,\n                        looseImports: new ImportMap().add(importFrom, `${pascalCaseDefinedType}Args`),\n                        looseType: `${pascalCaseDefinedType}Args`,\n                        serializer: `${serializerName}()`,\n                        serializerImports: new ImportMap().add(importFrom, serializerName),\n                        strictImports: new ImportMap().add(importFrom, pascalCaseDefinedType),\n                        strictType: pascalCaseDefinedType,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitEnumEmptyVariantType(enumEmptyVariantType) {\n                    const name = pascalCase(enumEmptyVariantType.name);\n                    const kindAttribute = `__kind: \"${name}\"`;\n                    return {\n                        isEnum: false,\n                        looseImports: new ImportMap(),\n                        looseType: `{ ${kindAttribute} }`,\n                        serializer: `['${name}', unit()]`,\n                        serializerImports: new ImportMap().add('umiSerializers', 'unit'),\n                        strictImports: new ImportMap(),\n                        strictType: `{ ${kindAttribute} }`,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitEnumStructVariantType(enumStructVariantType, { self }) {\n                    const name = pascalCase(enumStructVariantType.name);\n                    const kindAttribute = `__kind: \"${name}\"`;\n                    const type = visit(enumStructVariantType.struct, self);\n                    return {\n                        ...type,\n                        looseType: `{ ${kindAttribute},${type.looseType.slice(1, -1)}}`,\n                        serializer: `['${name}', ${type.serializer}]`,\n                        strictType: `{ ${kindAttribute},${type.strictType.slice(1, -1)}}`,\n                    };\n                },\n\n                visitEnumTupleVariantType(enumTupleVariantType, { self }) {\n                    const name = pascalCase(enumTupleVariantType.name);\n                    const kindAttribute = `__kind: \"${name}\"`;\n                    const struct = structTypeNode([\n                        structFieldTypeNode({\n                            name: 'fields',\n                            type: enumTupleVariantType.tuple,\n                        }),\n                    ]);\n                    const type = visit(struct, self);\n                    return {\n                        ...type,\n                        looseType: `{ ${kindAttribute},${type.looseType.slice(1, -1)}}`,\n                        serializer: `['${name}', ${type.serializer}]`,\n                        strictType: `{ ${kindAttribute},${type.strictType.slice(1, -1)}}`,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitEnumType(enumType, { self }) {\n                    const strictImports = new ImportMap();\n                    const looseImports = new ImportMap();\n                    const serializerImports = new ImportMap();\n\n                    const variantNames = enumType.variants.map(variant => pascalCase(variant.name));\n                    const currentParentName = { ...parentName };\n                    parentName = null;\n                    const options: string[] = [];\n\n                    const enumSize = resolveNestedTypeNode(enumType.size);\n                    if (enumSize.format !== 'u8' || enumSize.endian !== 'le') {\n                        const sizeManifest = visit(enumType.size, self);\n                        strictImports.mergeWith(sizeManifest.strictImports);\n                        looseImports.mergeWith(sizeManifest.looseImports);\n                        serializerImports.mergeWith(sizeManifest.serializerImports);\n                        options.push(`size: ${sizeManifest.serializer}`);\n                    }\n\n                    if (isScalarEnum(enumType)) {\n                        if (currentParentName === null) {\n                            throw new Error(\n                                'Scalar enums cannot be inlined and must be introduced ' +\n                                    'via a defined type. Ensure you are not inlining a ' +\n                                    'defined type that is a scalar enum through a visitor.',\n                            );\n                        }\n                        options.push(`description: '${currentParentName.strict}'`);\n                        const optionsAsString = options.length > 0 ? `, { ${options.join(', ')} }` : '';\n                        return {\n                            isEnum: true,\n                            looseImports,\n                            looseType: `{ ${variantNames.join(', ')} }`,\n                            serializer:\n                                `scalarEnum<${currentParentName.strict}>` +\n                                `(${currentParentName.strict + optionsAsString})`,\n                            serializerImports: serializerImports.add('umiSerializers', 'scalarEnum'),\n                            strictImports,\n                            strictType: `{ ${variantNames.join(', ')} }`,\n                            value: '',\n                            valueImports: new ImportMap(),\n                        };\n                    }\n\n                    const variants = enumType.variants.map(variant => {\n                        const variantName = pascalCase(variant.name);\n                        parentName = currentParentName\n                            ? {\n                                  loose: `GetDataEnumKindContent<${currentParentName.loose}, '${variantName}'>`,\n                                  strict: `GetDataEnumKindContent<${currentParentName.strict}, '${variantName}'>`,\n                              }\n                            : null;\n                        const variantManifest = visit(variant, self);\n                        parentName = null;\n                        return variantManifest;\n                    });\n\n                    const mergedManifest = mergeManifests(variants);\n                    mergedManifest.strictImports.mergeWith(strictImports);\n                    mergedManifest.looseImports.mergeWith(looseImports);\n                    mergedManifest.serializerImports.mergeWith(serializerImports);\n                    const variantSerializers = variants.map(variant => variant.serializer).join(', ');\n                    const serializerTypeParams = currentParentName ? currentParentName.strict : 'any';\n                    if (currentParentName?.strict) {\n                        options.push(`description: '${pascalCase(currentParentName.strict)}'`);\n                    }\n                    const optionsAsString = options.length > 0 ? `, { ${options.join(', ')} }` : '';\n\n                    return {\n                        ...mergedManifest,\n                        looseType: variants.map(variant => variant.looseType).join(' | '),\n                        serializer: `dataEnum<${serializerTypeParams}>` + `([${variantSerializers}]${optionsAsString})`,\n                        serializerImports: mergedManifest.serializerImports.add('umiSerializers', [\n                            'GetDataEnumKindContent',\n                            'GetDataEnumKind',\n                            'dataEnum',\n                        ]),\n                        strictType: variants.map(variant => variant.strictType).join(' | '),\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitEnumValue(node, { self }) {\n                    const imports = new ImportMap();\n                    const enumName = pascalCase(node.enum.name);\n                    const variantName = pascalCase(node.variant);\n                    const importFrom = getImportFrom(node.enum);\n\n                    const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;\n                    const isScalar =\n                        enumNode && isNode(enumNode, 'enumTypeNode')\n                            ? isScalarEnum(enumNode)\n                            : !nonScalarEnums.includes(node.enum.name);\n\n                    if (!node.value && isScalar) {\n                        return {\n                            ...typeManifest(),\n                            value: `${enumName}.${variantName}`,\n                            valueImports: imports.add(importFrom, enumName),\n                        };\n                    }\n\n                    const enumFn = camelCase(node.enum.name);\n                    imports.add(importFrom, enumFn);\n\n                    if (!node.value) {\n                        return {\n                            ...typeManifest(),\n                            value: `${enumFn}('${variantName}')`,\n                            valueImports: imports,\n                        };\n                    }\n\n                    const enumValue = visit(node.value, self);\n                    const fields = enumValue.value;\n                    imports.mergeWith(enumValue.valueImports);\n\n                    return {\n                        ...typeManifest(),\n                        value: `${enumFn}('${variantName}', ${fields})`,\n                        valueImports: imports,\n                    };\n                },\n\n                visitFixedSizeType(fixedSizeType, { self }) {\n                    parentSize = fixedSizeType.size;\n                    const manifest = visit(fixedSizeType.type, self);\n                    parentSize = null;\n                    return manifest;\n                },\n\n                visitInstruction(instruction, { self }) {\n                    parentName = {\n                        loose: `${pascalCase(instruction.name)}InstructionDataArgs`,\n                        strict: `${pascalCase(instruction.name)}InstructionData`,\n                    };\n                    const link = customInstructionData.get(instruction.name)?.linkNode;\n                    const struct = structTypeNodeFromInstructionArgumentNodes(instruction.arguments);\n                    const manifest = link ? visit(link, self) : visit(struct, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitMapEntryValue(node, { self }) {\n                    const mapKey = visit(node.key, self);\n                    const mapValue = visit(node.value, self);\n                    return {\n                        ...typeManifest(),\n                        imports: mapKey.valueImports.mergeWith(mapValue.valueImports),\n                        render: `[${mapKey.value}, ${mapValue.value}]`,\n                    };\n                },\n\n                visitMapType(mapType, { self }) {\n                    const key = visit(mapType.key, self);\n                    const value = visit(mapType.value, self);\n                    const mergedManifest = mergeManifests([key, value]);\n                    mergedManifest.serializerImports.add('umiSerializers', 'map');\n                    const sizeOption = getArrayLikeSizeOption(mapType.count, mergedManifest, self);\n                    const options = sizeOption ? `, { ${sizeOption} }` : '';\n                    return {\n                        ...mergedManifest,\n                        looseType: `Map<${key.looseType}, ${value.looseType}>`,\n                        serializer: `map(${key.serializer}, ${value.serializer}${options})`,\n                        strictType: `Map<${key.strictType}, ${value.strictType}>`,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitMapValue(node, { self }) {\n                    const map = node.entries.map(entry => visit(entry, self));\n                    return {\n                        ...typeManifest(),\n                        value: `new Map([${map.map(c => c.value).join(', ')}])`,\n                        valueImports: new ImportMap().mergeWith(...map.map(c => c.valueImports)),\n                    };\n                },\n\n                visitNoneValue() {\n                    return {\n                        ...typeManifest(),\n                        value: 'none()',\n                        valueImports: new ImportMap().add('umi', 'none'),\n                    };\n                },\n\n                visitNumberType(numberType) {\n                    const isBigNumber = ['u64', 'u128', 'i64', 'i128'].includes(numberType.format);\n                    const serializerImports = new ImportMap().add('umiSerializers', numberType.format);\n                    let endianness = '';\n                    if (numberType.endian === 'be') {\n                        serializerImports.add('umiSerializers', 'Endian');\n                        endianness = '{ endian: Endian.Big }';\n                    }\n                    return {\n                        isEnum: false,\n                        looseImports: new ImportMap(),\n                        looseType: isBigNumber ? 'number | bigint' : 'number',\n                        serializer: `${numberType.format}(${endianness})`,\n                        serializerImports,\n                        strictImports: new ImportMap(),\n                        strictType: isBigNumber ? 'bigint' : 'number',\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitNumberValue(node) {\n                    return {\n                        ...typeManifest(),\n                        value: JSON.stringify(node.number),\n                    };\n                },\n\n                visitOptionType(optionType, { self }) {\n                    const childManifest = visit(optionType.item, self);\n                    childManifest.strictImports.add('umi', 'Option');\n                    childManifest.looseImports.add('umi', 'OptionOrNullable');\n                    childManifest.serializerImports.add('umiSerializers', 'option');\n                    const options: string[] = [];\n\n                    // Prefix option.\n                    const optionPrefix = resolveNestedTypeNode(optionType.prefix);\n                    if (optionPrefix.format !== 'u8' || optionPrefix.endian !== 'le') {\n                        const prefixManifest = visit(optionType.prefix, self);\n                        childManifest.strictImports.mergeWith(prefixManifest.strictImports);\n                        childManifest.looseImports.mergeWith(prefixManifest.looseImports);\n                        childManifest.serializerImports.mergeWith(prefixManifest.serializerImports);\n                        options.push(`prefix: ${prefixManifest.serializer}`);\n                    }\n\n                    // Fixed option.\n                    if (optionType.fixed) {\n                        options.push(`fixed: true`);\n                    }\n\n                    const optionsAsString = options.length > 0 ? `, { ${options.join(', ')} }` : '';\n\n                    return {\n                        ...childManifest,\n                        looseType: `OptionOrNullable<${childManifest.looseType}>`,\n                        serializer: `option(${childManifest.serializer}${optionsAsString})`,\n                        strictType: `Option<${childManifest.strictType}>`,\n                    };\n                },\n\n                visitPublicKeyType() {\n                    const imports = new ImportMap().add('umi', 'PublicKey');\n                    return {\n                        isEnum: false,\n                        looseImports: imports,\n                        looseType: 'PublicKey',\n                        serializer: `publicKeySerializer()`,\n                        serializerImports: new ImportMap()\n                            .add('umiSerializers', 'publicKey')\n                            .addAlias('umiSerializers', 'publicKey', 'publicKeySerializer'),\n                        strictImports: imports,\n                        strictType: 'PublicKey',\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitPublicKeyValue(node) {\n                    return {\n                        ...typeManifest(),\n                        value: `publicKey(\"${node.publicKey}\")`,\n                        valueImports: new ImportMap().add('umi', 'publicKey'),\n                    };\n                },\n\n                visitRemainderOptionType(node) {\n                    throw new CodamaError(CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });\n                },\n\n                visitSetType(setType, { self }) {\n                    const childManifest = visit(setType.item, self);\n                    childManifest.serializerImports.add('umiSerializers', 'set');\n                    const sizeOption = getArrayLikeSizeOption(setType.count, childManifest, self);\n                    const options = sizeOption ? `, { ${sizeOption} }` : '';\n                    return {\n                        ...childManifest,\n                        looseType: `Set<${childManifest.looseType}>`,\n                        serializer: `set(${childManifest.serializer + options})`,\n                        strictType: `Set<${childManifest.strictType}>`,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitSetValue(node, { self }) {\n                    const set = node.items.map(value => visit(value, self));\n                    return {\n                        ...typeManifest(),\n                        value: `new Set([${set.map(c => c.value).join(', ')}])`,\n                        valueImports: new ImportMap().mergeWith(...set.map(c => c.valueImports)),\n                    };\n                },\n\n                visitSizePrefixType(sizePrefixType, { self }) {\n                    parentSize = resolveNestedTypeNode(sizePrefixType.prefix);\n                    const manifest = visit(sizePrefixType.type, self);\n                    parentSize = null;\n                    return manifest;\n                },\n\n                visitSolAmountType(solAmountType, { self }) {\n                    const numberManifest = visit(solAmountType.number, self);\n                    const nestedNumber = resolveNestedTypeNode(solAmountType.number);\n                    if (!isUnsignedInteger(nestedNumber)) {\n                        throw new Error(\n                            `Amount wrappers can only be applied to unsigned ` +\n                                `integer types. Got format [${nestedNumber.format}].`,\n                        );\n                    }\n                    const idAndDecimals = `'SOL', 9`;\n                    numberManifest.strictImports.add('umi', 'SolAmount');\n                    numberManifest.looseImports.add('umi', 'SolAmount');\n                    numberManifest.serializerImports.add('umi', 'mapAmountSerializer');\n                    return {\n                        ...numberManifest,\n                        looseType: 'SolAmount',\n                        serializer: `mapAmountSerializer(${numberManifest.serializer}, ${idAndDecimals})`,\n                        strictType: 'SolAmount',\n                    };\n                },\n\n                visitSomeValue(node, { self }) {\n                    const child = visit(node.value, self);\n                    return {\n                        ...typeManifest(),\n                        value: `some(${child.value})`,\n                        valueImports: child.valueImports.add('umi', 'some'),\n                    };\n                },\n\n                visitStringType(stringType, { self }) {\n                    const looseImports = new ImportMap();\n                    const strictImports = new ImportMap();\n                    const serializerImports = new ImportMap().add('umiSerializers', 'string');\n                    const options: string[] = [];\n\n                    // Encoding option.\n                    if (stringType.encoding !== 'utf8') {\n                        looseImports.add('umiSerializers', stringType.encoding);\n                        strictImports.add('umiSerializers', stringType.encoding);\n                        options.push(`encoding: ${stringType.encoding}`);\n                    }\n\n                    // Size option.\n                    if (!parentSize) {\n                        options.push(`size: 'variable'`);\n                    } else if (typeof parentSize === 'number') {\n                        options.push(`size: ${parentSize}`);\n                    } else if (parentSize.format !== 'u32' || parentSize.endian !== 'le') {\n                        const prefix = visit(parentSize, self);\n                        looseImports.mergeWith(prefix.looseImports);\n                        strictImports.mergeWith(prefix.strictImports);\n                        serializerImports.mergeWith(prefix.serializerImports);\n                        options.push(`size: ${prefix.serializer}`);\n                    }\n\n                    const optionsAsString = options.length > 0 ? `{ ${options.join(', ')} }` : '';\n\n                    return {\n                        isEnum: false,\n                        looseImports,\n                        looseType: 'string',\n                        serializer: `string(${optionsAsString})`,\n                        serializerImports,\n                        strictImports,\n                        strictType: 'string',\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n                },\n\n                visitStringValue(node) {\n                    return {\n                        ...typeManifest(),\n                        value: JSON.stringify(node.string),\n                    };\n                },\n\n                visitStructFieldType(structFieldType, { self }) {\n                    const name = camelCase(structFieldType.name);\n                    const fieldChild = visit(structFieldType.type, self);\n                    const structFieldDocs = parseDocs(structFieldType.docs);\n                    const docblock = structFieldDocs.length > 0 ? `\\n${jsDocblock(structFieldDocs)}` : '';\n                    const baseField = {\n                        ...fieldChild,\n                        looseType: `${docblock}${name}: ${fieldChild.looseType}; `,\n                        serializer: `['${name}', ${fieldChild.serializer}]`,\n                        strictType: `${docblock}${name}: ${fieldChild.strictType}; `,\n                    };\n                    if (!structFieldType.defaultValue) {\n                        return baseField;\n                    }\n                    if (structFieldType.defaultValueStrategy !== 'omitted') {\n                        return {\n                            ...baseField,\n                            looseType: `${docblock}${name}?: ${fieldChild.looseType}; `,\n                        };\n                    }\n                    return {\n                        ...baseField,\n                        looseImports: new ImportMap(),\n                        looseType: '',\n                    };\n                },\n\n                visitStructFieldValue(node, { self }) {\n                    const structValue = visit(node.value, self);\n                    return {\n                        ...structValue,\n                        value: `${node.name}: ${structValue.value}`,\n                    };\n                },\n\n                visitStructType(structType, { self }) {\n                    const currentParentName = parentName;\n                    parentName = null;\n\n                    const fields = structType.fields.map(field => visit(field, self));\n                    const mergedManifest = mergeManifests(fields);\n                    mergedManifest.serializerImports.add('umiSerializers', 'struct');\n                    const fieldSerializers = fields.map(field => field.serializer).join(', ');\n                    const structDescription =\n                        currentParentName?.strict && !currentParentName.strict.match(/['\"<>]/)\n                            ? `, { description: '${pascalCase(currentParentName.strict)}' }`\n                            : '';\n                    const serializerTypeParams = currentParentName ? currentParentName.strict : 'any';\n                    const baseManifest = {\n                        ...mergedManifest,\n                        looseType: `{ ${fields.map(field => field.looseType).join('')} }`,\n                        serializer: `struct<${serializerTypeParams}>` + `([${fieldSerializers}]${structDescription})`,\n                        strictType: `{ ${fields.map(field => field.strictType).join('')} }`,\n                        value: '',\n                        valueImports: new ImportMap(),\n                    };\n\n                    const optionalFields = structType.fields.filter(f => !!f.defaultValue);\n                    if (optionalFields.length === 0) {\n                        return baseManifest;\n                    }\n\n                    const defaultValues = optionalFields\n                        .map(f => {\n                            const key = camelCase(f.name);\n                            const defaultValue = f.defaultValue as NonNullable<typeof f.defaultValue>;\n                            const { value: renderedValue, valueImports } = visit(defaultValue, self);\n                            baseManifest.serializerImports.mergeWith(valueImports);\n                            if (f.defaultValueStrategy === 'omitted') {\n                                return `${key}: ${renderedValue}`;\n                            }\n                            return `${key}: value.${key} ?? ${renderedValue}`;\n                        })\n                        .join(', ');\n                    const mapSerializerTypeParams = currentParentName\n                        ? `${currentParentName.loose}, any, ${currentParentName.strict}`\n                        : 'any, any, any';\n                    const mappedSerializer =\n                        `mapSerializer<${mapSerializerTypeParams}>(` +\n                        `${baseManifest.serializer}, ` +\n                        `(value) => ({ ...value, ${defaultValues} }) ` +\n                        `)`;\n                    baseManifest.serializerImports.add('umiSerializers', 'mapSerializer');\n                    return { ...baseManifest, serializer: mappedSerializer };\n                },\n\n                visitStructValue(node, { self }) {\n                    const struct = node.fields.map(field => visit(field, self));\n                    return {\n                        ...typeManifest(),\n                        value: `{ ${struct.map(c => c.value).join(', ')} }`,\n                        valueImports: new ImportMap().mergeWith(...struct.map(c => c.valueImports)),\n                    };\n                },\n\n                visitTupleType(tupleType, { self }) {\n                    const items = tupleType.items.map(item => visit(item, self));\n                    const mergedManifest = mergeManifests(items);\n                    mergedManifest.serializerImports.add('umiSerializers', 'tuple');\n                    const itemSerializers = items.map(child => child.serializer).join(', ');\n                    return {\n                        ...mergedManifest,\n                        looseType: `[${items.map(item => item.looseType).join(', ')}]`,\n                        serializer: `tuple([${itemSerializers}])`,\n                        strictType: `[${items.map(item => item.strictType).join(', ')}]`,\n                        value: '',\n                    };\n                },\n\n                visitTupleValue(node, { self }) {\n                    const list = node.items.map(value => visit(value, self));\n                    return {\n                        ...typeManifest(),\n                        value: `[${list.map(c => c.value).join(', ')}]`,\n                        valueImports: new ImportMap().mergeWith(...list.map(c => c.valueImports)),\n                    };\n                },\n\n                visitZeroableOptionType(node) {\n                    throw new CodamaError(CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n\nfunction mergeManifests(\n    manifests: TypeManifest[],\n): Pick<TypeManifest, 'isEnum' | 'looseImports' | 'serializerImports' | 'strictImports' | 'valueImports'> {\n    return {\n        isEnum: false,\n        looseImports: new ImportMap().mergeWith(...manifests.map(td => td.looseImports)),\n        serializerImports: new ImportMap().mergeWith(...manifests.map(td => td.serializerImports)),\n        strictImports: new ImportMap().mergeWith(...manifests.map(td => td.strictImports)),\n        valueImports: new ImportMap().mergeWith(...manifests.map(td => td.valueImports)),\n    };\n}\n\nfunction getArrayLikeSizeOption(\n    count: ArrayTypeNode['count'],\n    manifest: Pick<TypeManifest, 'looseImports' | 'serializerImports' | 'strictImports'>,\n    self: Visitor<TypeManifest, TypeNode['kind']>,\n): string | null {\n    if (isNode(count, 'fixedCountNode')) return `size: ${count.value}`;\n    if (isNode(count, 'remainderCountNode')) return `size: 'remainder'`;\n\n    const prefixManifest = visit(count.prefix, self);\n    if (prefixManifest.serializer === 'u32()') return null;\n\n    manifest.strictImports.mergeWith(prefixManifest.strictImports);\n    manifest.looseImports.mergeWith(prefixManifest.looseImports);\n    manifest.serializerImports.mergeWith(prefixManifest.serializerImports);\n    return `size: ${prefixManifest.serializer}`;\n}\n","import { BytesValueNode } from '@codama/nodes';\nimport { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport function getBytesFromBytesValueNode(node: BytesValueNode): Uint8Array {\n    switch (node.encoding) {\n        case 'utf8':\n            return getUtf8Encoder().encode(node.data) as Uint8Array;\n        case 'base16':\n            return getBase16Encoder().encode(node.data) as Uint8Array;\n        case 'base58':\n            return getBase58Encoder().encode(node.data) as Uint8Array;\n        case 'base64':\n        default:\n            return getBase64Encoder().encode(node.data) as Uint8Array;\n    }\n}\n","import {\n    AccountNode,\n    camelCase,\n    CamelCaseString,\n    DefinedTypeLinkNode,\n    definedTypeLinkNode,\n    DefinedTypeNode,\n    definedTypeNode,\n    InstructionNode,\n    isNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\n\nexport type CustomDataOptions =\n    | string\n    | {\n          extract?: boolean;\n          extractAs?: string;\n          importAs?: string;\n          importFrom?: string;\n          name: string;\n      };\n\nexport type ParsedCustomDataOptions = Map<\n    CamelCaseString,\n    {\n        extract: boolean;\n        extractAs: CamelCaseString;\n        importAs: CamelCaseString;\n        importFrom: string;\n        linkNode: DefinedTypeLinkNode;\n    }\n>;\n\nexport const parseCustomDataOptions = (\n    customDataOptions: CustomDataOptions[],\n    defaultSuffix: string,\n): ParsedCustomDataOptions =>\n    new Map(\n        customDataOptions.map(o => {\n            const options = typeof o === 'string' ? { name: o } : o;\n            const importAs = camelCase(options.importAs ?? `${options.name}${defaultSuffix}`);\n            const importFrom = options.importFrom ?? 'hooked';\n            return [\n                camelCase(options.name),\n                {\n                    extract: options.extract ?? false,\n                    extractAs: options.extractAs ? camelCase(options.extractAs) : importAs,\n                    importAs,\n                    importFrom,\n                    linkNode: definedTypeLinkNode(importAs),\n                },\n            ];\n        }),\n    );\n\nexport const getDefinedTypeNodesToExtract = (\n    nodes: AccountNode[] | InstructionNode[],\n    parsedCustomDataOptions: ParsedCustomDataOptions,\n): DefinedTypeNode[] =>\n    nodes.flatMap(node => {\n        const options = parsedCustomDataOptions.get(node.name);\n        if (!options || !options.extract) return [];\n\n        if (isNode(node, 'accountNode')) {\n            return [definedTypeNode({ name: options.extractAs, type: { ...node.data } })];\n        }\n\n        return [\n            definedTypeNode({\n                name: options.extractAs,\n                type: structTypeNodeFromInstructionArgumentNodes(node.arguments),\n            }),\n        ];\n    });\n","import { type AccountNode, type RegisteredTypeNode, resolveNestedTypeNode, type TypeNode } from '@codama/nodes';\nimport { visit, Visitor } from '@codama/visitors-core';\n\nexport type GpaField = {\n    name: string;\n    offset: number | null;\n    type: TypeNode;\n};\n\nexport function getGpaFieldsFromAccount(\n    node: AccountNode,\n    sizeVisitor: Visitor<number | null, RegisteredTypeNode['kind'] | 'definedTypeLinkNode'>,\n): GpaField[] {\n    let offset: number | null = 0;\n    const struct = resolveNestedTypeNode(node.data);\n    return struct.fields.map((field): GpaField => {\n        const fieldOffset = offset;\n        if (offset !== null) {\n            const newOffset = visit(field.type, sizeVisitor);\n            offset = newOffset !== null ? offset + newOffset : null;\n        }\n        return { name: field.name, offset: fieldOffset, type: field.type };\n    });\n}\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport {\n    AccountLinkNode,\n    DefinedTypeLinkNode,\n    InstructionLinkNode,\n    PdaLinkNode,\n    ProgramLinkNode,\n    ResolverValueNode,\n} from '@codama/nodes';\n\nimport { ParsedCustomDataOptions } from './customData';\n\nexport type LinkOverrides = {\n    accounts?: Record<string, string>;\n    definedTypes?: Record<string, string>;\n    instructions?: Record<string, string>;\n    pdas?: Record<string, string>;\n    programs?: Record<string, string>;\n    resolvers?: Record<string, string>;\n};\n\ntype OverridableNodes =\n    | AccountLinkNode\n    | DefinedTypeLinkNode\n    | InstructionLinkNode\n    | PdaLinkNode\n    | ProgramLinkNode\n    | ResolverValueNode;\n\nexport type GetImportFromFunction = (node: OverridableNodes, fallback?: string) => string;\n\nexport function getImportFromFactory(\n    overrides: LinkOverrides,\n    customAccountData: ParsedCustomDataOptions,\n    customInstructionData: ParsedCustomDataOptions,\n): GetImportFromFunction {\n    const customDataOverrides = Object.fromEntries(\n        [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [\n            importAs,\n            importFrom,\n        ]),\n    );\n    const linkOverrides = {\n        accounts: overrides.accounts ?? {},\n        definedTypes: { ...customDataOverrides, ...overrides.definedTypes },\n        instructions: overrides.instructions ?? {},\n        pdas: overrides.pdas ?? {},\n        programs: overrides.programs ?? {},\n        resolvers: overrides.resolvers ?? {},\n    };\n\n    return (node: OverridableNodes) => {\n        const kind = node.kind;\n        switch (kind) {\n            case 'accountLinkNode':\n                return linkOverrides.accounts[node.name] ?? 'generatedAccounts';\n            case 'definedTypeLinkNode':\n                return linkOverrides.definedTypes[node.name] ?? 'generatedTypes';\n            case 'instructionLinkNode':\n                return linkOverrides.instructions[node.name] ?? 'generatedInstructions';\n            case 'pdaLinkNode':\n                return linkOverrides.pdas[node.name] ?? 'generatedAccounts';\n            case 'programLinkNode':\n                return linkOverrides.programs[node.name] ?? 'generatedPrograms';\n            case 'resolverValueNode':\n                return linkOverrides.resolvers[node.name] ?? 'hooked';\n            default:\n                throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n                    expectedKinds: [\n                        'AccountLinkNode',\n                        'DefinedTypeLinkNode',\n                        'InstructionLinkNode',\n                        'PdaLinkNode',\n                        'ProgramLinkNode',\n                        'resolverValueNode',\n                    ],\n                    kind: kind satisfies never,\n                    node,\n                });\n        }\n    };\n}\n","import { dirname as pathDirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport { camelCase, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\nimport nunjucks, { ConfigureOptions as NunJucksOptions } from 'nunjucks';\n\nexport function jsDocblock(docs: string[]): string {\n    if (docs.length <= 0) return '';\n    if (docs.length === 1) return `/** ${docs[0]} */\\n`;\n    const lines = docs.map(doc => ` * ${doc}`);\n    return `/**\\n${lines.join('\\n')}\\n */\\n`;\n}\n\nexport const render = (template: string, context?: object, options?: NunJucksOptions): string => {\n    // @ts-expect-error import.meta will be used in the right environment.\n    const dirname = __ESM__ ? pathDirname(fileURLToPath(import.meta.url)) : __dirname;\n    const templates = __TEST__ ? join(dirname, '..', '..', 'public', 'templates') : join(dirname, 'templates'); // Path to templates from bundled output file.\n    const env = nunjucks.configure(templates, { autoescape: false, trimBlocks: true, ...options });\n    env.addFilter('pascalCase', pascalCase);\n    env.addFilter('camelCase', camelCase);\n    env.addFilter('snakeCase', snakeCase);\n    env.addFilter('kebabCase', kebabCase);\n    env.addFilter('titleCase', titleCase);\n    env.addFilter('jsDocblock', jsDocblock);\n    return env.render(template, context);\n};\n","/* eslint-disable no-case-declarations */\nimport { camelCase, InstructionInputValueNode, isNode, OptionalAccountStrategy, pascalCase } from '@codama/nodes';\nimport { ResolvedInstructionInput, visit } from '@codama/visitors-core';\n\nimport { ContextMap } from './ContextMap';\nimport { getTypeManifestVisitor } from './getTypeManifestVisitor';\nimport { ImportMap } from './ImportMap';\nimport { GetImportFromFunction } from './utils';\n\nexport function renderInstructionDefaults(\n    input: ResolvedInstructionInput,\n    typeManifestVisitor: ReturnType<typeof getTypeManifestVisitor>,\n    optionalAccountStrategy: OptionalAccountStrategy,\n    argObject: string,\n    getImportFrom: GetImportFromFunction,\n): {\n    imports: ImportMap;\n    interfaces: ContextMap;\n    render: string;\n} {\n    const imports = new ImportMap();\n    const interfaces = new ContextMap();\n\n    if (!input.defaultValue) {\n        return { imports, interfaces, render: '' };\n    }\n\n    const { defaultValue } = input;\n    const render = (\n        renderedValue: string,\n        isWritable?: boolean,\n    ): {\n        imports: ImportMap;\n        interfaces: ContextMap;\n        render: string;\n    } => {\n        const inputName = camelCase(input.name);\n        if (input.kind === 'instructionAccountNode' && isNode(defaultValue, 'resolverValueNode')) {\n            return {\n                imports,\n                interfaces,\n                render: `resolvedAccounts.${inputName} = { ...resolvedAccounts.${inputName}, ...${renderedValue} };`,\n            };\n        }\n        if (input.kind === 'instructionAccountNode' && isWritable === undefined) {\n            return {\n                imports,\n                interfaces,\n                render: `resolvedAccounts.${inputName}.value = ${renderedValue};`,\n            };\n        }\n        if (input.kind === 'instructionAccountNode') {\n            return {\n                imports,\n                interfaces,\n                render:\n                    `resolvedAccounts.${inputName}.value = ${renderedValue};\\n` +\n                    `resolvedAccounts.${inputName}.isWritable = ${isWritable ? 'true' : 'false'}`,\n            };\n        }\n        return {\n            imports,\n            interfaces,\n            render: `${argObject}.${inputName} = ${renderedValue};`,\n        };\n    };\n\n    switch (defaultValue.kind) {\n        case 'accountValueNode':\n            const name = camelCase(defaultValue.name);\n            if (input.kind === 'instructionAccountNode') {\n                imports.add('shared', 'expectSome');\n                if (input.resolvedIsSigner && !input.isSigner) {\n                    return render(`expectSome(resolvedAccounts.${name}.value).publicKey`);\n                }\n                return render(`expectSome(resolvedAccounts.${name}.value)`);\n            }\n            imports.add('shared', 'expectPublicKey');\n            return render(`expectPublicKey(resolvedAccounts.${name}.value)`);\n        case 'pdaValueNode':\n            // Inlined PDA value.\n            if (isNode(defaultValue.pda, 'pdaNode')) {\n                const pdaProgram = defaultValue.pda.programId\n                    ? `context.programs.getPublicKey('${defaultValue.pda.programId}', '${defaultValue.pda.programId}')`\n                    : 'programId';\n                const pdaSeeds = defaultValue.pda.seeds.flatMap((seed): string[] => {\n                    if (isNode(seed, 'constantPdaSeedNode') && isNode(seed.value, 'programIdValueNode')) {\n                        imports\n                            .add('umiSerializers', 'publicKey')\n                            .addAlias('umiSerializers', 'publicKey', 'publicKeySerializer');\n                        return [`publicKeySerializer().serialize(${pdaProgram})`];\n                    }\n                    if (isNode(seed, 'constantPdaSeedNode') && !isNode(seed.value, 'programIdValueNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueManifest = visit(seed.value, typeManifestVisitor);\n                        imports.mergeWith(typeManifest.serializerImports);\n                        imports.mergeWith(valueManifest.valueImports);\n                        return [`${typeManifest.serializer}.serialize(${valueManifest.value})`];\n                    }\n                    if (isNode(seed, 'variablePdaSeedNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueSeed = defaultValue.seeds.find(s => s.name === seed.name)?.value;\n                        if (!valueSeed) return [];\n                        if (isNode(valueSeed, 'accountValueNode')) {\n                            imports.mergeWith(typeManifest.serializerImports);\n                            imports.add('shared', 'expectPublicKey');\n                            return [\n                                `${typeManifest.serializer}.serialize(expectPublicKey(resolvedAccounts.${camelCase(valueSeed.name)}.value))`,\n                            ];\n                        }\n                        if (isNode(valueSeed, 'argumentValueNode')) {\n                            imports.mergeWith(typeManifest.serializerImports);\n                            imports.add('shared', 'expectSome');\n                            return [\n                                `${typeManifest.serializer}.serialize(expectSome(${argObject}.${camelCase(valueSeed.name)}))`,\n                            ];\n                        }\n                        const valueManifest = visit(valueSeed, typeManifestVisitor);\n                        imports.mergeWith(typeManifest.serializerImports);\n                        imports.mergeWith(valueManifest.valueImports);\n                        return [`${typeManifest.serializer}.serialize(${valueManifest.value})`];\n                    }\n                    return [];\n                });\n\n                interfaces.add('eddsa');\n                return render(`context.eddsa.findPda(${pdaProgram}, [${pdaSeeds.join(', ')}])`);\n            }\n\n            // Linked PDA value.\n            const pdaFunction = `find${pascalCase(defaultValue.pda.name)}Pda`;\n            imports.add(getImportFrom(defaultValue.pda), pdaFunction);\n            interfaces.add('eddsa');\n            const pdaArgs = ['context'];\n            const pdaSeeds = defaultValue.seeds.map((seed): string => {\n                if (isNode(seed.value, 'accountValueNode')) {\n                    imports.add('shared', 'expectPublicKey');\n                    return `${seed.name}: expectPublicKey(resolvedAccounts.${camelCase(seed.value.name)}.value)`;\n                }\n                if (isNode(seed.value, 'argumentValueNode')) {\n                    imports.add('shared', 'expectSome');\n                    return `${seed.name}: expectSome(${argObject}.${camelCase(seed.value.name)})`;\n                }\n                const valueManifest = visit(seed.value, typeManifestVisitor);\n                imports.mergeWith(valueManifest.valueImports);\n                return `${seed.name}: ${valueManifest.value}`;\n            });\n            if (pdaSeeds.length > 0) {\n                pdaArgs.push(`{ ${pdaSeeds.join(', ')} }`);\n            }\n            return render(`${pdaFunction}(${pdaArgs.join(', ')})`);\n        case 'publicKeyValueNode':\n            if (!defaultValue.identifier) {\n                imports.add('umi', 'publicKey');\n                return render(`publicKey('${defaultValue.publicKey}')`);\n            }\n            interfaces.add('programs');\n            return render(\n                `context.programs.getPublicKey('${defaultValue.identifier}', '${defaultValue.publicKey}')`,\n                false,\n            );\n        case 'programLinkNode':\n            const functionName = `get${pascalCase(defaultValue.name)}ProgramId`;\n            imports.add(getImportFrom(defaultValue), functionName);\n            return render(`${functionName}(context)`, false);\n        case 'programIdValueNode':\n            if (\n                optionalAccountStrategy === 'programId' &&\n                input.kind === 'instructionAccountNode' &&\n                input.isOptional\n            ) {\n                return { imports, interfaces, render: '' };\n            }\n            return render('programId', false);\n        case 'identityValueNode':\n            interfaces.add('identity');\n            if (input.kind === 'instructionAccountNode' && input.isSigner !== false) {\n                return render('context.identity');\n            }\n            return render('context.identity.publicKey');\n        case 'payerValueNode':\n            interfaces.add('payer');\n            if (input.kind === 'instructionAccountNode' && input.isSigner !== false) {\n                return render('context.payer');\n            }\n            return render('context.payer.publicKey');\n        case 'accountBumpValueNode':\n            imports.add('shared', 'expectPda');\n            return render(`expectPda(resolvedAccounts.${camelCase(defaultValue.name)}.value)[1]`);\n        case 'argumentValueNode':\n            imports.add('shared', 'expectSome');\n            return render(`expectSome(${argObject}.${camelCase(defaultValue.name)})`);\n        case 'resolverValueNode':\n            const resolverName = camelCase(defaultValue.name);\n            const isWritable = input.kind === 'instructionAccountNode' && input.isWritable ? 'true' : 'false';\n            imports.add(getImportFrom(defaultValue), resolverName);\n            interfaces.add(['eddsa', 'identity', 'payer']);\n            return render(`${resolverName}(context, resolvedAccounts, ${argObject}, programId, ${isWritable})`);\n        case 'conditionalValueNode':\n            const ifTrueRenderer = renderNestedInstructionDefault(\n                input,\n                typeManifestVisitor,\n                optionalAccountStrategy,\n                defaultValue.ifTrue,\n                argObject,\n                getImportFrom,\n            );\n            const ifFalseRenderer = renderNestedInstructionDefault(\n                input,\n                typeManifestVisitor,\n                optionalAccountStrategy,\n                defaultValue.ifFalse,\n                argObject,\n                getImportFrom,\n            );\n            if (!ifTrueRenderer && !ifFalseRenderer) {\n                return { imports, interfaces, render: '' };\n            }\n            if (ifTrueRenderer) {\n                imports.mergeWith(ifTrueRenderer.imports);\n                interfaces.mergeWith(ifTrueRenderer.interfaces);\n            }\n            if (ifFalseRenderer) {\n                imports.mergeWith(ifFalseRenderer.imports);\n                interfaces.mergeWith(ifFalseRenderer.interfaces);\n            }\n            const negatedCondition = !ifTrueRenderer;\n            let condition = 'true';\n\n            if (isNode(defaultValue.condition, 'resolverValueNode')) {\n                const conditionalResolverName = camelCase(defaultValue.condition.name);\n                const conditionalIsWritable =\n                    input.kind === 'instructionAccountNode' && input.isWritable ? 'true' : 'false';\n                imports.add(getImportFrom(defaultValue.condition), conditionalResolverName);\n                interfaces.add(['eddsa', 'identity', 'payer']);\n                condition = `${conditionalResolverName}(context, resolvedAccounts, ${argObject}, programId, ${conditionalIsWritable})`;\n                condition = negatedCondition ? `!${condition}` : condition;\n            } else {\n                const comparedInputName = isNode(defaultValue.condition, 'accountValueNode')\n                    ? `resolvedAccounts.${camelCase(defaultValue.condition.name)}.value`\n                    : `${argObject}.${camelCase(defaultValue.condition.name)}`;\n                if (defaultValue.value) {\n                    const comparedValue = visit(defaultValue.value, typeManifestVisitor);\n                    imports.mergeWith(comparedValue.valueImports);\n                    const operator = negatedCondition ? '!==' : '===';\n                    condition = `${comparedInputName} ${operator} ${comparedValue.value}`;\n                } else {\n                    condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;\n                }\n            }\n\n            if (ifTrueRenderer && ifFalseRenderer) {\n                return {\n                    imports,\n                    interfaces,\n                    render: `if (${condition}) {\\n${ifTrueRenderer.render}\\n} else {\\n${ifFalseRenderer.render}\\n}`,\n                };\n            }\n\n            return {\n                imports,\n                interfaces,\n                render: `if (${condition}) {\\n${ifTrueRenderer ? ifTrueRenderer.render : ifFalseRenderer?.render}\\n}`,\n            };\n        default:\n            const valueManifest = visit(defaultValue, typeManifestVisitor);\n            imports.mergeWith(valueManifest.valueImports);\n            return render(valueManifest.value);\n    }\n}\n\nfunction renderNestedInstructionDefault(\n    input: ResolvedInstructionInput,\n    typeManifestVisitor: ReturnType<typeof getTypeManifestVisitor>,\n    optionalAccountStrategy: OptionalAccountStrategy,\n    defaultValue: InstructionInputValueNode | undefined,\n    argObject: string,\n    getImportFrom: GetImportFromFunction,\n):\n    | {\n          imports: ImportMap;\n          interfaces: ContextMap;\n          render: string;\n      }\n    | undefined {\n    if (!defaultValue) return undefined;\n    return renderInstructionDefaults(\n        { ...input, defaultValue },\n        typeManifestVisitor,\n        optionalAccountStrategy,\n        argObject,\n        getImportFrom,\n    );\n}\n","import { deleteDirectory } from '@codama/renderers-core';\nimport { LogLevel, throwValidatorItemsVisitor } from '@codama/validators';\nimport { rootNodeVisitor, visit } from '@codama/visitors-core';\nimport { Plugin } from 'prettier';\nimport * as estreePlugin from 'prettier/plugins/estree';\nimport * as typeScriptPlugin from 'prettier/plugins/typescript';\nimport { format } from 'prettier/standalone';\n\nimport { GetRenderMapOptions, getRenderMapVisitor } from './getRenderMapVisitor';\nimport { getValidationItemsVisitor } from './getValidatorBagVisitor';\n\ntype PrettierOptions = Parameters<typeof format>[1];\n\nexport type RenderOptions = GetRenderMapOptions & {\n    deleteFolderBeforeRendering?: boolean;\n    formatCode?: boolean;\n    prettierOptions?: PrettierOptions;\n    throwLevel?: LogLevel;\n};\n\nconst DEFAULT_PRETTIER_OPTIONS: PrettierOptions = {\n    arrowParens: 'always',\n    parser: 'typescript',\n    plugins: [estreePlugin as Plugin<unknown>, typeScriptPlugin],\n    printWidth: 80,\n    semi: true,\n    singleQuote: true,\n    tabWidth: 2,\n    trailingComma: 'es5',\n    useTabs: false,\n};\n\nexport function renderVisitor(path: string, options: RenderOptions = {}) {\n    return rootNodeVisitor(async root => {\n        // Validate nodes.\n        visit(root, throwValidatorItemsVisitor(getValidationItemsVisitor(), options.throwLevel));\n\n        // Delete existing generated folder.\n        if (options.deleteFolderBeforeRendering ?? true) {\n            deleteDirectory(path);\n        }\n\n        // Render the new files.\n        const renderMap = visit(root, getRenderMapVisitor(options));\n\n        // Format the code.\n        if (options.formatCode ?? true) {\n            const prettierOptions = { ...DEFAULT_PRETTIER_OPTIONS, ...options.prettierOptions };\n            await renderMap.mapContentAsync(code => format(code, prettierOptions));\n        }\n\n        renderMap.write(path);\n    });\n}\n","import { camelCase, isDataEnum, isNode, Node, pascalCase, resolveNestedTypeNode, titleCase } from '@codama/nodes';\nimport { ValidationItem, validationItem } from '@codama/validators';\nimport { extendVisitor, mergeVisitor, NodeStack, pipe, recordNodeStackVisitor, Visitor } from '@codama/visitors-core';\n\nexport function getValidationItemsVisitor(): Visitor<readonly ValidationItem[]> {\n    const exportMap: Map<string, { exportType: string; node: Node; stack: NodeStack }> = new Map();\n    const stack = new NodeStack();\n\n    const isEponymousExport = (node: Node, exportName: string): boolean =>\n        exportName === ('name' in node ? node.name : '');\n\n    const getNodeTitle = (node: Node): string => {\n        const name = 'name' in node ? node.name : '';\n        const type = titleCase(node.kind.slice(0, -4)).toLowerCase();\n        return `\"${name}\" ${type}`;\n    };\n\n    const checkExportConflicts = (node: Node, exports: Record<string, string>): readonly ValidationItem[] => {\n        const items = [] as ValidationItem[];\n        const conflictingNodes: Node[] = [];\n        Object.entries(exports).forEach(([exportName, exportType]) => {\n            // Checks for conflicts.\n            const exportConflict = exportMap.get(exportName);\n            if (!exportConflict) {\n                exportMap.set(exportName, { exportType, node, stack: stack.clone() });\n                return;\n            }\n\n            // Avoids throwing many similar error for the same kind of conflict.\n            const conflictingNode = exportConflict.node;\n            if (conflictingNodes.includes(conflictingNode)) return;\n            conflictingNodes.push(conflictingNode);\n\n            // Constructs the error message.\n            let exportDetails = '';\n            let conflictExportDetails = '';\n            if (!isEponymousExport(node, exportName)) {\n                exportDetails = `exports a \"${exportName}\" ${exportType} that `;\n            }\n            if (!isEponymousExport(conflictingNode, exportName)) {\n                conflictExportDetails = `\"${exportName}\" ${exportConflict.exportType} exported by the `;\n            }\n            const message =\n                `The ${getNodeTitle(node)} ${exportDetails}` +\n                `conflicts with the ${conflictExportDetails}` +\n                `${getNodeTitle(conflictingNode)}.\\n` +\n                `|> Conflicting stack: ${exportConflict.stack.toString()}.`;\n            items.push(validationItem('error', message, node, stack));\n        });\n        return items;\n    };\n\n    return pipe(\n        mergeVisitor(\n            () => [] as readonly ValidationItem[],\n            (_, items) => items.flat(),\n        ),\n        v => recordNodeStackVisitor(v, stack),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node, { next }) {\n                    const items = [] as ValidationItem[];\n                    const pascalCaseName = pascalCase(node.name);\n                    const exports = {\n                        [pascalCaseName]: 'type',\n                        [`${pascalCaseName}AccountData`]: 'type',\n                        [`${pascalCaseName}AccountDataArgs`]: 'type',\n                        [`fetch${pascalCaseName}`]: 'function',\n                        [`safeFetch${pascalCaseName}`]: 'function',\n                        [`deserialize${pascalCaseName}`]: 'function',\n                        [`get${pascalCaseName}AccountDataSerializer`]: 'function',\n                        [`get${pascalCaseName}GpaBuilder`]: 'function',\n                        [`get${pascalCaseName}Size`]: 'function',\n                    };\n                    items.push(...checkExportConflicts(node, exports));\n\n                    const reservedAccountFields = new Set(['publicKey', 'header']);\n                    const invalidFields = resolveNestedTypeNode(node.data)\n                        .fields.map(field => field.name)\n                        .filter(name => reservedAccountFields.has(name));\n                    if (invalidFields.length > 0) {\n                        const x = invalidFields.join(', ');\n                        const message =\n                            invalidFields.length === 1\n                                ? `Account field [${x}] is reserved. Please rename it.`\n                                : `Account fields [${x}] are reserved. Please rename them.`;\n                        items.push(validationItem('error', message, node, stack));\n                    }\n                    return [...items, ...next(node)];\n                },\n\n                visitDefinedType(node, { next }) {\n                    const items = [] as ValidationItem[];\n                    const camelCaseName = camelCase(node.name);\n                    const pascalCaseName = pascalCase(node.name);\n                    items.push(\n                        ...checkExportConflicts(node, {\n                            [pascalCaseName]: 'type',\n                            [`${pascalCaseName}Args`]: 'type',\n                            [`fetch${pascalCaseName}`]: 'function',\n                            ...(isNode(node.type, 'enumTypeNode') && isDataEnum(node.type)\n                                ? {\n                                      [camelCaseName]: 'function',\n                                      [`is${pascalCaseName}`]: 'function',\n                                  }\n                                : {}),\n                        }),\n                    );\n                    return [...items, ...next(node)];\n                },\n\n                visitError(node, { next }) {\n                    const items = [] as ValidationItem[];\n                    items.push(\n                        ...checkExportConflicts(node, {\n                            [`${pascalCase(node.name)}Error`]: 'class',\n                        }),\n                    );\n                    return [...items, ...next(node)];\n                },\n\n                visitInstruction(node, { next }) {\n                    const items = [] as ValidationItem[];\n                    const camelCaseName = camelCase(node.name);\n                    const pascalCaseName = pascalCase(node.name);\n                    const pascalCaseData = `${pascalCaseName}InstructionData`;\n                    const pascalCaseExtra = `${pascalCaseName}InstructionExtra`;\n                    items.push(\n                        ...checkExportConflicts(node, {\n                            [camelCaseName]: 'function',\n                            [`${pascalCaseName}InstructionAccounts`]: 'type',\n                            [`${pascalCaseName}InstructionArgs`]: 'type',\n                            [`${pascalCaseData}`]: 'type',\n                            [`${pascalCaseData}Args`]: 'type',\n                            [`get${pascalCaseData}Serializer`]: 'function',\n                            [`${pascalCaseExtra}Args`]: 'type',\n                        }),\n                    );\n                    return [...items, ...next(node)];\n                },\n\n                visitProgram(node, { next }) {\n                    const items = [] as ValidationItem[];\n                    const pascalCaseName = pascalCase(node.name);\n                    items.push(\n                        ...checkExportConflicts(node, {\n                            [`get${pascalCaseName}Program`]: 'function',\n                            [`get${pascalCaseName}ErrorFromCode`]: 'function',\n                            [`get${pascalCaseName}ErrorFromName`]: 'function',\n                        }),\n                    );\n                    return [...items, ...next(node)];\n                },\n            }),\n    );\n}\n"],"mappings":"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","names":["module","import_errors","import_nodes","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_nodes","import_nodes","nunjucks","optionsAsString","import_nodes","import_visitors_core","render","pdaSeeds","typeManifest","valueManifest","typeManifest","seedManifest","import_renderers_core","import_validators","import_visitors_core","import_nodes","import_visitors_core","exports"]}