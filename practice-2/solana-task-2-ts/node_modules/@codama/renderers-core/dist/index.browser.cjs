"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  RenderMap: () => RenderMap,
  createDirectory: () => createDirectory,
  createFile: () => createFile,
  deleteDirectory: () => deleteDirectory,
  readJson: () => readJson,
  writeRenderMapVisitor: () => writeRenderMapVisitor
});
module.exports = __toCommonJS(index_exports);

// src/fs.ts
var import_node_fs = require("fs");
var import_errors = require("@codama/errors");
function readJson(value) {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "readFileSync" });
  }
  return JSON.parse((0, import_node_fs.readFileSync)(value, "utf-8"));
}
var createDirectory = (path) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "mkdirSync" });
  }
  (0, import_node_fs.mkdirSync)(path, { recursive: true });
};
var deleteDirectory = (path) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "rmSync" });
  }
  if ((0, import_node_fs.existsSync)(path)) {
    (0, import_node_fs.rmSync)(path, { recursive: true });
  }
};
var createFile = (path, content) => {
  if (true) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "writeFileSync" });
  }
  const directory = path.substring(0, path.lastIndexOf("/"));
  if (!(0, import_node_fs.existsSync)(directory)) {
    createDirectory(directory);
  }
  (0, import_node_fs.writeFileSync)(path, content);
};

// src/RenderMap.ts
var import_errors2 = require("@codama/errors");
var RenderMap = class {
  _map = /* @__PURE__ */ new Map();
  add(relativePath, code) {
    this._map.set(relativePath, code);
    return this;
  }
  remove(relativePath) {
    this._map.delete(relativePath);
    return this;
  }
  mergeWith(...others) {
    others.forEach((other) => {
      other._map.forEach((code, relativePath) => {
        this.add(relativePath, code);
      });
    });
    return this;
  }
  isEmpty() {
    return this._map.size === 0;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    const value = this.safeGet(key);
    if (value === void 0) {
      throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key });
    }
    return value;
  }
  safeGet(key) {
    return this._map.get(key);
  }
  contains(key, value) {
    const content = this.get(key);
    return typeof value === "string" ? content.includes(value) : value.test(content);
  }
  async mapContentAsync(fn) {
    await Promise.all(
      [...this._map.entries()].map(async ([relativePath, code]) => {
        this._map.set(relativePath, await fn(code));
      })
    );
    return this;
  }
  mapContent(fn) {
    this._map.forEach((code, relativePath) => {
      this._map.set(relativePath, fn(code));
    });
    return this;
  }
  write(path) {
    this._map.forEach((code, relativePath) => {
      createFile(`${path}/${relativePath}`, code);
    });
  }
};

// src/writeRenderMapVisitor.ts
var import_visitors_core = require("@codama/visitors-core");
function writeRenderMapVisitor(visitor, path) {
  return (0, import_visitors_core.mapVisitor)(visitor, (renderMap) => renderMap.write(path));
}
//# sourceMappingURL=index.browser.cjs.map