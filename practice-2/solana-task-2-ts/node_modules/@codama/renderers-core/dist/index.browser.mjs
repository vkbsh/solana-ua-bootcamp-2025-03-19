// src/fs.ts
import { existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "node:fs";
import { CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, CodamaError } from "@codama/errors";
function readJson(value) {
  if (true) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "readFileSync" });
  }
  return JSON.parse(readFileSync(value, "utf-8"));
}
var createDirectory = (path) => {
  if (true) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "mkdirSync" });
  }
  mkdirSync(path, { recursive: true });
};
var deleteDirectory = (path) => {
  if (true) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "rmSync" });
  }
  if (existsSync(path)) {
    rmSync(path, { recursive: true });
  }
};
var createFile = (path, content) => {
  if (true) {
    throw new CodamaError(CODAMA_ERROR__NODE_FILESYSTEM_FUNCTION_UNAVAILABLE, { fsFunction: "writeFileSync" });
  }
  const directory = path.substring(0, path.lastIndexOf("/"));
  if (!existsSync(directory)) {
    createDirectory(directory);
  }
  writeFileSync(path, content);
};

// src/RenderMap.ts
import { CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, CodamaError as CodamaError2 } from "@codama/errors";
var RenderMap = class {
  _map = /* @__PURE__ */ new Map();
  add(relativePath, code) {
    this._map.set(relativePath, code);
    return this;
  }
  remove(relativePath) {
    this._map.delete(relativePath);
    return this;
  }
  mergeWith(...others) {
    others.forEach((other) => {
      other._map.forEach((code, relativePath) => {
        this.add(relativePath, code);
      });
    });
    return this;
  }
  isEmpty() {
    return this._map.size === 0;
  }
  has(key) {
    return this._map.has(key);
  }
  get(key) {
    const value = this.safeGet(key);
    if (value === void 0) {
      throw new CodamaError2(CODAMA_ERROR__VISITORS__RENDER_MAP_KEY_NOT_FOUND, { key });
    }
    return value;
  }
  safeGet(key) {
    return this._map.get(key);
  }
  contains(key, value) {
    const content = this.get(key);
    return typeof value === "string" ? content.includes(value) : value.test(content);
  }
  async mapContentAsync(fn) {
    await Promise.all(
      [...this._map.entries()].map(async ([relativePath, code]) => {
        this._map.set(relativePath, await fn(code));
      })
    );
    return this;
  }
  mapContent(fn) {
    this._map.forEach((code, relativePath) => {
      this._map.set(relativePath, fn(code));
    });
    return this;
  }
  write(path) {
    this._map.forEach((code, relativePath) => {
      createFile(`${path}/${relativePath}`, code);
    });
  }
};

// src/writeRenderMapVisitor.ts
import { mapVisitor } from "@codama/visitors-core";
function writeRenderMapVisitor(visitor, path) {
  return mapVisitor(visitor, (renderMap) => renderMap.write(path));
}
export {
  RenderMap,
  createDirectory,
  createFile,
  deleteDirectory,
  readJson,
  writeRenderMapVisitor
};
//# sourceMappingURL=index.browser.mjs.map