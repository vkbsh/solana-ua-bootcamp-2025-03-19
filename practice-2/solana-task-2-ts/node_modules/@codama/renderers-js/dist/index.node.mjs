// src/ImportMap.ts
var DEFAULT_EXTERNAL_MODULE_MAP = {
  solanaAccounts: "@solana/kit",
  solanaAddresses: "@solana/kit",
  solanaCodecsCore: "@solana/kit",
  solanaCodecsDataStructures: "@solana/kit",
  solanaCodecsNumbers: "@solana/kit",
  solanaCodecsStrings: "@solana/kit",
  solanaErrors: "@solana/kit",
  solanaInstructions: "@solana/kit",
  solanaOptions: "@solana/kit",
  solanaPrograms: "@solana/kit",
  solanaRpcTypes: "@solana/kit",
  solanaSigners: "@solana/kit"
};
var DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP = {
  solanaAccounts: "@solana/accounts",
  solanaAddresses: "@solana/addresses",
  solanaCodecsCore: "@solana/codecs",
  solanaCodecsDataStructures: "@solana/codecs",
  solanaCodecsNumbers: "@solana/codecs",
  solanaCodecsStrings: "@solana/codecs",
  solanaErrors: "@solana/errors",
  solanaInstructions: "@solana/instructions",
  solanaOptions: "@solana/codecs",
  solanaPrograms: "@solana/programs",
  solanaRpcTypes: "@solana/rpc-types",
  solanaSigners: "@solana/signers"
};
var DEFAULT_INTERNAL_MODULE_MAP = {
  errors: "../errors",
  generated: "..",
  generatedAccounts: "../accounts",
  generatedErrors: "../errors",
  generatedInstructions: "../instructions",
  generatedPdas: "../pdas",
  generatedPrograms: "../programs",
  generatedTypes: "../types",
  hooked: "../../hooked",
  shared: "../shared",
  types: "../types"
};
var ImportMap = class {
  _imports = /* @__PURE__ */ new Map();
  _aliases = /* @__PURE__ */ new Map();
  add(module, imports) {
    const newImports = new Set(typeof imports === "string" ? [imports] : imports);
    if (newImports.size === 0) return this;
    const currentImports = this._imports.get(module) ?? /* @__PURE__ */ new Set();
    newImports.forEach((i) => currentImports.add(i));
    this._imports.set(module, currentImports);
    return this;
  }
  remove(module, imports) {
    const importsToRemove = new Set(typeof imports === "string" ? [imports] : imports);
    if (importsToRemove.size === 0) return this;
    const currentImports = this._imports.get(module) ?? /* @__PURE__ */ new Set();
    importsToRemove.forEach((i) => currentImports.delete(i));
    if (currentImports.size === 0) {
      this._imports.delete(module);
    } else {
      this._imports.set(module, currentImports);
    }
    return this;
  }
  mergeWith(...others) {
    others.forEach((rawOther) => {
      const other = "imports" in rawOther ? rawOther.imports : rawOther;
      other._imports.forEach((imports, module) => {
        this.add(module, imports);
      });
      other._aliases.forEach((aliases, module) => {
        Object.entries(aliases).forEach(([name, alias]) => {
          this.addAlias(module, name, alias);
        });
      });
    });
    return this;
  }
  mergeWithManifest(manifest) {
    return this.mergeWith(manifest.strictType, manifest.looseType, manifest.encoder, manifest.decoder);
  }
  addAlias(module, name, alias) {
    const currentAliases = this._aliases.get(module) ?? {};
    currentAliases[name] = alias;
    this._aliases.set(module, currentAliases);
    return this;
  }
  isEmpty() {
    return this._imports.size === 0;
  }
  resolve(dependencies = {}, useGranularImports = false) {
    const aliasedMap = new Map(
      [...this._imports.entries()].map(([module, imports]) => {
        const aliasMap = this._aliases.get(module) ?? {};
        const joinedImports = [...imports].map((i) => aliasMap[i] ? `${i} as ${aliasMap[i]}` : i);
        return [module, new Set(joinedImports)];
      })
    );
    const dependencyMap = {
      ...useGranularImports ? DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP : DEFAULT_EXTERNAL_MODULE_MAP,
      ...DEFAULT_INTERNAL_MODULE_MAP,
      ...dependencies
    };
    const resolvedMap = /* @__PURE__ */ new Map();
    aliasedMap.forEach((imports, module) => {
      const resolvedModule = dependencyMap[module] ?? module;
      const currentImports = resolvedMap.get(resolvedModule) ?? /* @__PURE__ */ new Set();
      imports.forEach((i) => currentImports.add(i));
      resolvedMap.set(resolvedModule, currentImports);
    });
    return resolvedMap;
  }
  toString(dependencies = {}, useGranularImports = false) {
    return [...this.resolve(dependencies, useGranularImports).entries()].sort(([a], [b]) => {
      const aIsRelative = a.startsWith(".");
      const bIsRelative = b.startsWith(".");
      if (aIsRelative && !bIsRelative) return 1;
      if (!aIsRelative && bIsRelative) return -1;
      return a.localeCompare(b);
    }).map(([module, imports]) => {
      const joinedImports = [...imports].sort().filter((i) => {
        const name = i.split(" ");
        if (name.length > 1) {
          return !imports.has(name[1]);
        }
        return true;
      }).join(", ");
      return `import { ${joinedImports} } from '${module}';`;
    }).join("\n");
  }
};

// src/fragments/accountFetchHelpers.ts
import { getLastNodeFromPath } from "@codama/visitors-core";

// src/fragments/common.ts
import { join as join2 } from "node:path";

// src/utils/async.ts
import {
  accountValueNode,
  argumentValueNode,
  isNode
} from "@codama/nodes";
import { deduplicateInstructionDependencies } from "@codama/visitors-core";
function hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers) {
  const hasByteDeltasAsync = (instructionNode.byteDeltas ?? []).some(
    ({ value }) => isNode(value, "resolverValueNode") && asyncResolvers.includes(value.name)
  );
  const hasRemainingAccountsAsync = (instructionNode.remainingAccounts ?? []).some(
    ({ value }) => isNode(value, "resolverValueNode") && asyncResolvers.includes(value.name)
  );
  return hasAsyncDefaultValues(resolvedInputs, asyncResolvers) || hasByteDeltasAsync || hasRemainingAccountsAsync;
}
function hasAsyncDefaultValues(resolvedInputs, asyncResolvers) {
  return resolvedInputs.some(
    (input) => !!input.defaultValue && isAsyncDefaultValue(input.defaultValue, asyncResolvers)
  );
}
function isAsyncDefaultValue(defaultValue, asyncResolvers) {
  switch (defaultValue.kind) {
    case "pdaValueNode":
      return true;
    case "resolverValueNode":
      return asyncResolvers.includes(defaultValue.name);
    case "conditionalValueNode":
      return isAsyncDefaultValue(defaultValue.condition, asyncResolvers) || (defaultValue.ifFalse == null ? false : isAsyncDefaultValue(defaultValue.ifFalse, asyncResolvers)) || (defaultValue.ifTrue == null ? false : isAsyncDefaultValue(defaultValue.ifTrue, asyncResolvers));
    default:
      return false;
  }
}
function getInstructionDependencies(input, asyncResolvers, useAsync) {
  if (isNode(input, "instructionNode")) {
    return deduplicateInstructionDependencies([
      ...input.accounts.flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync)),
      ...input.arguments.flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync)),
      ...(input.extraArguments ?? []).flatMap((x) => getInstructionDependencies(x, asyncResolvers, useAsync))
    ]);
  }
  if (!input.defaultValue) return [];
  const getNestedDependencies = (defaultValue) => {
    if (!defaultValue) return [];
    return getInstructionDependencies({ ...input, defaultValue }, asyncResolvers, useAsync);
  };
  if (isNode(input.defaultValue, ["accountValueNode", "accountBumpValueNode"])) {
    return [accountValueNode(input.defaultValue.name)];
  }
  if (isNode(input.defaultValue, ["argumentValueNode"])) {
    return [argumentValueNode(input.defaultValue.name)];
  }
  if (isNode(input.defaultValue, "pdaValueNode")) {
    const dependencies = /* @__PURE__ */ new Map();
    input.defaultValue.seeds.forEach((seed) => {
      if (isNode(seed.value, ["accountValueNode", "argumentValueNode"])) {
        dependencies.set(seed.value.name, { ...seed.value });
      }
    });
    return [...dependencies.values()];
  }
  if (isNode(input.defaultValue, "resolverValueNode")) {
    const isSynchronousResolver = !asyncResolvers.includes(input.defaultValue.name);
    if (useAsync || isSynchronousResolver) {
      return input.defaultValue.dependsOn ?? [];
    }
  }
  if (isNode(input.defaultValue, "conditionalValueNode")) {
    return deduplicateInstructionDependencies([
      ...getNestedDependencies(input.defaultValue.condition),
      ...getNestedDependencies(input.defaultValue.ifTrue),
      ...getNestedDependencies(input.defaultValue.ifFalse)
    ]);
  }
  return [];
}

// src/utils/codecs.ts
import { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from "@solana/codecs-strings";
function getBytesFromBytesValueNode(node) {
  switch (node.encoding) {
    case "utf8":
      return getUtf8Encoder().encode(node.data);
    case "base16":
      return getBase16Encoder().encode(node.data);
    case "base58":
      return getBase58Encoder().encode(node.data);
    case "base64":
    default:
      return getBase64Encoder().encode(node.data);
  }
}

// src/utils/customData.ts
import {
  camelCase,
  definedTypeLinkNode,
  definedTypeNode,
  isNode as isNode2,
  structTypeNodeFromInstructionArgumentNodes
} from "@codama/nodes";
var parseCustomDataOptions = (customDataOptions, defaultSuffix) => new Map(
  customDataOptions.map((o) => {
    const options = typeof o === "string" ? { name: o } : o;
    const importAs = camelCase(options.importAs ?? `${options.name}${defaultSuffix}`);
    const importFrom = options.importFrom ?? "hooked";
    return [
      camelCase(options.name),
      {
        extract: options.extract ?? false,
        extractAs: options.extractAs ? camelCase(options.extractAs) : importAs,
        importAs,
        importFrom,
        linkNode: definedTypeLinkNode(importAs)
      }
    ];
  })
);
var getDefinedTypeNodesToExtract = (nodes, parsedCustomDataOptions) => nodes.flatMap((node) => {
  const options = parsedCustomDataOptions.get(node.name);
  if (!options || !options.extract) return [];
  if (isNode2(node, "accountNode")) {
    return [definedTypeNode({ name: options.extractAs, type: { ...node.data } })];
  }
  return [
    definedTypeNode({
      name: options.extractAs,
      type: structTypeNodeFromInstructionArgumentNodes(node.arguments)
    })
  ];
});

// src/utils/linkOverrides.ts
import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from "@codama/errors";
function getImportFromFactory(overrides, customAccountData, customInstructionData) {
  const customDataOverrides = Object.fromEntries(
    [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [
      importAs,
      importFrom
    ])
  );
  const linkOverrides = {
    accounts: overrides.accounts ?? {},
    definedTypes: { ...customDataOverrides, ...overrides.definedTypes },
    instructions: overrides.instructions ?? {},
    pdas: overrides.pdas ?? {},
    programs: overrides.programs ?? {},
    resolvers: overrides.resolvers ?? {}
  };
  return (node) => {
    const kind = node.kind;
    switch (kind) {
      case "accountLinkNode":
        return linkOverrides.accounts[node.name] ?? "generatedAccounts";
      case "definedTypeLinkNode":
        return linkOverrides.definedTypes[node.name] ?? "generatedTypes";
      case "instructionLinkNode":
        return linkOverrides.instructions[node.name] ?? "generatedInstructions";
      case "pdaLinkNode":
        return linkOverrides.pdas[node.name] ?? "generatedPdas";
      case "programLinkNode":
        return linkOverrides.programs[node.name] ?? "generatedPrograms";
      case "resolverValueNode":
        return linkOverrides.resolvers[node.name] ?? "hooked";
      default:
        throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {
          expectedKinds: [
            "AccountLinkNode",
            "DefinedTypeLinkNode",
            "InstructionLinkNode",
            "PdaLinkNode",
            "ProgramLinkNode",
            "resolverValueNode"
          ],
          kind,
          node
        });
    }
  };
}

// src/utils/render.ts
import { dirname as pathDirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { camelCase as camelCase2, kebabCase, pascalCase, snakeCase, titleCase } from "@codama/nodes";
import nunjucks from "nunjucks";
function jsDocblock(docs) {
  if (docs.length <= 0) return "";
  if (docs.length === 1) return `/** ${docs[0]} */
`;
  const lines = docs.map((doc) => ` * ${doc}`);
  return `/**
${lines.join("\n")}
 */
`;
}
var render = (template, context, options) => {
  const dirname = true ? pathDirname(fileURLToPath(import.meta.url)) : __dirname;
  const templates = false ? join(dirname, "..", "..", "public", "templates") : join(dirname, "templates");
  const env = nunjucks.configure(templates, { autoescape: false, trimBlocks: true, ...options });
  env.addFilter("pascalCase", pascalCase);
  env.addFilter("camelCase", camelCase2);
  env.addFilter("snakeCase", snakeCase);
  env.addFilter("kebabCase", kebabCase);
  env.addFilter("titleCase", titleCase);
  env.addFilter("jsDocblock", jsDocblock);
  return env.render(template, context);
};

// src/fragments/common.ts
function fragment(render2, imports) {
  return new Fragment(render2, imports);
}
function fragmentFromTemplate(fragmentFile, context, options) {
  return fragment(render(join2("fragments", fragmentFile), context, options));
}
function mergeFragments(fragments, mergeRenders) {
  return new Fragment(
    mergeRenders(fragments.map((f) => f.render)),
    new ImportMap().mergeWith(...fragments),
    new Set(fragments.flatMap((f) => [...f.features]))
  );
}
var Fragment = class _Fragment {
  render;
  imports;
  features;
  constructor(render2, imports, features) {
    this.render = render2;
    this.imports = imports ? new ImportMap().mergeWith(imports) : new ImportMap();
    this.features = /* @__PURE__ */ new Set([...features ?? []]);
  }
  setRender(render2) {
    this.render = render2;
    return this;
  }
  mapRender(fn) {
    this.render = fn(this.render);
    return this;
  }
  addImports(module, imports) {
    this.imports.add(module, imports);
    return this;
  }
  removeImports(module, imports) {
    this.imports.remove(module, imports);
    return this;
  }
  mergeImportsWith(...others) {
    this.imports.mergeWith(...others);
    return this;
  }
  addImportAlias(module, name, alias) {
    this.imports.addAlias(module, name, alias);
    return this;
  }
  addFeatures(features) {
    const featureArray = typeof features === "string" ? [features] : features;
    featureArray.forEach((f) => this.features.add(f));
    return this;
  }
  removeFeatures(features) {
    const featureArray = typeof features === "string" ? [features] : features;
    featureArray.forEach((f) => this.features.delete(f));
    return this;
  }
  hasFeatures(features) {
    const featureArray = typeof features === "string" ? [features] : features;
    return featureArray.every((f) => this.features.has(f));
  }
  mergeFeaturesWith(...others) {
    others.forEach((f) => this.addFeatures([...f.features]));
    return this;
  }
  clone() {
    return new _Fragment(this.render).mergeImportsWith(this.imports);
  }
  toString() {
    return this.render;
  }
};

// src/fragments/accountFetchHelpers.ts
function getAccountFetchHelpersFragment(scope) {
  const { accountPath, typeManifest: typeManifest2, nameApi, customAccountData } = scope;
  const accountNode = getLastNodeFromPath(accountPath);
  const hasCustomData = customAccountData.has(accountNode.name);
  const accountTypeFragment = hasCustomData ? typeManifest2.strictType.clone() : fragment(nameApi.dataType(accountNode.name));
  const decoderFunctionFragment = hasCustomData ? typeManifest2.decoder.clone() : fragment(`${nameApi.decoderFunction(accountNode.name)}()`);
  return fragmentFromTemplate("accountFetchHelpers.njk", {
    accountType: accountTypeFragment.render,
    decodeFunction: nameApi.accountDecodeFunction(accountNode.name),
    decoderFunction: decoderFunctionFragment.render,
    fetchAllFunction: nameApi.accountFetchAllFunction(accountNode.name),
    fetchAllMaybeFunction: nameApi.accountFetchAllMaybeFunction(accountNode.name),
    fetchFunction: nameApi.accountFetchFunction(accountNode.name),
    fetchMaybeFunction: nameApi.accountFetchMaybeFunction(accountNode.name)
  }).mergeImportsWith(accountTypeFragment, decoderFunctionFragment).addImports("solanaAddresses", ["type Address"]).addImports("solanaAccounts", [
    "type Account",
    "assertAccountExists",
    "assertAccountsExist",
    "decodeAccount",
    "type EncodedAccount",
    "fetchEncodedAccount",
    "fetchEncodedAccounts",
    "type FetchAccountConfig",
    "type FetchAccountsConfig",
    "type MaybeAccount",
    "type MaybeEncodedAccount"
  ]);
}

// src/fragments/accountPdaHelpers.ts
import { isNodeFilter } from "@codama/nodes";
import { findProgramNodeFromPath, getLastNodeFromPath as getLastNodeFromPath2 } from "@codama/visitors-core";
function getAccountPdaHelpersFragment(scope) {
  const { accountPath, nameApi, linkables, customAccountData, typeManifest: typeManifest2 } = scope;
  const accountNode = getLastNodeFromPath2(accountPath);
  const programNode = findProgramNodeFromPath(accountPath);
  const pdaNode = accountNode.pda ? linkables.get([...accountPath, accountNode.pda]) : void 0;
  if (!pdaNode) {
    return fragment("");
  }
  const accountTypeFragment = customAccountData.has(accountNode.name) ? typeManifest2.strictType.clone() : fragment(nameApi.dataType(accountNode.name));
  const importFrom = "generatedPdas";
  const pdaSeedsType = nameApi.pdaSeedsType(pdaNode.name);
  const findPdaFunction = nameApi.pdaFindFunction(pdaNode.name);
  const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter("variablePdaSeedNode")).length > 0;
  return fragmentFromTemplate("accountPdaHelpers.njk", {
    accountType: accountTypeFragment.render,
    fetchFromSeedsFunction: nameApi.accountFetchFromSeedsFunction(accountNode.name),
    fetchFunction: nameApi.accountFetchFunction(accountNode.name),
    fetchMaybeFromSeedsFunction: nameApi.accountFetchMaybeFromSeedsFunction(accountNode.name),
    fetchMaybeFunction: nameApi.accountFetchMaybeFunction(accountNode.name),
    findPdaFunction,
    hasVariableSeeds,
    pdaSeedsType,
    program: programNode
  }).mergeImportsWith(accountTypeFragment).addImports(importFrom, hasVariableSeeds ? [pdaSeedsType, findPdaFunction] : [findPdaFunction]).addImports("solanaAddresses", ["type Address"]).addImports("solanaAccounts", [
    "type Account",
    "assertAccountExists",
    "type FetchAccountConfig",
    "type MaybeAccount"
  ]);
}

// src/fragments/accountSizeHelpers.ts
import { getLastNodeFromPath as getLastNodeFromPath3 } from "@codama/visitors-core";
function getAccountSizeHelpersFragment(scope) {
  const { accountPath, nameApi } = scope;
  const accountNode = getLastNodeFromPath3(accountPath);
  if (accountNode.size == null) {
    return fragment("");
  }
  return fragmentFromTemplate("accountSizeHelpers.njk", {
    account: accountNode,
    getSizeFunction: nameApi.accountGetSizeFunction(accountNode.name)
  });
}

// src/fragments/accountType.ts
import { getLastNodeFromPath as getLastNodeFromPath4 } from "@codama/visitors-core";

// src/fragments/type.ts
function getTypeFragment(scope) {
  const { name, manifest, nameApi, docs = [] } = scope;
  const typeFragment = fragmentFromTemplate("type.njk", {
    docs,
    looseName: nameApi.dataArgsType(name),
    manifest,
    strictName: nameApi.dataType(name)
  });
  if (!manifest.isEnum) {
    typeFragment.mergeImportsWith(manifest.strictType, manifest.looseType);
  }
  return typeFragment;
}

// src/fragments/typeDecoder.ts
function getTypeDecoderFragment(scope) {
  const { name, manifest, nameApi, docs = [] } = scope;
  return fragmentFromTemplate("typeDecoder.njk", {
    decoderFunction: nameApi.decoderFunction(name),
    docs,
    looseName: nameApi.dataArgsType(name),
    manifest,
    strictName: nameApi.dataType(name)
  }).mergeImportsWith(manifest.decoder).addImports("solanaCodecsCore", "type Decoder");
}

// src/fragments/typeEncoder.ts
function getTypeEncoderFragment(scope) {
  const { name, manifest, nameApi, docs = [] } = scope;
  return fragmentFromTemplate("typeEncoder.njk", {
    docs,
    encoderFunction: nameApi.encoderFunction(name),
    looseName: nameApi.dataArgsType(name),
    manifest,
    strictName: nameApi.dataType(name)
  }).mergeImportsWith(manifest.encoder).addImports("solanaCodecsCore", "type Encoder");
}

// src/fragments/typeCodec.ts
function getTypeCodecFragment(scope) {
  const { name, manifest, nameApi } = scope;
  return mergeFragments(
    [
      getTypeEncoderFragment({ ...scope, docs: scope.encoderDocs }),
      getTypeDecoderFragment({ ...scope, docs: scope.decoderDocs }),
      fragmentFromTemplate("typeCodec.njk", {
        codecFunction: nameApi.codecFunction(name),
        decoderFunction: nameApi.decoderFunction(name),
        docs: scope.codecDocs,
        encoderFunction: nameApi.encoderFunction(name),
        looseName: nameApi.dataArgsType(name),
        manifest,
        strictName: nameApi.dataType(name)
      }).addImports("solanaCodecsCore", ["type Codec", "combineCodec"])
    ],
    (renders) => renders.join("\n\n")
  );
}

// src/fragments/typeWithCodec.ts
function getTypeWithCodecFragment(scope) {
  return mergeFragments(
    [getTypeFragment({ ...scope, docs: scope.typeDocs }), getTypeCodecFragment(scope)],
    (renders) => renders.join("\n\n")
  );
}

// src/fragments/accountType.ts
function getAccountTypeFragment(scope) {
  const { accountPath, typeManifest: typeManifest2, nameApi, customAccountData } = scope;
  const accountNode = getLastNodeFromPath4(accountPath);
  if (customAccountData.has(accountNode.name)) {
    return fragment("");
  }
  return getTypeWithCodecFragment({
    manifest: typeManifest2,
    name: accountNode.name,
    nameApi
  });
}

// src/fragments/discriminatorCondition.ts
import {
  constantDiscriminatorNode,
  constantValueNode,
  constantValueNodeFromBytes,
  isNode as isNode3,
  isNodeFilter as isNodeFilter2
} from "@codama/nodes";
import { visit } from "@codama/visitors-core";
import { getBase64Decoder } from "@solana/codecs-strings";
function getDiscriminatorConditionFragment(scope) {
  return mergeFragments(
    scope.discriminators.flatMap((discriminator) => {
      if (isNode3(discriminator, "sizeDiscriminatorNode")) {
        return [getSizeConditionFragment(discriminator, scope)];
      }
      if (isNode3(discriminator, "constantDiscriminatorNode")) {
        return [getByteConditionFragment(discriminator, scope)];
      }
      if (isNode3(discriminator, "fieldDiscriminatorNode")) {
        return [getFieldConditionFragment(discriminator, scope)];
      }
      return [];
    }),
    (r) => r.join(" && ")
  ).mapRender((r) => `if (${r}) { ${scope.ifTrue}; }`);
}
function getSizeConditionFragment(discriminator, scope) {
  const { dataName } = scope;
  return fragment(`${dataName}.length === ${discriminator.size}`);
}
function getByteConditionFragment(discriminator, scope) {
  const { dataName, typeManifestVisitor } = scope;
  const constant = visit(discriminator.constant, typeManifestVisitor).value;
  return constant.mapRender((r) => `containsBytes(${dataName}, ${r}, ${discriminator.offset})`).addImports("solanaCodecsCore", "containsBytes");
}
function getFieldConditionFragment(discriminator, scope) {
  const field = scope.struct.fields.find((f) => f.name === discriminator.name);
  if (!field || !field.defaultValue) {
    throw new Error(
      `Field discriminator "${discriminator.name}" does not have a matching argument with default value.`
    );
  }
  if (isNode3(field.type, "arrayTypeNode") && isNode3(field.type.item, "numberTypeNode") && field.type.item.format === "u8" && isNode3(field.type.count, "fixedCountNode") && isNode3(field.defaultValue, "arrayValueNode") && field.defaultValue.items.every(isNodeFilter2("numberValueNode"))) {
    const base64Bytes = getBase64Decoder().decode(
      new Uint8Array(field.defaultValue.items.map((node) => node.number))
    );
    return getByteConditionFragment(
      constantDiscriminatorNode(constantValueNodeFromBytes("base64", base64Bytes), discriminator.offset),
      scope
    );
  }
  return getByteConditionFragment(
    constantDiscriminatorNode(constantValueNode(field.type, field.defaultValue), discriminator.offset),
    scope
  );
}

// src/fragments/instructionAccountMeta.ts
import { pascalCase as pascalCase2 } from "@codama/nodes";
function getInstructionAccountMetaFragment(instructionAccountNode) {
  const typeParam = `TAccount${pascalCase2(instructionAccountNode.name)}`;
  if (instructionAccountNode.isSigner === true && instructionAccountNode.isWritable) {
    return fragment(`WritableSignerAccount<${typeParam}> & IAccountSignerMeta<${typeParam}>`).addImports("solanaInstructions", ["type WritableSignerAccount"]).addImports("solanaSigners", ["type IAccountSignerMeta"]);
  }
  if (instructionAccountNode.isSigner === true) {
    return fragment(`ReadonlySignerAccount<${typeParam}> & IAccountSignerMeta<${typeParam}>`).addImports("solanaInstructions", ["type ReadonlySignerAccount"]).addImports("solanaSigners", ["type IAccountSignerMeta"]);
  }
  if (instructionAccountNode.isWritable) {
    return fragment(`WritableAccount<${typeParam}>`).addImports("solanaInstructions", "type WritableAccount");
  }
  return fragment(`ReadonlyAccount<${typeParam}>`).addImports("solanaInstructions", "type ReadonlyAccount");
}

// src/fragments/instructionAccountTypeParam.ts
import { pascalCase as pascalCase3 } from "@codama/nodes";
import {
  findInstructionNodeFromPath,
  findProgramNodeFromPath as findProgramNodeFromPath2,
  getLastNodeFromPath as getLastNodeFromPath5
} from "@codama/visitors-core";
function getInstructionAccountTypeParamFragment(scope) {
  const { instructionAccountPath, allowAccountMeta, linkables } = scope;
  const instructionAccountNode = getLastNodeFromPath5(instructionAccountPath);
  const instructionNode = findInstructionNodeFromPath(instructionAccountPath);
  const programNode = findProgramNodeFromPath2(instructionAccountPath);
  const typeParam = `TAccount${pascalCase3(instructionAccountNode.name)}`;
  const accountMeta = allowAccountMeta ? " | IAccountMeta<string>" : "";
  const imports = new ImportMap();
  if (allowAccountMeta) {
    imports.add("solanaInstructions", "type IAccountMeta");
  }
  if (instructionNode.optionalAccountStrategy === "omitted" && instructionAccountNode.isOptional) {
    return fragment(`${typeParam} extends string${accountMeta} | undefined = undefined`, imports);
  }
  const defaultAddress = getDefaultAddress(instructionAccountNode.defaultValue, programNode.publicKey, linkables);
  return fragment(`${typeParam} extends string${accountMeta} = ${defaultAddress}`, imports);
}
function getDefaultAddress(defaultValue, programId, linkables) {
  switch (defaultValue?.kind) {
    case "publicKeyValueNode":
      return `"${defaultValue.publicKey}"`;
    case "programLinkNode":
      const programNode = linkables.get([defaultValue]);
      return programNode ? `"${programNode.publicKey}"` : "string";
    case "programIdValueNode":
      return `"${programId}"`;
    default:
      return "string";
  }
}

// src/fragments/instructionByteDelta.ts
import { assertIsNode, camelCase as camelCase3, isNode as isNode4 } from "@codama/nodes";
import { getLastNodeFromPath as getLastNodeFromPath6 } from "@codama/visitors-core";
function getInstructionByteDeltaFragment(scope) {
  const { byteDeltas } = getLastNodeFromPath6(scope.instructionPath);
  const fragments = (byteDeltas ?? []).flatMap((r) => getByteDeltaFragment(r, scope));
  if (fragments.length === 0) return fragment("");
  return mergeFragments(
    fragments,
    (r) => `// Bytes created or reallocated by the instruction.
const byteDelta: number = [${r.join(",")}].reduce((a, b) => a + b, 0);`
  );
}
function getByteDeltaFragment(byteDelta, scope) {
  const bytesFragment = (() => {
    if (isNode4(byteDelta.value, "numberValueNode")) {
      return getNumberValueNodeFragment(byteDelta);
    }
    if (isNode4(byteDelta.value, "argumentValueNode")) {
      return getArgumentValueNodeFragment(byteDelta);
    }
    if (isNode4(byteDelta.value, "accountLinkNode")) {
      return getAccountLinkNodeFragment(byteDelta, scope);
    }
    if (isNode4(byteDelta.value, "resolverValueNode")) {
      return getResolverValueNodeFragment(byteDelta, scope);
    }
    return null;
  })();
  if (bytesFragment === null) return [];
  if (byteDelta.withHeader) {
    bytesFragment.mapRender((r) => `${r} + BASE_ACCOUNT_SIZE`).addImports("solanaAccounts", "BASE_ACCOUNT_SIZE");
  }
  if (byteDelta.subtract) {
    bytesFragment.mapRender((r) => `- (${r})`);
  }
  return [bytesFragment];
}
function getNumberValueNodeFragment(byteDelta) {
  assertIsNode(byteDelta.value, "numberValueNode");
  return fragment(byteDelta.value.number.toString());
}
function getArgumentValueNodeFragment(byteDelta) {
  assertIsNode(byteDelta.value, "argumentValueNode");
  const argumentName = camelCase3(byteDelta.value.name);
  return fragment(`Number(args.${argumentName})`);
}
function getAccountLinkNodeFragment(byteDelta, scope) {
  assertIsNode(byteDelta.value, "accountLinkNode");
  const functionName = scope.nameApi.accountGetSizeFunction(byteDelta.value.name);
  return fragment(`${functionName}()`).addImports(scope.getImportFrom(byteDelta.value), functionName);
}
function getResolverValueNodeFragment(byteDelta, scope) {
  assertIsNode(byteDelta.value, "resolverValueNode");
  const isAsync = scope.asyncResolvers.includes(byteDelta.value.name);
  if (!scope.useAsync && isAsync) return null;
  const awaitKeyword = scope.useAsync && isAsync ? "await " : "";
  const functionName = scope.nameApi.resolverFunction(byteDelta.value.name);
  return fragment(`${awaitKeyword}${functionName}(resolverScope)`).addImports(scope.getImportFrom(byteDelta.value), functionName).addFeatures(["instruction:resolverScopeVariable"]);
}

// src/fragments/instructionData.ts
import { getLastNodeFromPath as getLastNodeFromPath7 } from "@codama/visitors-core";
function getInstructionDataFragment(scope) {
  const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;
  const instructionNode = getLastNodeFromPath7(instructionPath);
  if (instructionNode.arguments.length === 0 || customInstructionData.has(instructionNode.name)) {
    return fragment("");
  }
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  return getTypeWithCodecFragment({
    manifest: dataArgsManifest,
    name: instructionDataName,
    nameApi
  });
}

// src/fragments/discriminatorConstants.ts
import {
  camelCase as camelCase4,
  isNode as isNode5,
  isNodeFilter as isNodeFilter3,
  VALUE_NODES
} from "@codama/nodes";
import { visit as visit2 } from "@codama/visitors-core";
function getDiscriminatorConstantsFragment(scope) {
  const fragments = scope.discriminatorNodes.map((node) => getDiscriminatorConstantFragment(node, scope)).filter(Boolean);
  return mergeFragments(fragments, (r) => r.join("\n\n"));
}
function getDiscriminatorConstantFragment(discriminatorNode, scope) {
  switch (discriminatorNode.kind) {
    case "constantDiscriminatorNode":
      return getConstantDiscriminatorConstantFragment(discriminatorNode, scope);
    case "fieldDiscriminatorNode":
      return getFieldDiscriminatorConstantFragment(discriminatorNode, scope);
    default:
      return null;
  }
}
function getConstantDiscriminatorConstantFragment(discriminatorNode, scope) {
  const { discriminatorNodes, typeManifestVisitor, prefix } = scope;
  const index = discriminatorNodes.filter(isNodeFilter3("constantDiscriminatorNode")).indexOf(discriminatorNode);
  const suffix = index <= 0 ? "" : `_${index + 1}`;
  const name = camelCase4(`${prefix}_discriminator${suffix}`);
  const encoder = visit2(discriminatorNode.constant.type, typeManifestVisitor).encoder;
  const value = visit2(discriminatorNode.constant.value, typeManifestVisitor).value;
  return getConstantFragment({ ...scope, encoder, name, value });
}
function getFieldDiscriminatorConstantFragment(discriminatorNode, scope) {
  const { fields, prefix, typeManifestVisitor } = scope;
  const field = fields.find((f) => f.name === discriminatorNode.name);
  if (!field || !field.defaultValue || !isNode5(field.defaultValue, VALUE_NODES)) {
    return null;
  }
  const name = camelCase4(`${prefix}_${discriminatorNode.name}`);
  const encoder = visit2(field.type, typeManifestVisitor).encoder;
  const value = visit2(field.defaultValue, typeManifestVisitor).value;
  return getConstantFragment({ ...scope, encoder, name, value });
}
function getConstantFragment(scope) {
  const { encoder, name, nameApi, value } = scope;
  const constantName = nameApi.constant(name);
  const constantFunction = nameApi.constantFunction(name);
  return mergeFragments(
    [
      value.mapRender((r) => `export const ${constantName} = ${r};`),
      encoder.mapRender((r) => `export function ${constantFunction}() { return ${r}.encode(${constantName}); }`)
    ],
    (r) => r.join("\n\n")
  );
}

// src/fragments/instructionExtraArgs.ts
import { getLastNodeFromPath as getLastNodeFromPath8 } from "@codama/visitors-core";
function getInstructionExtraArgsFragment(scope) {
  const { instructionPath, extraArgsManifest, nameApi } = scope;
  const instructionNode = getLastNodeFromPath8(instructionPath);
  if ((instructionNode.extraArguments ?? []).length === 0) {
    return fragment("");
  }
  const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);
  return fragmentFromTemplate("instructionExtraArgs.njk", {
    looseName: nameApi.dataArgsType(instructionExtraName),
    manifest: extraArgsManifest,
    strictName: nameApi.dataType(instructionExtraName)
  }).mergeImportsWith(extraArgsManifest.looseType);
}

// src/fragments/instructionFunction.ts
import { camelCase as camelCase9, isNode as isNode10, isNodeFilter as isNodeFilter4, pascalCase as pascalCase5 } from "@codama/nodes";
import {
  findProgramNodeFromPath as findProgramNodeFromPath3,
  getLastNodeFromPath as getLastNodeFromPath12
} from "@codama/visitors-core";

// src/fragments/instructionInputResolved.ts
import { camelCase as camelCase6, isNode as isNode7, parseOptionalAccountStrategy } from "@codama/nodes";
import { getLastNodeFromPath as getLastNodeFromPath9 } from "@codama/visitors-core";

// src/fragments/instructionInputDefault.ts
import { camelCase as camelCase5, isNode as isNode6 } from "@codama/nodes";
import { visit as visit3 } from "@codama/visitors-core";
function getInstructionInputDefaultFragment(scope) {
  const { input, optionalAccountStrategy, asyncResolvers, useAsync, nameApi, typeManifestVisitor, getImportFrom } = scope;
  if (!input.defaultValue) {
    return fragment("");
  }
  if (!useAsync && isAsyncDefaultValue(input.defaultValue, asyncResolvers)) {
    return fragment("");
  }
  const { defaultValue } = input;
  const defaultFragment = (renderedValue, isWritable) => {
    const inputName = camelCase5(input.name);
    if (input.kind === "instructionAccountNode" && isNode6(defaultValue, "resolverValueNode")) {
      return fragment(`accounts.${inputName} = { ...accounts.${inputName}, ...${renderedValue} };`);
    }
    if (input.kind === "instructionAccountNode" && isWritable === void 0) {
      return fragment(`accounts.${inputName}.value = ${renderedValue};`);
    }
    if (input.kind === "instructionAccountNode") {
      return fragment(
        `accounts.${inputName}.value = ${renderedValue};
accounts.${inputName}.isWritable = ${isWritable ? "true" : "false"}`
      );
    }
    return fragment(`args.${inputName} = ${renderedValue};`);
  };
  switch (defaultValue.kind) {
    case "accountValueNode":
      const name = camelCase5(defaultValue.name);
      if (input.kind === "instructionAccountNode" && input.resolvedIsSigner && !input.isSigner) {
        return defaultFragment(`expectTransactionSigner(accounts.${name}.value).address`).addImports(
          "shared",
          "expectTransactionSigner"
        );
      }
      if (input.kind === "instructionAccountNode") {
        return defaultFragment(`expectSome(accounts.${name}.value)`).addImports("shared", "expectSome");
      }
      return defaultFragment(`expectAddress(accounts.${name}.value)`).addImports("shared", "expectAddress");
    case "pdaValueNode":
      if (isNode6(defaultValue.pda, "pdaNode")) {
        const pdaProgram = defaultValue.pda.programId ? fragment(
          `'${defaultValue.pda.programId}' as Address<'${defaultValue.pda.programId}'>`
        ).addImports("solanaAddresses", "type Address") : fragment("programAddress");
        const pdaSeeds2 = defaultValue.pda.seeds.flatMap((seed) => {
          if (isNode6(seed, "constantPdaSeedNode") && isNode6(seed.value, "programIdValueNode")) {
            return [
              fragment(`getAddressEncoder().encode(${pdaProgram.render})`).mergeImportsWith(pdaProgram).addImports("solanaAddresses", "getAddressEncoder")
            ];
          }
          if (isNode6(seed, "constantPdaSeedNode") && !isNode6(seed.value, "programIdValueNode")) {
            const typeManifest2 = visit3(seed.type, typeManifestVisitor);
            const valueManifest2 = visit3(seed.value, typeManifestVisitor);
            return [
              fragment(
                `${typeManifest2.encoder.render}.encode(${valueManifest2.value.render})`
              ).mergeImportsWith(typeManifest2.encoder, valueManifest2.value)
            ];
          }
          if (isNode6(seed, "variablePdaSeedNode")) {
            const typeManifest2 = visit3(seed.type, typeManifestVisitor);
            const valueSeed = defaultValue.seeds.find((s) => s.name === seed.name)?.value;
            if (!valueSeed) return [];
            if (isNode6(valueSeed, "accountValueNode")) {
              return [
                fragment(
                  `${typeManifest2.encoder.render}.encode(expectAddress(accounts.${camelCase5(valueSeed.name)}.value))`
                ).mergeImportsWith(typeManifest2.encoder).addImports("shared", "expectAddress")
              ];
            }
            if (isNode6(valueSeed, "argumentValueNode")) {
              return [
                fragment(
                  `${typeManifest2.encoder.render}.encode(expectSome(args.${camelCase5(valueSeed.name)}))`
                ).mergeImportsWith(typeManifest2.encoder).addImports("shared", "expectSome")
              ];
            }
            const valueManifest2 = visit3(valueSeed, typeManifestVisitor);
            return [
              fragment(
                `${typeManifest2.encoder.render}.encode(${valueManifest2.value.render})`
              ).mergeImportsWith(typeManifest2.encoder, valueManifest2.value)
            ];
          }
          return [];
        });
        const pdaStatement = mergeFragments([pdaProgram, ...pdaSeeds2], ([p, ...s]) => {
          const programAddress2 = p === "programAddress" ? p : `programAddress: ${p}`;
          return `await getProgramDerivedAddress({ ${programAddress2}, seeds: [${s.join(", ")}] })`;
        }).addImports("solanaAddresses", "getProgramDerivedAddress");
        return defaultFragment(pdaStatement.render).mergeImportsWith(pdaStatement);
      }
      const pdaFunction = nameApi.pdaFindFunction(defaultValue.pda.name);
      const pdaArgs = [];
      const pdaSeeds = defaultValue.seeds.map((seed) => {
        if (isNode6(seed.value, "accountValueNode")) {
          return fragment(
            `${seed.name}: expectAddress(accounts.${camelCase5(seed.value.name)}.value)`
          ).addImports("shared", "expectAddress");
        }
        if (isNode6(seed.value, "argumentValueNode")) {
          return fragment(`${seed.name}: expectSome(args.${camelCase5(seed.value.name)})`).addImports(
            "shared",
            "expectSome"
          );
        }
        return visit3(seed.value, typeManifestVisitor).value.mapRender((r) => `${seed.name}: ${r}`);
      });
      const pdaSeedsFragment = mergeFragments(pdaSeeds, (renders) => renders.join(", ")).mapRender((r) => `{ ${r} }`);
      if (pdaSeeds.length > 0) {
        pdaArgs.push(pdaSeedsFragment.render);
      }
      return defaultFragment(`await ${pdaFunction}(${pdaArgs.join(", ")})`).mergeImportsWith(pdaSeedsFragment).addImports(getImportFrom(defaultValue.pda), pdaFunction);
    case "publicKeyValueNode":
      return defaultFragment(`'${defaultValue.publicKey}' as Address<'${defaultValue.publicKey}'>`).addImports(
        "solanaAddresses",
        "type Address"
      );
    case "programLinkNode":
      const programAddress = nameApi.programAddressConstant(defaultValue.name);
      return defaultFragment(programAddress, false).addImports(getImportFrom(defaultValue), programAddress);
    case "programIdValueNode":
      if (optionalAccountStrategy === "programId" && input.kind === "instructionAccountNode" && input.isOptional) {
        return fragment("");
      }
      return defaultFragment("programAddress", false);
    case "identityValueNode":
    case "payerValueNode":
      return fragment("");
    case "accountBumpValueNode":
      return defaultFragment(
        `expectProgramDerivedAddress(accounts.${camelCase5(defaultValue.name)}.value)[1]`
      ).addImports("shared", "expectProgramDerivedAddress");
    case "argumentValueNode":
      return defaultFragment(`expectSome(args.${camelCase5(defaultValue.name)})`).addImports(
        "shared",
        "expectSome"
      );
    case "resolverValueNode":
      const resolverFunction = nameApi.resolverFunction(defaultValue.name);
      const resolverAwait = useAsync && asyncResolvers.includes(defaultValue.name) ? "await " : "";
      return defaultFragment(`${resolverAwait}${resolverFunction}(resolverScope)`).addImports(getImportFrom(defaultValue), resolverFunction).addFeatures(["instruction:resolverScopeVariable"]);
    case "conditionalValueNode":
      const ifTrueRenderer = renderNestedInstructionDefault({
        ...scope,
        defaultValue: defaultValue.ifTrue
      });
      const ifFalseRenderer = renderNestedInstructionDefault({
        ...scope,
        defaultValue: defaultValue.ifFalse
      });
      if (!ifTrueRenderer && !ifFalseRenderer) {
        return fragment("");
      }
      const conditionalFragment = fragment("");
      if (ifTrueRenderer) {
        conditionalFragment.mergeImportsWith(ifTrueRenderer).mergeFeaturesWith(ifTrueRenderer);
      }
      if (ifFalseRenderer) {
        conditionalFragment.mergeImportsWith(ifFalseRenderer).mergeFeaturesWith(ifFalseRenderer);
      }
      const negatedCondition = !ifTrueRenderer;
      let condition = "true";
      if (isNode6(defaultValue.condition, "resolverValueNode")) {
        const conditionalResolverFunction = nameApi.resolverFunction(defaultValue.condition.name);
        conditionalFragment.addImports(getImportFrom(defaultValue.condition), conditionalResolverFunction).addFeatures(["instruction:resolverScopeVariable"]);
        const conditionalResolverAwait = useAsync && asyncResolvers.includes(defaultValue.condition.name) ? "await " : "";
        condition = `${conditionalResolverAwait}${conditionalResolverFunction}(resolverScope)`;
        condition = negatedCondition ? `!${condition}` : condition;
      } else {
        const comparedInputName = isNode6(defaultValue.condition, "accountValueNode") ? `accounts.${camelCase5(defaultValue.condition.name)}.value` : `args.${camelCase5(defaultValue.condition.name)}`;
        if (defaultValue.value) {
          const comparedValue = visit3(defaultValue.value, typeManifestVisitor).value;
          conditionalFragment.mergeImportsWith(comparedValue).mergeFeaturesWith(comparedValue);
          const operator = negatedCondition ? "!==" : "===";
          condition = `${comparedInputName} ${operator} ${comparedValue.render}`;
        } else {
          condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;
        }
      }
      if (ifTrueRenderer && ifFalseRenderer) {
        return conditionalFragment.setRender(
          `if (${condition}) {
${ifTrueRenderer.render}
} else {
${ifFalseRenderer.render}
}`
        );
      }
      return conditionalFragment.setRender(
        `if (${condition}) {
${ifTrueRenderer ? ifTrueRenderer.render : ifFalseRenderer?.render}
}`
      );
    default:
      const valueManifest = visit3(defaultValue, typeManifestVisitor).value;
      return defaultFragment(valueManifest.render).mergeImportsWith(valueManifest);
  }
}
function renderNestedInstructionDefault(scope) {
  const { input, defaultValue } = scope;
  if (!defaultValue) return void 0;
  return getInstructionInputDefaultFragment({
    ...scope,
    input: { ...input, defaultValue }
  });
}

// src/fragments/instructionInputResolved.ts
function getInstructionInputResolvedFragment(scope) {
  const instructionNode = getLastNodeFromPath9(scope.instructionPath);
  const resolvedInputFragments = scope.resolvedInputs.flatMap((input) => {
    const inputFragment = getInstructionInputDefaultFragment({
      ...scope,
      input,
      optionalAccountStrategy: parseOptionalAccountStrategy(instructionNode.optionalAccountStrategy)
    });
    if (!inputFragment.render) return [];
    const camelName = camelCase6(input.name);
    return [
      inputFragment.mapRender(
        (r) => isNode7(input, "instructionArgumentNode") ? `if (!args.${camelName}) {
${r}
}` : `if (!accounts.${camelName}.value) {
${r}
}`
      )
    ];
  });
  if (resolvedInputFragments.length === 0) {
    return fragment("");
  }
  return mergeFragments(
    [fragment("// Resolve default values."), ...resolvedInputFragments],
    (renders) => renders.join("\n")
  );
}

// src/fragments/instructionInputType.ts
import {
  camelCase as camelCase7,
  getAllInstructionArguments,
  isNode as isNode8,
  parseDocs,
  pascalCase as pascalCase4
} from "@codama/nodes";
import {
  getLastNodeFromPath as getLastNodeFromPath10
} from "@codama/visitors-core";
function getInstructionInputTypeFragment(scope) {
  const { instructionPath, useAsync, nameApi } = scope;
  const instructionNode = getLastNodeFromPath10(instructionPath);
  const instructionInputType = useAsync ? nameApi.instructionAsyncInputType(instructionNode.name) : nameApi.instructionSyncInputType(instructionNode.name);
  const accountsFragment = getAccountsFragment(scope);
  const [dataArgumentsFragment, customDataArgumentsFragment] = getDataArgumentsFragments(scope);
  const extraArgumentsFragment = getExtraArgumentsFragment(scope);
  const remainingAccountsFragment = getRemainingAccountsFragment(instructionNode);
  return fragmentFromTemplate("instructionInputType.njk", {
    accountsFragment,
    customDataArgumentsFragment,
    dataArgumentsFragment,
    extraArgumentsFragment,
    instruction: instructionNode,
    instructionInputType,
    remainingAccountsFragment
  }).mergeImportsWith(
    accountsFragment,
    dataArgumentsFragment,
    customDataArgumentsFragment,
    extraArgumentsFragment,
    remainingAccountsFragment
  ).addImports("solanaAddresses", ["type Address"]);
}
function getAccountsFragment(scope) {
  const { instructionPath, resolvedInputs, useAsync, asyncResolvers } = scope;
  const instructionNode = getLastNodeFromPath10(instructionPath);
  const fragments = instructionNode.accounts.map((account) => {
    const resolvedAccount = resolvedInputs.find(
      (input) => input.kind === "instructionAccountNode" && input.name === account.name
    );
    const hasDefaultValue = !!resolvedAccount.defaultValue && !isNode8(resolvedAccount.defaultValue, ["identityValueNode", "payerValueNode"]) && (useAsync || !isAsyncDefaultValue(resolvedAccount.defaultValue, asyncResolvers));
    const accountDocs = parseDocs(account.docs);
    const docblock = accountDocs.length > 0 ? jsDocblock(accountDocs) : "";
    const optionalSign = hasDefaultValue || resolvedAccount.isOptional ? "?" : "";
    return getAccountTypeFragment2(resolvedAccount).mapRender(
      (r) => `${docblock}${camelCase7(account.name)}${optionalSign}: ${r};`
    );
  });
  return mergeFragments(fragments, (r) => r.join("\n"));
}
function getAccountTypeFragment2(account) {
  const typeParam = `TAccount${pascalCase4(account.name)}`;
  if (account.isPda && account.isSigner === false) {
    return fragment(`ProgramDerivedAddress<${typeParam}>`).addImports("solanaAddresses", [
      "type ProgramDerivedAddress"
    ]);
  }
  if (account.isPda && account.isSigner === "either") {
    return fragment(`ProgramDerivedAddress<${typeParam}> | TransactionSigner<${typeParam}>`).addImports("solanaAddresses", ["type ProgramDerivedAddress"]).addImports("solanaSigners", ["type TransactionSigner"]);
  }
  if (account.isSigner === "either") {
    return fragment(`Address<${typeParam}> | TransactionSigner<${typeParam}>`).addImports("solanaAddresses", ["type Address"]).addImports("solanaSigners", ["type TransactionSigner"]);
  }
  if (account.isSigner) {
    return fragment(`TransactionSigner<${typeParam}>`).addImports("solanaSigners", ["type TransactionSigner"]);
  }
  return fragment(`Address<${typeParam}>`).addImports("solanaAddresses", ["type Address"]);
}
function getDataArgumentsFragments(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = getLastNodeFromPath10(instructionPath);
  const customData = scope.customInstructionData.get(instructionNode.name);
  if (customData) {
    return [
      fragment(""),
      fragment(nameApi.dataArgsType(customData.importAs)).mergeImportsWith(scope.dataArgsManifest.looseType).mapRender((r) => `${r} & `)
    ];
  }
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const dataArgsType = nameApi.dataArgsType(instructionDataName);
  const fragments = instructionNode.arguments.flatMap((arg) => {
    const argFragment = getArgumentFragment(arg, fragment(dataArgsType), scope.resolvedInputs, scope.renamedArgs);
    return argFragment ? [argFragment] : [];
  });
  return [mergeFragments(fragments, (r) => r.join("\n")), fragment("")];
}
function getExtraArgumentsFragment(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = getLastNodeFromPath10(instructionPath);
  const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);
  const extraArgsType = nameApi.dataArgsType(instructionExtraName);
  const fragments = (instructionNode.extraArguments ?? []).flatMap((arg) => {
    const argFragment = getArgumentFragment(arg, fragment(extraArgsType), scope.resolvedInputs, scope.renamedArgs);
    return argFragment ? [argFragment] : [];
  });
  return mergeFragments(fragments, (r) => r.join("\n"));
}
function getArgumentFragment(arg, argsType, resolvedInputs, renamedArgs) {
  const resolvedArg = resolvedInputs.find(
    (input) => isNode8(input, "instructionArgumentNode") && input.name === arg.name
  );
  if (arg.defaultValue && arg.defaultValueStrategy === "omitted") return null;
  const renamedName = renamedArgs.get(arg.name) ?? arg.name;
  const optionalSign = arg.defaultValue || resolvedArg?.defaultValue ? "?" : "";
  return argsType.mapRender((r) => `${camelCase7(renamedName)}${optionalSign}: ${r}["${camelCase7(arg.name)}"];`);
}
function getRemainingAccountsFragment(instructionNode) {
  const fragments = (instructionNode.remainingAccounts ?? []).flatMap((remainingAccountsNode) => {
    if (isNode8(remainingAccountsNode.value, "resolverValueNode")) return [];
    const { name } = remainingAccountsNode.value;
    const allArguments = getAllInstructionArguments(instructionNode);
    const argumentExists = allArguments.some((arg) => arg.name === name);
    if (argumentExists) return [];
    const isSigner = remainingAccountsNode.isSigner ?? false;
    const optionalSign = remainingAccountsNode.isOptional ?? false ? "?" : "";
    const signerFragment = fragment(`TransactionSigner`).addImports("solanaSigners", ["type TransactionSigner"]);
    const addressFragment = fragment(`Address`).addImports("solanaAddresses", ["type Address"]);
    return (() => {
      if (isSigner === "either") {
        return mergeFragments([signerFragment, addressFragment], (r) => r.join(" | "));
      }
      return isSigner ? signerFragment : addressFragment;
    })().mapRender((r) => `${camelCase7(name)}${optionalSign}: Array<${r}>;`);
  });
  return mergeFragments(fragments, (r) => r.join("\n"));
}

// src/fragments/instructionRemainingAccounts.ts
import {
  assertIsNode as assertIsNode2,
  camelCase as camelCase8,
  getAllInstructionArguments as getAllInstructionArguments2,
  isNode as isNode9
} from "@codama/nodes";
import { getLastNodeFromPath as getLastNodeFromPath11 } from "@codama/visitors-core";
function getInstructionRemainingAccountsFragment(scope) {
  const { remainingAccounts } = getLastNodeFromPath11(scope.instructionPath);
  const fragments = (remainingAccounts ?? []).flatMap((r) => getRemainingAccountsFragment2(r, scope));
  if (fragments.length === 0) return fragment("");
  return mergeFragments(
    fragments,
    (r) => `// Remaining accounts.
const remainingAccounts: IAccountMeta[] = ${r.length === 1 ? r[0] : `[...${r.join(", ...")}]`}`
  ).addImports("solanaInstructions", ["type IAccountMeta"]);
}
function getRemainingAccountsFragment2(remainingAccounts, scope) {
  const remainingAccountsFragment = (() => {
    if (isNode9(remainingAccounts.value, "argumentValueNode")) {
      return getArgumentValueNodeFragment2(remainingAccounts, scope);
    }
    if (isNode9(remainingAccounts.value, "resolverValueNode")) {
      return getResolverValueNodeFragment2(remainingAccounts, scope);
    }
    return null;
  })();
  if (remainingAccountsFragment === null) return [];
  return [remainingAccountsFragment];
}
function getArgumentValueNodeFragment2(remainingAccounts, scope) {
  const instructionNode = getLastNodeFromPath11(scope.instructionPath);
  assertIsNode2(remainingAccounts.value, "argumentValueNode");
  const argumentName = camelCase8(remainingAccounts.value.name);
  const isOptional = remainingAccounts.isOptional ?? false;
  const isSigner = remainingAccounts.isSigner ?? false;
  const isWritable = remainingAccounts.isWritable ?? false;
  const nonSignerRole = isWritable ? "AccountRole.WRITABLE" : "AccountRole.READONLY";
  const signerRole = isWritable ? "AccountRole.WRITABLE_SIGNER" : "AccountRole.READONLY_SIGNER";
  const role = isSigner === true ? signerRole : nonSignerRole;
  const argumentArray = isOptional ? `(args.${argumentName} ?? [])` : `args.${argumentName}`;
  const allArguments = getAllInstructionArguments2(instructionNode);
  const argumentExists = allArguments.some((arg) => arg.name === remainingAccounts.value.name);
  if (argumentExists || isSigner === false) {
    return fragment(`${argumentArray}.map((address) => ({ address, role: ${role} }))`).addImports(
      "solanaInstructions",
      ["AccountRole"]
    );
  }
  if (isSigner === "either") {
    return fragment(
      `${argumentArray}.map((addressOrSigner) => (isTransactionSigner(addressOrSigner)
? { address: addressOrSigner.address, role: ${role}, signer: addressOrSigner }
: { address: addressOrSigner, role: ${role} }
))`
    ).addImports("solanaInstructions", ["AccountRole"]).addImports("shared", ["isTransactionSigner"]);
  }
  return fragment(
    `${argumentArray}.map((signer) => ({ address: signer.address, role: ${signerRole}, signer }))`
  ).addImports("solanaInstructions", ["AccountRole"]);
}
function getResolverValueNodeFragment2(remainingAccounts, scope) {
  assertIsNode2(remainingAccounts.value, "resolverValueNode");
  const isAsync = scope.asyncResolvers.includes(remainingAccounts.value.name);
  if (!scope.useAsync && isAsync) return null;
  const awaitKeyword = scope.useAsync && isAsync ? "await " : "";
  const functionName = scope.nameApi.resolverFunction(remainingAccounts.value.name);
  return fragment(`${awaitKeyword}${functionName}(resolverScope)`).addImports(scope.getImportFrom(remainingAccounts.value), functionName).addFeatures(["instruction:resolverScopeVariable"]);
}

// src/fragments/instructionFunction.ts
function getInstructionFunctionFragment(scope) {
  const {
    useAsync,
    instructionPath,
    resolvedInputs,
    renamedArgs,
    dataArgsManifest,
    asyncResolvers,
    nameApi,
    customInstructionData
  } = scope;
  const instructionNode = getLastNodeFromPath12(instructionPath);
  const programNode = findProgramNodeFromPath3(instructionPath);
  if (useAsync && !hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers)) {
    return fragment("");
  }
  const customData = customInstructionData.get(instructionNode.name);
  const hasAccounts = instructionNode.accounts.length > 0;
  const hasLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === "omitted" && instructionNode.accounts.some((account) => account.isOptional);
  const instructionDependencies = getInstructionDependencies(instructionNode, asyncResolvers, useAsync);
  const argDependencies = instructionDependencies.filter(isNodeFilter4("argumentValueNode")).map((node) => node.name);
  const hasData = !!customData || instructionNode.arguments.length > 0;
  const argIsNotOmitted = (arg) => !(arg.defaultValue && arg.defaultValueStrategy === "omitted");
  const argIsDependent = (arg) => argDependencies.includes(arg.name);
  const argHasDefaultValue = (arg) => {
    if (!arg.defaultValue) return false;
    if (useAsync) return true;
    return !isAsyncDefaultValue(arg.defaultValue, asyncResolvers);
  };
  const hasDataArgs = !!customData || instructionNode.arguments.filter(argIsNotOmitted).length > 0;
  const hasExtraArgs = (instructionNode.extraArguments ?? []).filter(
    (field) => argIsNotOmitted(field) && (argIsDependent(field) || argHasDefaultValue(field))
  ).length > 0;
  const hasRemainingAccountArgs = (instructionNode.remainingAccounts ?? []).filter(({ value }) => isNode10(value, "argumentValueNode")).length > 0;
  const hasAnyArgs = hasDataArgs || hasExtraArgs || hasRemainingAccountArgs;
  const hasInput = hasAccounts || hasAnyArgs;
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const programAddressConstant = nameApi.programAddressConstant(programNode.name);
  const encoderFunction = customData ? dataArgsManifest.encoder.render : `${nameApi.encoderFunction(instructionDataName)}()`;
  const argsTypeFragment = fragment(
    customData ? dataArgsManifest.looseType.render : nameApi.dataArgsType(instructionDataName)
  );
  if (customData) {
    argsTypeFragment.mergeImportsWith(dataArgsManifest.looseType, dataArgsManifest.encoder);
  }
  const functionName = useAsync ? nameApi.instructionAsyncFunction(instructionNode.name) : nameApi.instructionSyncFunction(instructionNode.name);
  const typeParamsFragment = getTypeParams(instructionNode, programAddressConstant);
  const instructionTypeFragment = getInstructionType(scope);
  const inputTypeFragment = getInstructionInputTypeFragment(scope);
  const inputTypeCallFragment = getInputTypeCall(scope);
  const renamedArgsText = [...renamedArgs.entries()].map(([k, v]) => `${k}: input.${v}`).join(", ");
  const resolvedInputsFragment = getInstructionInputResolvedFragment(scope);
  const remainingAccountsFragment = getInstructionRemainingAccountsFragment(scope);
  const byteDeltaFragment = getInstructionByteDeltaFragment(scope);
  const resolvedFragment = mergeFragments(
    [resolvedInputsFragment, remainingAccountsFragment, byteDeltaFragment],
    (renders) => renders.join("\n\n")
  );
  const hasRemainingAccounts = remainingAccountsFragment.render !== "";
  const hasByteDeltas = byteDeltaFragment.render !== "";
  const hasResolver = resolvedFragment.hasFeatures("instruction:resolverScopeVariable");
  const getReturnType = (instructionType) => {
    let returnType = instructionType;
    if (hasByteDeltas) {
      returnType = `${returnType} & IInstructionWithByteDelta`;
    }
    return useAsync ? `Promise<${returnType}>` : returnType;
  };
  const functionFragment = fragmentFromTemplate("instructionFunction.njk", {
    argsTypeFragment,
    encoderFunction,
    functionName,
    getReturnType,
    hasAccounts,
    hasAnyArgs,
    hasByteDeltas,
    hasData,
    hasDataArgs,
    hasExtraArgs,
    hasInput,
    hasLegacyOptionalAccounts,
    hasRemainingAccounts,
    hasResolver,
    inputTypeCallFragment,
    inputTypeFragment,
    instruction: instructionNode,
    instructionTypeFragment,
    programAddressConstant,
    renamedArgs: renamedArgsText,
    resolvedFragment,
    typeParamsFragment,
    useAsync
  }).mergeImportsWith(
    typeParamsFragment,
    instructionTypeFragment,
    inputTypeFragment,
    inputTypeCallFragment,
    resolvedFragment,
    argsTypeFragment
  ).addImports("generatedPrograms", [programAddressConstant]).addImports("solanaAddresses", ["type Address"]);
  if (hasAccounts) {
    functionFragment.addImports("solanaInstructions", ["type IAccountMeta"]).addImports("shared", ["getAccountMetaFactory", "type ResolvedAccount"]);
  }
  if (hasByteDeltas) {
    functionFragment.addImports("shared", ["type IInstructionWithByteDelta"]);
  }
  return functionFragment;
}
function getTypeParams(instructionNode, programAddressConstant) {
  const typeParams = instructionNode.accounts.map((account) => `TAccount${pascalCase5(account.name)} extends string`);
  typeParams.push(`TProgramAddress extends Address = typeof ${programAddressConstant}`);
  return fragment(typeParams.filter((x) => !!x).join(", ")).mapRender((r) => `<${r}>`).addImports("generatedPrograms", [programAddressConstant]);
}
function getInstructionType(scope) {
  const { instructionPath, nameApi } = scope;
  const instructionNode = getLastNodeFromPath12(instructionPath);
  const instructionTypeName = nameApi.instructionType(instructionNode.name);
  const programAddressFragment = fragment("TProgramAddress");
  const accountTypeParamsFragments = instructionNode.accounts.map((account) => {
    const typeParam = `TAccount${pascalCase5(account.name)}`;
    const camelName = camelCase9(account.name);
    if (account.isSigner === "either") {
      const signerRole = account.isWritable ? "WritableSignerAccount" : "ReadonlySignerAccount";
      return fragment(
        `typeof input["${camelName}"] extends TransactionSigner<${typeParam}> ? ${signerRole}<${typeParam}> & IAccountSignerMeta<${typeParam}> : ${typeParam}`
      ).addImports("solanaInstructions", [`type ${signerRole}`]).addImports("solanaSigners", ["type IAccountSignerMeta"]);
    }
    return fragment(typeParam);
  });
  return mergeFragments(
    [programAddressFragment, ...accountTypeParamsFragments],
    (renders) => renders.join(", ")
  ).mapRender((r) => `${instructionTypeName}<${r}>`);
}
function getInputTypeCall(scope) {
  const { instructionPath, useAsync, nameApi } = scope;
  const instructionNode = getLastNodeFromPath12(instructionPath);
  const inputTypeName = useAsync ? nameApi.instructionAsyncInputType(instructionNode.name) : nameApi.instructionSyncInputType(instructionNode.name);
  if (instructionNode.accounts.length === 0) return fragment(inputTypeName);
  const accountTypeParams = instructionNode.accounts.map((account) => `TAccount${pascalCase5(account.name)}`).join(", ");
  return fragment(`${inputTypeName}<${accountTypeParams}>`);
}

// src/fragments/instructionParseFunction.ts
import { findProgramNodeFromPath as findProgramNodeFromPath4, getLastNodeFromPath as getLastNodeFromPath13 } from "@codama/visitors-core";
function getInstructionParseFunctionFragment(scope) {
  const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;
  const instructionNode = getLastNodeFromPath13(instructionPath);
  const programNode = findProgramNodeFromPath4(instructionPath);
  const customData = customInstructionData.get(instructionNode.name);
  const hasAccounts = instructionNode.accounts.length > 0;
  const hasOptionalAccounts = instructionNode.accounts.some((account) => account.isOptional);
  const minimumNumberOfAccounts = instructionNode.optionalAccountStrategy === "omitted" ? instructionNode.accounts.filter((account) => !account.isOptional).length : instructionNode.accounts.length;
  const hasData = !!customData || instructionNode.arguments.length > 0;
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const programAddressConstant = nameApi.programAddressConstant(programNode.name);
  const dataTypeFragment = fragment(
    customData ? dataArgsManifest.strictType.render : nameApi.dataType(instructionDataName)
  );
  const decoderFunction = customData ? dataArgsManifest.decoder.render : `${nameApi.decoderFunction(instructionDataName)}()`;
  if (customData) {
    dataTypeFragment.mergeImportsWith(dataArgsManifest.strictType, dataArgsManifest.decoder);
  }
  return fragmentFromTemplate("instructionParseFunction.njk", {
    dataTypeFragment,
    decoderFunction,
    hasAccounts,
    hasData,
    hasOptionalAccounts,
    instruction: instructionNode,
    instructionParseFunction: nameApi.instructionParseFunction(instructionNode.name),
    instructionParsedType: nameApi.instructionParsedType(instructionNode.name),
    minimumNumberOfAccounts,
    programAddressConstant
  }).mergeImportsWith(dataTypeFragment).addImports("generatedPrograms", [programAddressConstant]).addImports("solanaInstructions", ["type IInstruction"]).addImports("solanaInstructions", hasAccounts ? ["type IInstructionWithAccounts", "type IAccountMeta"] : []).addImports("solanaInstructions", hasData ? ["type IInstructionWithData"] : []);
}

// src/fragments/instructionType.ts
import { pascalCase as pascalCase6 } from "@codama/nodes";
import { findProgramNodeFromPath as findProgramNodeFromPath5, getLastNodeFromPath as getLastNodeFromPath14 } from "@codama/visitors-core";
function getInstructionTypeFragment(scope) {
  const { instructionPath, nameApi, customInstructionData } = scope;
  const instructionNode = getLastNodeFromPath14(instructionPath);
  const programNode = findProgramNodeFromPath5(instructionPath);
  const hasAccounts = instructionNode.accounts.length > 0;
  const customData = customInstructionData.get(instructionNode.name);
  const hasData = !!customData || instructionNode.arguments.length > 0;
  const instructionDataName = nameApi.instructionDataType(instructionNode.name);
  const programAddressConstant = nameApi.programAddressConstant(programNode.name);
  const dataType = customData ? pascalCase6(customData.importAs) : pascalCase6(instructionDataName);
  const accountTypeParamsFragment = mergeFragments(
    instructionNode.accounts.map(
      (account) => getInstructionAccountTypeParamFragment({
        ...scope,
        allowAccountMeta: true,
        instructionAccountPath: [...instructionPath, account]
      })
    ),
    (renders) => renders.join(", ")
  );
  const usesLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === "omitted";
  const accountMetasFragment = mergeFragments(
    instructionNode.accounts.map(
      (account) => getInstructionAccountMetaFragment(account).mapRender((r) => {
        const typeParam = `TAccount${pascalCase6(account.name)}`;
        const isLegacyOptional = account.isOptional && usesLegacyOptionalAccounts;
        const type = `${typeParam} extends string ? ${r} : ${typeParam}`;
        if (!isLegacyOptional) return type;
        return `...(${typeParam} extends undefined ? [] : [${type}])`;
      })
    ),
    (renders) => renders.join(", ")
  );
  const fragment2 = fragmentFromTemplate("instructionType.njk", {
    accountMetas: accountMetasFragment.render,
    accountTypeParams: accountTypeParamsFragment.render,
    dataType,
    hasAccounts,
    hasData,
    instruction: instructionNode,
    instructionType: nameApi.instructionType(instructionNode.name),
    programAddressConstant
  }).mergeImportsWith(accountTypeParamsFragment, accountMetasFragment).addImports("generatedPrograms", [programAddressConstant]).addImports("solanaInstructions", [
    "type IAccountMeta",
    "type IInstruction",
    "type IInstructionWithAccounts",
    ...hasData ? ["type IInstructionWithData"] : []
  ]);
  return fragment2;
}

// src/fragments/pdaFunction.ts
import { isNode as isNode11, isNodeFilter as isNodeFilter5 } from "@codama/nodes";
import { findProgramNodeFromPath as findProgramNodeFromPath6, getLastNodeFromPath as getLastNodeFromPath15, visit as visit4 } from "@codama/visitors-core";
function getPdaFunctionFragment(scope) {
  const { pdaPath, typeManifestVisitor, nameApi } = scope;
  const pdaNode = getLastNodeFromPath15(pdaPath);
  const programNode = findProgramNodeFromPath6(pdaPath);
  const imports = new ImportMap();
  const seeds = pdaNode.seeds.map((seed) => {
    if (isNode11(seed, "variablePdaSeedNode")) {
      const seedManifest2 = visit4(seed.type, typeManifestVisitor);
      imports.mergeWith(seedManifest2.looseType, seedManifest2.encoder);
      return { ...seed, typeManifest: seedManifest2 };
    }
    if (isNode11(seed.value, "programIdValueNode")) {
      imports.add("solanaAddresses", "getAddressEncoder");
      return seed;
    }
    const seedManifest = visit4(seed.type, typeManifestVisitor);
    imports.mergeWith(seedManifest.encoder);
    const valueManifest = visit4(seed.value, typeManifestVisitor).value;
    imports.mergeWith(valueManifest.imports);
    return { ...seed, typeManifest: seedManifest, valueManifest };
  });
  const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter5("variablePdaSeedNode")).length > 0;
  return fragmentFromTemplate("pdaFunction.njk", {
    findPdaFunction: nameApi.pdaFindFunction(pdaNode.name),
    hasVariableSeeds,
    pdaSeedsType: nameApi.pdaSeedsType(pdaNode.name),
    programAddress: pdaNode.programId ?? programNode.publicKey,
    seeds
  }).mergeImportsWith(imports).addImports("solanaAddresses", ["type Address", "getProgramDerivedAddress", "type ProgramDerivedAddress"]);
}

// src/fragments/program.ts
function getProgramFragment(scope) {
  const { programNode, nameApi } = scope;
  return fragmentFromTemplate("program.njk", {
    program: programNode,
    programAddressConstant: nameApi.programAddressConstant(programNode.name)
  }).addImports("solanaAddresses", ["type Address"]);
}

// src/fragments/programAccounts.ts
import { resolveNestedTypeNode } from "@codama/nodes";
function getProgramAccountsFragment(scope) {
  if (scope.programNode.accounts.length === 0) return fragment("");
  return mergeFragments(
    [getProgramAccountsEnumFragment(scope), getProgramAccountsIdentifierFunctionFragment(scope)],
    (r) => `${r.join("\n\n")}
`
  );
}
function getProgramAccountsEnumFragment(scope) {
  const { programNode, nameApi } = scope;
  const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);
  const programAccountsEnumVariants = programNode.accounts.map(
    (account) => nameApi.programAccountsEnumVariant(account.name)
  );
  return fragment(`export enum ${programAccountsEnum} { ${programAccountsEnumVariants.join(", ")} }`);
}
function getProgramAccountsIdentifierFunctionFragment(scope) {
  const { programNode, nameApi } = scope;
  const accountsWithDiscriminators = programNode.accounts.filter(
    (account) => (account.discriminators ?? []).length > 0
  );
  const hasAccountDiscriminators = accountsWithDiscriminators.length > 0;
  if (!hasAccountDiscriminators) return fragment("");
  const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);
  const programAccountsIdentifierFunction = nameApi.programAccountsIdentifierFunction(programNode.name);
  const discriminatorsFragment = mergeFragments(
    accountsWithDiscriminators.map((account) => {
      const variant = nameApi.programAccountsEnumVariant(account.name);
      return getDiscriminatorConditionFragment({
        ...scope,
        dataName: "data",
        discriminators: account.discriminators ?? [],
        ifTrue: `return ${programAccountsEnum}.${variant};`,
        struct: resolveNestedTypeNode(account.data)
      });
    }),
    (r) => r.join("\n")
  );
  return discriminatorsFragment.mapRender(
    (discriminators) => `export function ${programAccountsIdentifierFunction}(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): ${programAccountsEnum} {
const data = 'data' in account ? account.data : account;
${discriminators}
throw new Error("The provided account could not be identified as a ${programNode.name} account.")
}`
  ).addImports("solanaCodecsCore", "type ReadonlyUint8Array");
}

// src/fragments/programErrors.ts
function getProgramErrorsFragment(scope) {
  const { programNode, nameApi } = scope;
  const programAddressConstant = nameApi.programAddressConstant(programNode.name);
  return fragmentFromTemplate("programErrors.njk", {
    errors: programNode.errors,
    getProgramErrorConstant: (name) => nameApi.programErrorConstantPrefix(programNode.name) + nameApi.programErrorConstant(name),
    programAddressConstant,
    programErrorMessagesMap: nameApi.programErrorMessagesMap(programNode.name),
    programErrorUnion: nameApi.programErrorUnion(programNode.name),
    programGetErrorMessageFunction: nameApi.programGetErrorMessageFunction(programNode.name),
    programIsErrorFunction: nameApi.programIsErrorFunction(programNode.name)
  }).addImports("generatedPrograms", [programAddressConstant]).addImports("solanaPrograms", ["isProgramError"]).addImports("solanaErrors", ["type SolanaError", "type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM"]).addImports("solanaAddresses", ["type Address"]);
}

// src/fragments/programInstructions.ts
import {
  getAllInstructionsWithSubs,
  structTypeNodeFromInstructionArgumentNodes as structTypeNodeFromInstructionArgumentNodes2
} from "@codama/nodes";
function getProgramInstructionsFragment(scope) {
  if (scope.programNode.instructions.length === 0) return fragment("");
  const allInstructions = getAllInstructionsWithSubs(scope.programNode, {
    leavesOnly: !scope.renderParentInstructions,
    subInstructionsFirst: true
  });
  const scopeWithInstructions = { ...scope, allInstructions };
  return mergeFragments(
    [
      getProgramInstructionsEnumFragment(scopeWithInstructions),
      getProgramInstructionsIdentifierFunctionFragment(scopeWithInstructions),
      getProgramInstructionsParsedUnionTypeFragment(scopeWithInstructions)
    ],
    (r) => `${r.join("\n\n")}
`
  );
}
function getProgramInstructionsEnumFragment(scope) {
  const { programNode, allInstructions, nameApi } = scope;
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const programInstructionsEnumVariants = allInstructions.map(
    (instruction) => nameApi.programInstructionsEnumVariant(instruction.name)
  );
  return fragment(
    `export enum ${programInstructionsEnum} { ${programInstructionsEnumVariants.join(", ")} }`
  );
}
function getProgramInstructionsIdentifierFunctionFragment(scope) {
  const { programNode, nameApi, allInstructions } = scope;
  const instructionsWithDiscriminators = allInstructions.filter(
    (instruction) => (instruction.discriminators ?? []).length > 0
  );
  const hasInstructionDiscriminators = instructionsWithDiscriminators.length > 0;
  if (!hasInstructionDiscriminators) return fragment("");
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const programInstructionsIdentifierFunction = nameApi.programInstructionsIdentifierFunction(programNode.name);
  const discriminatorsFragment = mergeFragments(
    instructionsWithDiscriminators.map((instruction) => {
      const variant = nameApi.programInstructionsEnumVariant(instruction.name);
      return getDiscriminatorConditionFragment({
        ...scope,
        dataName: "data",
        discriminators: instruction.discriminators ?? [],
        ifTrue: `return ${programInstructionsEnum}.${variant};`,
        struct: structTypeNodeFromInstructionArgumentNodes2(instruction.arguments)
      });
    }),
    (r) => r.join("\n")
  );
  return discriminatorsFragment.mapRender(
    (discriminators) => `export function ${programInstructionsIdentifierFunction}(instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array): ${programInstructionsEnum} {
const data = 'data' in instruction ? instruction.data : instruction;
${discriminators}
throw new Error("The provided instruction could not be identified as a ${programNode.name} instruction.")
}`
  ).addImports("solanaCodecsCore", "type ReadonlyUint8Array");
}
function getProgramInstructionsParsedUnionTypeFragment(scope) {
  const { programNode, allInstructions, nameApi } = scope;
  const programAddress = programNode.publicKey;
  const programInstructionsType = nameApi.programInstructionsParsedUnionType(programNode.name);
  const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);
  const typeVariants = allInstructions.map((instruction) => {
    const instructionEnumVariant = nameApi.programInstructionsEnumVariant(instruction.name);
    const parsedInstructionType = nameApi.instructionParsedType(instruction.name);
    return fragment(
      `| { instructionType: ${programInstructionsEnum}.${instructionEnumVariant} } & ${parsedInstructionType}<TProgram>`
    ).addImports("generatedInstructions", `type ${parsedInstructionType}`);
  });
  return mergeFragments(
    [
      fragment(`export type ${programInstructionsType}<TProgram extends string = '${programAddress}'> =`),
      ...typeVariants
    ],
    (r) => r.join("\n")
  );
}

// src/fragments/typeDiscriminatedUnionHelpers.ts
import { isDataEnum, isNode as isNode12 } from "@codama/nodes";
function getTypeDiscriminatedUnionHelpersFragment(scope) {
  const { name, typeNode, nameApi } = scope;
  const isDiscriminatedUnion = isNode12(typeNode, "enumTypeNode") && isDataEnum(typeNode);
  if (!isDiscriminatedUnion) {
    return fragment("");
  }
  return fragmentFromTemplate("typeDiscriminatedUnionHelpers.njk", {
    discriminatedUnionDiscriminator: nameApi.discriminatedUnionDiscriminator(name),
    discriminatedUnionFunction: nameApi.discriminatedUnionFunction(name),
    getVariant: (variant) => nameApi.discriminatedUnionVariant(variant),
    isDiscriminatedUnionFunction: nameApi.isDiscriminatedUnionFunction(name),
    looseName: nameApi.dataArgsType(name),
    strictName: nameApi.dataType(name),
    typeNode
  }).addImports("solanaCodecsDataStructures", [
    "type GetDiscriminatedUnionVariantContent",
    "type GetDiscriminatedUnionVariant"
  ]);
}

// src/TypeManifest.ts
function typeManifest() {
  return {
    decoder: fragment(""),
    encoder: fragment(""),
    isEnum: false,
    looseType: fragment(""),
    strictType: fragment(""),
    value: fragment("")
  };
}
function mergeManifests(manifests, options = {}) {
  const { mergeTypes, mergeCodecs, mergeValues } = options;
  const merge = (fragmentFn, mergeFn) => mergeFn ? mergeFragments(manifests.map(fragmentFn), mergeFn) : fragment("");
  return {
    decoder: merge((m) => m.decoder, mergeCodecs),
    encoder: merge((m) => m.encoder, mergeCodecs),
    isEnum: false,
    looseType: merge((m) => m.looseType, mergeTypes),
    strictType: merge((m) => m.strictType, mergeTypes),
    value: merge((m) => m.value, mergeValues)
  };
}

// src/getRenderMapVisitor.ts
import { join as join3 } from "node:path";
import { logWarn } from "@codama/errors";
import {
  camelCase as camelCase12,
  definedTypeNode as definedTypeNode2,
  getAllAccounts,
  getAllDefinedTypes,
  getAllInstructionsWithSubs as getAllInstructionsWithSubs2,
  getAllPdas,
  getAllPrograms,
  resolveNestedTypeNode as resolveNestedTypeNode3,
  structTypeNodeFromInstructionArgumentNodes as structTypeNodeFromInstructionArgumentNodes4
} from "@codama/nodes";
import { RenderMap } from "@codama/renderers-core";
import {
  extendVisitor as extendVisitor2,
  findProgramNodeFromPath as findProgramNodeFromPath7,
  getResolvedInstructionInputsVisitor,
  LinkableDictionary as LinkableDictionary3,
  NodeStack as NodeStack2,
  pipe as pipe2,
  recordLinkablesOnFirstVisitVisitor,
  recordNodeStackVisitor as recordNodeStackVisitor2,
  staticVisitor as staticVisitor2,
  visit as visit6
} from "@codama/visitors-core";

// src/getTypeManifestVisitor.ts
import {
  camelCase as camelCase10,
  isNode as isNode13,
  isNodeFilter as isNodeFilter6,
  isScalarEnum,
  parseDocs as parseDocs2,
  REGISTERED_TYPE_NODE_KINDS,
  REGISTERED_VALUE_NODE_KINDS,
  resolveNestedTypeNode as resolveNestedTypeNode2,
  structFieldTypeNode,
  structTypeNode,
  structTypeNodeFromInstructionArgumentNodes as structTypeNodeFromInstructionArgumentNodes3
} from "@codama/nodes";
import {
  extendVisitor,
  findLastNodeFromPath,
  NodeStack,
  pipe,
  recordNodeStackVisitor,
  staticVisitor,
  visit as visit5
} from "@codama/visitors-core";
function getTypeManifestVisitor(input) {
  const { nameApi, linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;
  const stack = input.stack ?? new NodeStack();
  let parentName = null;
  return pipe(
    staticVisitor(
      () => ({
        decoder: fragment(""),
        encoder: fragment(""),
        isEnum: false,
        looseType: fragment(""),
        strictType: fragment(""),
        value: fragment("")
      }),
      {
        keys: [
          ...REGISTERED_TYPE_NODE_KINDS,
          ...REGISTERED_VALUE_NODE_KINDS,
          "definedTypeLinkNode",
          "definedTypeNode",
          "accountNode",
          "instructionNode"
        ]
      }
    ),
    (visitor) => extendVisitor(visitor, {
      visitAccount(account, { self }) {
        parentName = {
          loose: nameApi.dataArgsType(account.name),
          strict: nameApi.dataType(account.name)
        };
        const link = customAccountData.get(account.name)?.linkNode;
        const manifest = link ? visit5(link, self) : visit5(account.data, self);
        parentName = null;
        return manifest;
      },
      visitAmountType(amountType, { self }) {
        return visit5(amountType.number, self);
      },
      visitArrayType(arrayType, { self }) {
        const childManifest = visit5(arrayType.item, self);
        childManifest.looseType.mapRender((r) => `Array<${r}>`);
        childManifest.strictType.mapRender((r) => `Array<${r}>`);
        const sizeManifest = getArrayLikeSizeOption(arrayType.count, self);
        const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : "";
        const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : "";
        childManifest.encoder.mapRender((r) => `getArrayEncoder(${r + encoderOptions})`).mergeImportsWith(sizeManifest.encoder).addImports("solanaCodecsDataStructures", "getArrayEncoder");
        childManifest.decoder.mapRender((r) => `getArrayDecoder(${r + decoderOptions})`).mergeImportsWith(sizeManifest.decoder).addImports("solanaCodecsDataStructures", "getArrayDecoder");
        return childManifest;
      },
      visitArrayValue(node, { self }) {
        return mergeManifests(
          node.items.map((v) => visit5(v, self)),
          { mergeValues: (renders) => `[${renders.join(", ")}]` }
        );
      },
      visitBooleanType(booleanType, { self }) {
        const encoderImports = new ImportMap().add("solanaCodecsDataStructures", "getBooleanEncoder");
        const decoderImports = new ImportMap().add("solanaCodecsDataStructures", "getBooleanDecoder");
        let sizeEncoder = "";
        let sizeDecoder = "";
        const resolvedSize = resolveNestedTypeNode2(booleanType.size);
        if (resolvedSize.format !== "u8" || resolvedSize.endian !== "le") {
          const size = visit5(booleanType.size, self);
          encoderImports.mergeWith(size.encoder);
          decoderImports.mergeWith(size.decoder);
          sizeEncoder = `{ size: ${size.encoder.render} }`;
          sizeDecoder = `{ size: ${size.decoder.render} }`;
        }
        return {
          decoder: fragment(`getBooleanDecoder(${sizeDecoder})`, decoderImports),
          encoder: fragment(`getBooleanEncoder(${sizeEncoder})`, encoderImports),
          isEnum: false,
          looseType: fragment("boolean"),
          strictType: fragment("boolean"),
          value: fragment("")
        };
      },
      visitBooleanValue(node) {
        const manifest = typeManifest();
        manifest.value.setRender(JSON.stringify(node.boolean));
        return manifest;
      },
      visitBytesType() {
        return {
          decoder: fragment(`getBytesDecoder()`).addImports(
            "solanaCodecsDataStructures",
            "getBytesDecoder"
          ),
          encoder: fragment(`getBytesEncoder()`).addImports(
            "solanaCodecsDataStructures",
            "getBytesEncoder"
          ),
          isEnum: false,
          looseType: fragment("ReadonlyUint8Array").addImports(
            "solanaCodecsCore",
            "type ReadonlyUint8Array"
          ),
          strictType: fragment("ReadonlyUint8Array").addImports(
            "solanaCodecsCore",
            "type ReadonlyUint8Array"
          ),
          value: fragment("")
        };
      },
      visitBytesValue(node) {
        const manifest = typeManifest();
        const bytes = getBytesFromBytesValueNode(node);
        manifest.value.setRender(`new Uint8Array([${Array.from(bytes).join(", ")}])`);
        return manifest;
      },
      visitConstantValue(node, { self }) {
        if (isNode13(node.type, "bytesTypeNode") && isNode13(node.value, "bytesValueNode")) {
          return visit5(node.value, self);
        }
        return {
          ...typeManifest(),
          value: mergeFragments(
            [visit5(node.type, self).encoder, visit5(node.value, self).value],
            ([encoderFunction, value]) => `${encoderFunction}.encode(${value})`
          )
        };
      },
      visitDateTimeType(dateTimeType, { self }) {
        return visit5(dateTimeType.number, self);
      },
      visitDefinedType(definedType, { self }) {
        parentName = {
          loose: nameApi.dataArgsType(definedType.name),
          strict: nameApi.dataType(definedType.name)
        };
        const manifest = visit5(definedType.type, self);
        parentName = null;
        return manifest;
      },
      visitDefinedTypeLink(node) {
        const strictName = nameApi.dataType(node.name);
        const looseName = nameApi.dataArgsType(node.name);
        const encoderFunction = nameApi.encoderFunction(node.name);
        const decoderFunction = nameApi.decoderFunction(node.name);
        const importFrom = getImportFrom(node);
        return {
          decoder: fragment(`${decoderFunction}()`).addImports(importFrom, decoderFunction),
          encoder: fragment(`${encoderFunction}()`).addImports(importFrom, encoderFunction),
          isEnum: false,
          looseType: fragment(looseName).addImports(importFrom, `type ${looseName}`),
          strictType: fragment(strictName).addImports(importFrom, `type ${strictName}`),
          value: fragment("")
        };
      },
      visitEnumEmptyVariantType(enumEmptyVariantType) {
        const discriminator = nameApi.discriminatedUnionDiscriminator(camelCase10(parentName?.strict ?? ""));
        const name = nameApi.discriminatedUnionVariant(enumEmptyVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        return {
          decoder: fragment(`['${name}', getUnitDecoder()]`).addImports(
            "solanaCodecsDataStructures",
            "getUnitDecoder"
          ),
          encoder: fragment(`['${name}', getUnitEncoder()]`).addImports(
            "solanaCodecsDataStructures",
            "getUnitEncoder"
          ),
          isEnum: false,
          looseType: fragment(`{ ${kindAttribute} }`),
          strictType: fragment(`{ ${kindAttribute} }`),
          value: fragment("")
        };
      },
      visitEnumStructVariantType(enumStructVariantType, { self }) {
        const currentParentName = parentName;
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          camelCase10(currentParentName?.strict ?? "")
        );
        const name = nameApi.discriminatedUnionVariant(enumStructVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        parentName = null;
        const structManifest = visit5(enumStructVariantType.struct, self);
        parentName = currentParentName;
        structManifest.strictType.mapRender((r) => `{ ${kindAttribute},${r.slice(1, -1)}}`);
        structManifest.looseType.mapRender((r) => `{ ${kindAttribute},${r.slice(1, -1)}}`);
        structManifest.encoder.mapRender((r) => `['${name}', ${r}]`);
        structManifest.decoder.mapRender((r) => `['${name}', ${r}]`);
        return structManifest;
      },
      visitEnumTupleVariantType(enumTupleVariantType, { self }) {
        const currentParentName = parentName;
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          camelCase10(currentParentName?.strict ?? "")
        );
        const name = nameApi.discriminatedUnionVariant(enumTupleVariantType.name);
        const kindAttribute = `${discriminator}: "${name}"`;
        const struct = structTypeNode([
          structFieldTypeNode({
            name: "fields",
            type: enumTupleVariantType.tuple
          })
        ]);
        parentName = null;
        const structManifest = visit5(struct, self);
        parentName = currentParentName;
        structManifest.strictType.mapRender((r) => `{ ${kindAttribute},${r.slice(1, -1)}}`);
        structManifest.looseType.mapRender((r) => `{ ${kindAttribute},${r.slice(1, -1)}}`);
        structManifest.encoder.mapRender((r) => `['${name}', ${r}]`);
        structManifest.decoder.mapRender((r) => `['${name}', ${r}]`);
        return structManifest;
      },
      visitEnumType(enumType, { self }) {
        const currentParentName = parentName;
        const encoderImports = new ImportMap();
        const decoderImports = new ImportMap();
        const encoderOptions = [];
        const decoderOptions = [];
        const enumSize = resolveNestedTypeNode2(enumType.size);
        if (enumSize.format !== "u8" || enumSize.endian !== "le") {
          const sizeManifest = visit5(enumType.size, self);
          encoderImports.mergeWith(sizeManifest.encoder);
          decoderImports.mergeWith(sizeManifest.decoder);
          encoderOptions.push(`size: ${sizeManifest.encoder.render}`);
          decoderOptions.push(`size: ${sizeManifest.decoder.render}`);
        }
        const discriminator = nameApi.discriminatedUnionDiscriminator(
          camelCase10(currentParentName?.strict ?? "")
        );
        if (!isScalarEnum(enumType) && discriminator !== "__kind") {
          encoderOptions.push(`discriminator: '${discriminator}'`);
          decoderOptions.push(`discriminator: '${discriminator}'`);
        }
        const encoderOptionsAsString = encoderOptions.length > 0 ? `, { ${encoderOptions.join(", ")} }` : "";
        const decoderOptionsAsString = decoderOptions.length > 0 ? `, { ${decoderOptions.join(", ")} }` : "";
        if (isScalarEnum(enumType)) {
          if (currentParentName === null) {
            throw new Error(
              "Scalar enums cannot be inlined and must be introduced via a defined type. Ensure you are not inlining a defined type that is a scalar enum through a visitor."
            );
          }
          const variantNames = enumType.variants.map(({ name }) => nameApi.enumVariant(name));
          return {
            decoder: fragment(
              `getEnumDecoder(${currentParentName.strict + decoderOptionsAsString})`,
              decoderImports.add("solanaCodecsDataStructures", "getEnumDecoder")
            ),
            encoder: fragment(
              `getEnumEncoder(${currentParentName.strict + encoderOptionsAsString})`,
              encoderImports.add("solanaCodecsDataStructures", "getEnumEncoder")
            ),
            isEnum: true,
            looseType: fragment(`{ ${variantNames.join(", ")} }`),
            strictType: fragment(`{ ${variantNames.join(", ")} }`),
            value: fragment("")
          };
        }
        const mergedManifest = mergeManifests(
          enumType.variants.map((variant) => visit5(variant, self)),
          {
            mergeCodecs: (renders) => renders.join(", "),
            mergeTypes: (renders) => renders.join(" | ")
          }
        );
        mergedManifest.encoder.mapRender((r) => `getDiscriminatedUnionEncoder([${r}]${encoderOptionsAsString})`).mergeImportsWith(encoderImports).addImports("solanaCodecsDataStructures", ["getDiscriminatedUnionEncoder"]);
        mergedManifest.decoder.mapRender((r) => `getDiscriminatedUnionDecoder([${r}]${decoderOptionsAsString})`).mergeImportsWith(decoderImports).addImports("solanaCodecsDataStructures", ["getDiscriminatedUnionDecoder"]);
        return mergedManifest;
      },
      visitEnumValue(node, { self }) {
        const manifest = typeManifest();
        const enumName = nameApi.dataType(node.enum.name);
        const enumFunction = nameApi.discriminatedUnionFunction(node.enum.name);
        const importFrom = getImportFrom(node.enum);
        const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;
        const isScalar = enumNode && isNode13(enumNode, "enumTypeNode") ? isScalarEnum(enumNode) : !nonScalarEnums.includes(node.enum.name);
        if (!node.value && isScalar) {
          const variantName2 = nameApi.enumVariant(node.variant);
          manifest.value.setRender(`${enumName}.${variantName2}`).addImports(importFrom, enumName);
          return manifest;
        }
        const variantName = nameApi.discriminatedUnionVariant(node.variant);
        if (!node.value) {
          manifest.value.setRender(`${enumFunction}('${variantName}')`).addImports(importFrom, enumFunction);
          return manifest;
        }
        manifest.value = visit5(node.value, self).value.mapRender((r) => `${enumFunction}('${variantName}', ${r})`).addImports(importFrom, enumFunction);
        return manifest;
      },
      visitFixedSizeType(node, { self }) {
        const manifest = visit5(node.type, self);
        manifest.encoder.mapRender((r) => `fixEncoderSize(${r}, ${node.size})`).addImports("solanaCodecsCore", "fixEncoderSize");
        manifest.decoder.mapRender((r) => `fixDecoderSize(${r}, ${node.size})`).addImports("solanaCodecsCore", "fixDecoderSize");
        return manifest;
      },
      visitHiddenPrefixType(node, { self }) {
        const manifest = visit5(node.type, self);
        const prefixes = node.prefix.map((c) => visit5(c, self).value);
        const prefixEncoders = fragment(prefixes.map((c) => `getConstantEncoder(${c.render})`).join(", ")).addImports("solanaCodecsCore", "getConstantEncoder").mergeImportsWith(...prefixes);
        const prefixDecoders = fragment(prefixes.map((c) => `getConstantDecoder(${c.render})`).join(", ")).addImports("solanaCodecsCore", "getConstantDecoder").mergeImportsWith(...prefixes);
        manifest.encoder.mapRender((r) => `getHiddenPrefixEncoder(${r}, [${prefixEncoders.render}])`).mergeImportsWith(prefixEncoders).addImports("solanaCodecsDataStructures", "getHiddenPrefixEncoder");
        manifest.decoder.mapRender((r) => `getHiddenPrefixDecoder(${r}, [${prefixDecoders.render}])`).mergeImportsWith(prefixDecoders).addImports("solanaCodecsDataStructures", "getHiddenPrefixDecoder");
        return manifest;
      },
      visitHiddenSuffixType(node, { self }) {
        const manifest = visit5(node.type, self);
        const suffixes = node.suffix.map((c) => visit5(c, self).value);
        const suffixEncoders = fragment(suffixes.map((c) => `getConstantEncoder(${c.render})`).join(", ")).addImports("solanaCodecsCore", "getConstantEncoder").mergeImportsWith(...suffixes);
        const suffixDecoders = fragment(suffixes.map((c) => `getConstantDecoder(${c.render})`).join(", ")).addImports("solanaCodecsCore", "getConstantDecoder").mergeImportsWith(...suffixes);
        manifest.encoder.mapRender((r) => `getHiddenSuffixEncoder(${r}, [${suffixEncoders.render}])`).mergeImportsWith(suffixEncoders).addImports("solanaCodecsDataStructures", "getHiddenSuffixEncoder");
        manifest.decoder.mapRender((r) => `getHiddenSuffixDecoder(${r}, [${suffixDecoders.render}])`).mergeImportsWith(suffixDecoders).addImports("solanaCodecsDataStructures", "getHiddenSuffixDecoder");
        return manifest;
      },
      visitInstruction(instruction, { self }) {
        const instructionDataName = nameApi.instructionDataType(instruction.name);
        parentName = {
          loose: nameApi.dataArgsType(instructionDataName),
          strict: nameApi.dataType(instructionDataName)
        };
        const link = customInstructionData.get(instruction.name)?.linkNode;
        const struct = structTypeNodeFromInstructionArgumentNodes3(instruction.arguments);
        const manifest = link ? visit5(link, self) : visit5(struct, self);
        parentName = null;
        return manifest;
      },
      visitMapEntryValue(node, { self }) {
        return mergeManifests([visit5(node.key, self), visit5(node.value, self)], {
          mergeValues: (renders) => `[${renders.join(", ")}]`
        });
      },
      visitMapType(mapType, { self }) {
        const key = visit5(mapType.key, self);
        const value = visit5(mapType.value, self);
        const mergedManifest = mergeManifests([key, value], {
          mergeCodecs: ([k, v]) => `${k}, ${v}`,
          mergeTypes: ([k, v]) => `Map<${k}, ${v}>`
        });
        const sizeManifest = getArrayLikeSizeOption(mapType.count, self);
        const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : "";
        const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : "";
        mergedManifest.encoder.mapRender((r) => `getMapEncoder(${r}${encoderOptions})`).addImports("solanaCodecsDataStructures", "getMapEncoder");
        mergedManifest.decoder.mapRender((r) => `getMapDecoder(${r}${decoderOptions})`).addImports("solanaCodecsDataStructures", "getMapDecoder");
        return mergedManifest;
      },
      visitMapValue(node, { self }) {
        const entryFragments = node.entries.map((entry) => visit5(entry, self));
        return mergeManifests(entryFragments, {
          mergeValues: (renders) => `new Map([${renders.join(", ")}])`
        });
      },
      visitNoneValue() {
        const manifest = typeManifest();
        manifest.value.setRender("none()").addImports("solanaOptions", "none");
        return manifest;
      },
      visitNumberType(numberType) {
        const encoderFunction = nameApi.encoderFunction(numberType.format);
        const decoderFunction = nameApi.decoderFunction(numberType.format);
        const isBigNumber = ["u64", "u128", "i64", "i128"].includes(numberType.format);
        const encoderImports = new ImportMap().add("solanaCodecsNumbers", encoderFunction);
        const decoderImports = new ImportMap().add("solanaCodecsNumbers", decoderFunction);
        let endianness = "";
        if (numberType.endian === "be") {
          encoderImports.add("solanaCodecsNumbers", "Endian");
          decoderImports.add("solanaCodecsNumbers", "Endian");
          endianness = "{ endian: Endian.Big }";
        }
        return {
          decoder: fragment(`${decoderFunction}(${endianness})`, decoderImports),
          encoder: fragment(`${encoderFunction}(${endianness})`, encoderImports),
          isEnum: false,
          looseType: fragment(isBigNumber ? "number | bigint" : "number"),
          strictType: fragment(isBigNumber ? "bigint" : "number"),
          value: fragment("")
        };
      },
      visitNumberValue(node) {
        const manifest = typeManifest();
        manifest.value.setRender(JSON.stringify(node.number));
        return manifest;
      },
      visitOptionType(optionType, { self }) {
        const childManifest = visit5(optionType.item, self);
        childManifest.strictType.mapRender((r) => `Option<${r}>`).addImports("solanaOptions", "type Option");
        childManifest.looseType.mapRender((r) => `OptionOrNullable<${r}>`).addImports("solanaOptions", "type OptionOrNullable");
        const encoderOptions = [];
        const decoderOptions = [];
        const optionPrefix = resolveNestedTypeNode2(optionType.prefix);
        if (optionPrefix.format !== "u8" || optionPrefix.endian !== "le") {
          const prefixManifest = visit5(optionType.prefix, self);
          childManifest.encoder.mergeImportsWith(prefixManifest.encoder);
          childManifest.decoder.mergeImportsWith(prefixManifest.decoder);
          encoderOptions.push(`prefix: ${prefixManifest.encoder.render}`);
          decoderOptions.push(`prefix: ${prefixManifest.decoder.render}`);
        }
        if (optionType.fixed) {
          encoderOptions.push(`noneValue: "zeroes"`);
          decoderOptions.push(`noneValue: "zeroes"`);
        }
        const encoderOptionsAsString = encoderOptions.length > 0 ? `, { ${encoderOptions.join(", ")} }` : "";
        const decoderOptionsAsString = decoderOptions.length > 0 ? `, { ${decoderOptions.join(", ")} }` : "";
        childManifest.encoder.mapRender((r) => `getOptionEncoder(${r + encoderOptionsAsString})`).addImports("solanaOptions", "getOptionEncoder");
        childManifest.decoder.mapRender((r) => `getOptionDecoder(${r + decoderOptionsAsString})`).addImports("solanaOptions", "getOptionDecoder");
        return childManifest;
      },
      visitPostOffsetType(node, { self }) {
        const manifest = visit5(node.type, self);
        if (node.strategy === "padded") {
          manifest.encoder.mapRender((r) => `padRightEncoder(${r}, ${node.offset})`).addImports("solanaCodecsCore", "padRightEncoder");
          manifest.decoder.mapRender((r) => `padRightDecoder(${r}, ${node.offset})`).addImports("solanaCodecsCore", "padRightDecoder");
          return manifest;
        }
        const fn = (() => {
          switch (node.strategy) {
            case "absolute":
              return node.offset < 0 ? `({ wrapBytes }) => wrapBytes(${node.offset})` : `() => ${node.offset}`;
            case "preOffset":
              return node.offset < 0 ? `({ preOffset }) => preOffset ${node.offset}` : `({ preOffset }) => preOffset + ${node.offset}`;
            case "relative":
            default:
              return node.offset < 0 ? `({ postOffset }) => postOffset ${node.offset}` : `({ postOffset }) => postOffset + ${node.offset}`;
          }
        })();
        manifest.encoder.mapRender((r) => `offsetEncoder(${r}, { postOffset: ${fn} })`).addImports("solanaCodecsCore", "offsetEncoder");
        manifest.decoder.mapRender((r) => `offsetDecoder(${r}, { postOffset: ${fn} })`).addImports("solanaCodecsCore", "offsetDecoder");
        return manifest;
      },
      visitPreOffsetType(node, { self }) {
        const manifest = visit5(node.type, self);
        if (node.strategy === "padded") {
          manifest.encoder.mapRender((r) => `padLeftEncoder(${r}, ${node.offset})`).addImports("solanaCodecsCore", "padLeftEncoder");
          manifest.decoder.mapRender((r) => `padLeftDecoder(${r}, ${node.offset})`).addImports("solanaCodecsCore", "padLeftDecoder");
          return manifest;
        }
        const fn = (() => {
          switch (node.strategy) {
            case "absolute":
              return node.offset < 0 ? `({ wrapBytes }) => wrapBytes(${node.offset})` : `() => ${node.offset}`;
            case "relative":
            default:
              return node.offset < 0 ? `({ preOffset }) => preOffset ${node.offset}` : `({ preOffset }) => preOffset + ${node.offset}`;
          }
        })();
        manifest.encoder.mapRender((r) => `offsetEncoder(${r}, { preOffset: ${fn} })`).addImports("solanaCodecsCore", "offsetEncoder");
        manifest.decoder.mapRender((r) => `offsetDecoder(${r}, { preOffset: ${fn} })`).addImports("solanaCodecsCore", "offsetDecoder");
        return manifest;
      },
      visitPublicKeyType() {
        const imports = new ImportMap().add("solanaAddresses", "type Address");
        return {
          decoder: fragment("getAddressDecoder()").addImports("solanaAddresses", "getAddressDecoder"),
          encoder: fragment("getAddressEncoder()").addImports("solanaAddresses", "getAddressEncoder"),
          isEnum: false,
          looseType: fragment("Address", imports),
          strictType: fragment("Address", imports),
          value: fragment("")
        };
      },
      visitPublicKeyValue(node) {
        const manifest = typeManifest();
        manifest.value.setRender(`address("${node.publicKey}")`).addImports("solanaAddresses", "address");
        return manifest;
      },
      visitRemainderOptionType(node, { self }) {
        const childManifest = visit5(node.item, self);
        childManifest.strictType.mapRender((r) => `Option<${r}>`).addImports("solanaOptions", "type Option");
        childManifest.looseType.mapRender((r) => `OptionOrNullable<${r}>`).addImports("solanaOptions", "type OptionOrNullable");
        const encoderOptions = ["prefix: null"];
        const decoderOptions = ["prefix: null"];
        const encoderOptionsAsString = encoderOptions.length > 0 ? `, { ${encoderOptions.join(", ")} }` : "";
        const decoderOptionsAsString = decoderOptions.length > 0 ? `, { ${decoderOptions.join(", ")} }` : "";
        childManifest.encoder.mapRender((r) => `getOptionEncoder(${r + encoderOptionsAsString})`).addImports("solanaOptions", "getOptionEncoder");
        childManifest.decoder.mapRender((r) => `getOptionDecoder(${r + decoderOptionsAsString})`).addImports("solanaOptions", "getOptionDecoder");
        return childManifest;
      },
      visitSentinelType(node, { self }) {
        const manifest = visit5(node.type, self);
        const sentinel = visit5(node.sentinel, self).value;
        manifest.encoder.mapRender((r) => `addEncoderSentinel(${r}, ${sentinel.render})`).mergeImportsWith(sentinel).addImports("solanaCodecsCore", "addEncoderSentinel");
        manifest.decoder.mapRender((r) => `addDecoderSentinel(${r}, ${sentinel.render})`).mergeImportsWith(sentinel).addImports("solanaCodecsCore", "addDecoderSentinel");
        return manifest;
      },
      visitSetType(setType, { self }) {
        const childManifest = visit5(setType.item, self);
        childManifest.strictType.mapRender((r) => `Set<${r}>`);
        childManifest.looseType.mapRender((r) => `Set<${r}>`);
        const sizeManifest = getArrayLikeSizeOption(setType.count, self);
        const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : "";
        const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : "";
        childManifest.encoder.mergeImportsWith(sizeManifest.encoder).mapRender((r) => `getSetEncoder(${r + encoderOptions})`).addImports("solanaCodecsDataStructures", "getSetEncoder");
        childManifest.decoder.mergeImportsWith(sizeManifest.decoder).mapRender((r) => `getSetDecoder(${r + decoderOptions})`).addImports("solanaCodecsDataStructures", "getSetDecoder");
        return childManifest;
      },
      visitSetValue(node, { self }) {
        return mergeManifests(
          node.items.map((v) => visit5(v, self)),
          { mergeValues: (renders) => `new Set([${renders.join(", ")}])` }
        );
      },
      visitSizePrefixType(node, { self }) {
        const manifest = visit5(node.type, self);
        const prefix = visit5(node.prefix, self);
        manifest.encoder.mapRender((r) => `addEncoderSizePrefix(${r}, ${prefix.encoder.render})`).mergeImportsWith(prefix.encoder).addImports("solanaCodecsCore", "addEncoderSizePrefix");
        manifest.decoder.mapRender((r) => `addDecoderSizePrefix(${r}, ${prefix.decoder.render})`).mergeImportsWith(prefix.decoder).addImports("solanaCodecsCore", "addDecoderSizePrefix");
        return manifest;
      },
      visitSolAmountType({ number }, { self }) {
        const numberManifest = visit5(number, self);
        const lamportsType = "Lamports";
        const lamportsImport = new ImportMap().add("solanaRpcTypes", "type Lamports");
        return {
          ...numberManifest,
          decoder: numberManifest.decoder.mapRender((r) => `getLamportsDecoder(${r})`).addImports("solanaRpcTypes", "getLamportsDecoder"),
          encoder: numberManifest.encoder.mapRender((r) => `getLamportsEncoder(${r})`).addImports("solanaRpcTypes", "getLamportsEncoder"),
          looseType: fragment(lamportsType, lamportsImport),
          strictType: fragment(lamportsType, lamportsImport)
        };
      },
      visitSomeValue(node, { self }) {
        const manifest = typeManifest();
        manifest.value = visit5(node.value, self).value.mapRender((r) => `some(${r})`).addImports("solanaOptions", "some");
        return manifest;
      },
      visitStringType(stringType) {
        const [encoder, decoder] = (() => {
          switch (stringType.encoding) {
            case "base16":
              return ["getBase16Encoder", "getBase16Decoder"];
            case "base58":
              return ["getBase58Encoder", "getBase58Decoder"];
            case "base64":
              return ["getBase64Encoder", "getBase64Decoder"];
            case "utf8":
              return ["getUtf8Encoder", "getUtf8Decoder"];
            default:
              throw new Error(`Unsupported string encoding: ${stringType.encoding}`);
          }
        })();
        return {
          decoder: fragment(`${decoder}()`).addImports("solanaCodecsStrings", decoder),
          encoder: fragment(`${encoder}()`).addImports("solanaCodecsStrings", encoder),
          isEnum: false,
          looseType: fragment("string"),
          strictType: fragment("string"),
          value: fragment("")
        };
      },
      visitStringValue(node) {
        const manifest = typeManifest();
        manifest.value.setRender(JSON.stringify(node.string));
        return manifest;
      },
      visitStructFieldType(structFieldType, { self }) {
        const name = camelCase10(structFieldType.name);
        const childManifest = visit5(structFieldType.type, self);
        const structFieldDocs = parseDocs2(structFieldType.docs);
        const docblock = structFieldDocs.length > 0 ? `
${jsDocblock(structFieldDocs)}` : "";
        const originalLooseType = childManifest.looseType.render;
        childManifest.strictType.mapRender((r) => `${docblock}${name}: ${r}; `);
        childManifest.looseType.mapRender((r) => `${docblock}${name}: ${r}; `);
        childManifest.encoder.mapRender((r) => `['${name}', ${r}]`);
        childManifest.decoder.mapRender((r) => `['${name}', ${r}]`);
        if (!structFieldType.defaultValue) {
          return childManifest;
        }
        if (structFieldType.defaultValueStrategy !== "omitted") {
          childManifest.looseType.setRender(`${docblock}${name}?: ${originalLooseType}; `);
          return childManifest;
        }
        childManifest.looseType = fragment("");
        return childManifest;
      },
      visitStructFieldValue(node, { self }) {
        const manifest = typeManifest();
        manifest.value = visit5(node.value, self).value.mapRender((r) => `${node.name}: ${r}`);
        return manifest;
      },
      visitStructType(structType, { self }) {
        const optionalFields = structType.fields.filter((f) => !!f.defaultValue);
        const mergedManifest = mergeManifests(
          structType.fields.map((field) => visit5(field, self)),
          {
            mergeCodecs: (renders) => `([${renders.join(", ")}])`,
            mergeTypes: (renders) => `{ ${renders.join("")} }`
          }
        );
        mergedManifest.encoder.mapRender((r) => `getStructEncoder${r}`).addImports("solanaCodecsDataStructures", "getStructEncoder");
        mergedManifest.decoder.mapRender((r) => `getStructDecoder${r}`).addImports("solanaCodecsDataStructures", "getStructDecoder");
        if (optionalFields.length === 0) {
          return mergedManifest;
        }
        const parentPath = stack.getPath();
        const instructionNode = findLastNodeFromPath(parentPath, "instructionNode");
        const accountNode = findLastNodeFromPath(parentPath, "accountNode");
        const discriminatorPrefix = instructionNode ? instructionNode.name : accountNode?.name;
        const discriminators = (instructionNode ? instructionNode.discriminators : accountNode?.discriminators) ?? [];
        const fieldDiscriminators = discriminators.filter(isNodeFilter6("fieldDiscriminatorNode"));
        const defaultValues = optionalFields.map((f) => {
          const key = camelCase10(f.name);
          if (fieldDiscriminators.some((d) => d.name === f.name)) {
            const constantName = nameApi.constant(camelCase10(`${discriminatorPrefix}_${f.name}`));
            return f.defaultValueStrategy === "omitted" ? `${key}: ${constantName}` : `${key}: value.${key} ?? ${constantName}`;
          }
          const defaultValue = f.defaultValue;
          const { render: renderedValue, imports } = visit5(defaultValue, self).value;
          mergedManifest.encoder.mergeImportsWith(imports);
          return f.defaultValueStrategy === "omitted" ? `${key}: ${renderedValue}` : `${key}: value.${key} ?? ${renderedValue}`;
        }).join(", ");
        mergedManifest.encoder.mapRender((r) => `transformEncoder(${r}, (value) => ({ ...value, ${defaultValues} }))`).addImports("solanaCodecsCore", "transformEncoder");
        return mergedManifest;
      },
      visitStructValue(node, { self }) {
        return mergeManifests(
          node.fields.map((field) => visit5(field, self)),
          { mergeValues: (renders) => `{ ${renders.join(", ")} }` }
        );
      },
      visitTupleType(tupleType, { self }) {
        const items = tupleType.items.map((item) => visit5(item, self));
        const mergedManifest = mergeManifests(items, {
          mergeCodecs: (codecs) => `[${codecs.join(", ")}]`,
          mergeTypes: (types) => `readonly [${types.join(", ")}]`
        });
        mergedManifest.encoder.mapRender((render2) => `getTupleEncoder(${render2})`).addImports("solanaCodecsDataStructures", "getTupleEncoder");
        mergedManifest.decoder.mapRender((render2) => `getTupleDecoder(${render2})`).addImports("solanaCodecsDataStructures", "getTupleDecoder");
        return mergedManifest;
      },
      visitTupleValue(node, { self }) {
        return mergeManifests(
          node.items.map((v) => visit5(v, self)),
          { mergeValues: (renders) => `[${renders.join(", ")}]` }
        );
      },
      visitZeroableOptionType(node, { self }) {
        const childManifest = visit5(node.item, self);
        childManifest.strictType.mapRender((r) => `Option<${r}>`).addImports("solanaOptions", "type Option");
        childManifest.looseType.mapRender((r) => `OptionOrNullable<${r}>`).addImports("solanaOptions", "type OptionOrNullable");
        const encoderOptions = ["prefix: null"];
        const decoderOptions = ["prefix: null"];
        if (node.zeroValue) {
          const zeroValueManifest = visit5(node.zeroValue, self);
          childManifest.encoder.mergeImportsWith(zeroValueManifest.value);
          childManifest.decoder.mergeImportsWith(zeroValueManifest.value);
          encoderOptions.push(`noneValue: ${zeroValueManifest.value.render}`);
          decoderOptions.push(`noneValue: ${zeroValueManifest.value.render}`);
        } else {
          encoderOptions.push(`noneValue: "zeroes"`);
          decoderOptions.push(`noneValue: "zeroes"`);
        }
        const encoderOptionsAsString = encoderOptions.length > 0 ? `, { ${encoderOptions.join(", ")} }` : "";
        const decoderOptionsAsString = decoderOptions.length > 0 ? `, { ${decoderOptions.join(", ")} }` : "";
        childManifest.encoder.mapRender((r) => `getOptionEncoder(${r + encoderOptionsAsString})`).addImports("solanaOptions", "getOptionEncoder");
        childManifest.decoder.mapRender((r) => `getOptionDecoder(${r + decoderOptionsAsString})`).addImports("solanaOptions", "getOptionDecoder");
        return childManifest;
      }
    }),
    (visitor) => recordNodeStackVisitor(visitor, stack)
  );
}
function getArrayLikeSizeOption(count, visitor) {
  if (isNode13(count, "fixedCountNode")) {
    return {
      decoder: fragment(`size: ${count.value}`),
      encoder: fragment(`size: ${count.value}`)
    };
  }
  if (isNode13(count, "remainderCountNode")) {
    return {
      decoder: fragment(`size: 'remainder'`),
      encoder: fragment(`size: 'remainder'`)
    };
  }
  const prefix = resolveNestedTypeNode2(count.prefix);
  if (prefix.format === "u32" && prefix.endian === "le") {
    return { decoder: fragment(""), encoder: fragment("") };
  }
  const prefixManifest = visit5(count.prefix, visitor);
  prefixManifest.encoder.mapRender((r) => `size: ${r}`);
  prefixManifest.decoder.mapRender((r) => `size: ${r}`);
  return prefixManifest;
}

// src/nameTransformers.ts
import { camelCase as camelCase11, capitalize, kebabCase as kebabCase2, pascalCase as pascalCase7, snakeCase as snakeCase2, titleCase as titleCase2 } from "@codama/nodes";
function getNameApi(transformers) {
  const helpers = {
    camelCase: camelCase11,
    capitalize,
    kebabCase: kebabCase2,
    pascalCase: pascalCase7,
    snakeCase: snakeCase2,
    titleCase: titleCase2
  };
  return Object.fromEntries(
    Object.entries(transformers).map(([key, transformer]) => [key, (name) => transformer(name, helpers)])
  );
}
var DEFAULT_NAME_TRANSFORMERS = {
  accountDecodeFunction: (name) => `decode${pascalCase7(name)}`,
  accountFetchAllFunction: (name) => `fetchAll${pascalCase7(name)}`,
  accountFetchAllMaybeFunction: (name) => `fetchAllMaybe${pascalCase7(name)}`,
  accountFetchFromSeedsFunction: (name) => `fetch${pascalCase7(name)}FromSeeds`,
  accountFetchFunction: (name) => `fetch${pascalCase7(name)}`,
  accountFetchMaybeFromSeedsFunction: (name) => `fetchMaybe${pascalCase7(name)}FromSeeds`,
  accountFetchMaybeFunction: (name) => `fetchMaybe${pascalCase7(name)}`,
  accountGetSizeFunction: (name) => `get${pascalCase7(name)}Size`,
  codecFunction: (name) => `get${pascalCase7(name)}Codec`,
  constant: (name) => snakeCase2(name).toUpperCase(),
  constantFunction: (name) => `get${pascalCase7(name)}Bytes`,
  dataArgsType: (name) => `${pascalCase7(name)}Args`,
  dataType: (name) => `${pascalCase7(name)}`,
  decoderFunction: (name) => `get${pascalCase7(name)}Decoder`,
  discriminatedUnionDiscriminator: () => "__kind",
  discriminatedUnionFunction: (name) => `${camelCase11(name)}`,
  discriminatedUnionVariant: (name) => `${pascalCase7(name)}`,
  encoderFunction: (name) => `get${pascalCase7(name)}Encoder`,
  enumVariant: (name) => `${pascalCase7(name)}`,
  instructionAsyncFunction: (name) => `get${pascalCase7(name)}InstructionAsync`,
  instructionAsyncInputType: (name) => `${pascalCase7(name)}AsyncInput`,
  instructionDataType: (name) => `${pascalCase7(name)}InstructionData`,
  instructionExtraType: (name) => `${pascalCase7(name)}InstructionExtra`,
  instructionParseFunction: (name) => `parse${pascalCase7(name)}Instruction`,
  instructionParsedType: (name) => `Parsed${pascalCase7(name)}Instruction`,
  instructionSyncFunction: (name) => `get${pascalCase7(name)}Instruction`,
  instructionSyncInputType: (name) => `${pascalCase7(name)}Input`,
  instructionType: (name) => `${pascalCase7(name)}Instruction`,
  isDiscriminatedUnionFunction: (name) => `is${pascalCase7(name)}`,
  pdaFindFunction: (name) => `find${pascalCase7(name)}Pda`,
  pdaSeedsType: (name) => `${pascalCase7(name)}Seeds`,
  programAccountsEnum: (name) => `${pascalCase7(name)}Account`,
  programAccountsEnumVariant: (name) => `${pascalCase7(name)}`,
  programAccountsIdentifierFunction: (name) => `identify${pascalCase7(name)}Account`,
  programAddressConstant: (name) => `${snakeCase2(name).toUpperCase()}_PROGRAM_ADDRESS`,
  programErrorConstant: (name) => snakeCase2(name).toUpperCase(),
  programErrorConstantPrefix: (name) => `${snakeCase2(name).toUpperCase()}_ERROR__`,
  programErrorMessagesMap: (name) => `${camelCase11(name)}ErrorMessages`,
  programErrorUnion: (name) => `${pascalCase7(name)}Error`,
  programGetErrorMessageFunction: (name) => `get${pascalCase7(name)}ErrorMessage`,
  programInstructionsEnum: (name) => `${pascalCase7(name)}Instruction`,
  programInstructionsEnumVariant: (name) => `${pascalCase7(name)}`,
  programInstructionsIdentifierFunction: (name) => `identify${pascalCase7(name)}Instruction`,
  programInstructionsParsedUnionType: (name) => `Parsed${pascalCase7(name)}Instruction`,
  programIsErrorFunction: (name) => `is${pascalCase7(name)}Error`,
  resolverFunction: (name) => `${camelCase11(name)}`
};

// src/getRenderMapVisitor.ts
function getRenderMapVisitor(options = {}) {
  const linkables = new LinkableDictionary3();
  const stack = new NodeStack2();
  const nameTransformers = {
    ...DEFAULT_NAME_TRANSFORMERS,
    ...options.nameTransformers
  };
  const nameApi = getNameApi(nameTransformers);
  const renderParentInstructions = options.renderParentInstructions ?? false;
  const dependencyMap = options.dependencyMap ?? {};
  const useGranularImports = options.useGranularImports ?? false;
  const asyncResolvers = (options.asyncResolvers ?? []).map(camelCase12);
  const nonScalarEnums = (options.nonScalarEnums ?? []).map(camelCase12);
  const internalNodes = (options.internalNodes ?? []).map(camelCase12);
  const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], "AccountData");
  const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], "InstructionData");
  const getImportFrom = getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData);
  const typeManifestVisitor = getTypeManifestVisitor({
    customAccountData,
    customInstructionData,
    getImportFrom,
    linkables,
    nameApi,
    nonScalarEnums,
    stack
  });
  const resolvedInstructionInputVisitor = getResolvedInstructionInputsVisitor();
  const globalScope = {
    asyncResolvers,
    customAccountData,
    customInstructionData,
    getImportFrom,
    linkables,
    nameApi,
    nonScalarEnums,
    renderParentInstructions,
    typeManifestVisitor
  };
  const render2 = (template, context, renderOptions) => {
    return render(join3("pages", template), context, renderOptions);
  };
  return pipe2(
    staticVisitor2(() => new RenderMap(), {
      keys: ["rootNode", "programNode", "pdaNode", "accountNode", "definedTypeNode", "instructionNode"]
    }),
    (v) => extendVisitor2(v, {
      visitAccount(node) {
        const accountPath = stack.getPath("accountNode");
        if (!findProgramNodeFromPath7(accountPath)) {
          throw new Error("Account must be visited inside a program.");
        }
        const scope = {
          ...globalScope,
          accountPath,
          typeManifest: visit6(node, typeManifestVisitor)
        };
        const fields = resolveNestedTypeNode3(node.data).fields;
        const accountDiscriminatorConstantsFragment = getDiscriminatorConstantsFragment({
          ...scope,
          discriminatorNodes: node.discriminators ?? [],
          fields,
          prefix: node.name
        });
        const accountTypeFragment = getAccountTypeFragment(scope);
        const accountFetchHelpersFragment = getAccountFetchHelpersFragment(scope);
        const accountSizeHelpersFragment = getAccountSizeHelpersFragment(scope);
        const accountPdaHelpersFragment = getAccountPdaHelpersFragment(scope);
        const imports = new ImportMap().mergeWith(
          accountDiscriminatorConstantsFragment,
          accountTypeFragment,
          accountFetchHelpersFragment,
          accountSizeHelpersFragment,
          accountPdaHelpersFragment
        );
        return new RenderMap().add(
          `accounts/${camelCase12(node.name)}.ts`,
          render2("accountsPage.njk", {
            accountDiscriminatorConstantsFragment,
            accountFetchHelpersFragment,
            accountPdaHelpersFragment,
            accountSizeHelpersFragment,
            accountTypeFragment,
            imports: imports.toString(dependencyMap, useGranularImports)
          })
        );
      },
      visitDefinedType(node) {
        const scope = {
          ...globalScope,
          codecDocs: [],
          decoderDocs: [],
          encoderDocs: [],
          manifest: visit6(node, typeManifestVisitor),
          name: node.name,
          typeDocs: node.docs,
          typeNode: node.type
        };
        const typeWithCodecFragment = getTypeWithCodecFragment(scope);
        const typeDiscriminatedUnionHelpersFragment = getTypeDiscriminatedUnionHelpersFragment(scope);
        const imports = new ImportMap().mergeWith(typeWithCodecFragment, typeDiscriminatedUnionHelpersFragment).remove("generatedTypes", [
          nameApi.dataType(node.name),
          nameApi.dataArgsType(node.name),
          nameApi.encoderFunction(node.name),
          nameApi.decoderFunction(node.name),
          nameApi.codecFunction(node.name)
        ]);
        return new RenderMap().add(
          `types/${camelCase12(node.name)}.ts`,
          render2("definedTypesPage.njk", {
            imports: imports.toString({
              ...dependencyMap,
              generatedTypes: "."
            }),
            typeDiscriminatedUnionHelpersFragment,
            typeWithCodecFragment
          })
        );
      },
      visitInstruction(node) {
        const instructionPath = stack.getPath("instructionNode");
        if (!findProgramNodeFromPath7(instructionPath)) {
          throw new Error("Instruction must be visited inside a program.");
        }
        const instructionExtraName = nameApi.instructionExtraType(node.name);
        const scope = {
          ...globalScope,
          dataArgsManifest: visit6(node, typeManifestVisitor),
          extraArgsManifest: visit6(
            definedTypeNode2({
              name: instructionExtraName,
              type: structTypeNodeFromInstructionArgumentNodes4(node.extraArguments ?? [])
            }),
            typeManifestVisitor
          ),
          instructionPath,
          renamedArgs: getRenamedArgsMap(node),
          resolvedInputs: visit6(node, resolvedInstructionInputVisitor)
        };
        const instructionDiscriminatorConstantsFragment = getDiscriminatorConstantsFragment({
          ...scope,
          discriminatorNodes: node.discriminators ?? [],
          fields: node.arguments,
          prefix: node.name
        });
        const instructionTypeFragment = getInstructionTypeFragment(scope);
        const instructionDataFragment = getInstructionDataFragment(scope);
        const instructionExtraArgsFragment = getInstructionExtraArgsFragment(scope);
        const instructionFunctionAsyncFragment = getInstructionFunctionFragment({
          ...scope,
          useAsync: true
        });
        const instructionFunctionSyncFragment = getInstructionFunctionFragment({
          ...scope,
          useAsync: false
        });
        const instructionParseFunctionFragment = getInstructionParseFunctionFragment(scope);
        const imports = new ImportMap().mergeWith(
          instructionDiscriminatorConstantsFragment,
          instructionTypeFragment,
          instructionDataFragment,
          instructionExtraArgsFragment,
          instructionFunctionAsyncFragment,
          instructionFunctionSyncFragment,
          instructionParseFunctionFragment
        );
        return new RenderMap().add(
          `instructions/${camelCase12(node.name)}.ts`,
          render2("instructionsPage.njk", {
            imports: imports.toString(dependencyMap, useGranularImports),
            instruction: node,
            instructionDataFragment,
            instructionDiscriminatorConstantsFragment,
            instructionExtraArgsFragment,
            instructionFunctionAsyncFragment,
            instructionFunctionSyncFragment,
            instructionParseFunctionFragment,
            instructionTypeFragment
          })
        );
      },
      visitPda(node) {
        const pdaPath = stack.getPath("pdaNode");
        if (!findProgramNodeFromPath7(pdaPath)) {
          throw new Error("Account must be visited inside a program.");
        }
        const scope = { ...globalScope, pdaPath };
        const pdaFunctionFragment = getPdaFunctionFragment(scope);
        const imports = new ImportMap().mergeWith(pdaFunctionFragment);
        return new RenderMap().add(
          `pdas/${camelCase12(node.name)}.ts`,
          render2("pdasPage.njk", {
            imports: imports.toString(dependencyMap, useGranularImports),
            pdaFunctionFragment
          })
        );
      },
      visitProgram(node, { self }) {
        const customDataDefinedType = [
          ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),
          ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData)
        ];
        const scope = { ...globalScope, programNode: node };
        const renderMap = new RenderMap().mergeWith(...node.pdas.map((p) => visit6(p, self))).mergeWith(...node.accounts.map((a) => visit6(a, self))).mergeWith(...node.definedTypes.map((t) => visit6(t, self))).mergeWith(...customDataDefinedType.map((t) => visit6(t, self)));
        if (node.errors.length > 0) {
          const programErrorsFragment = getProgramErrorsFragment(scope);
          renderMap.add(
            `errors/${camelCase12(node.name)}.ts`,
            render2("errorsPage.njk", {
              imports: new ImportMap().mergeWith(programErrorsFragment).toString(dependencyMap, useGranularImports),
              programErrorsFragment
            })
          );
        }
        const programFragment = getProgramFragment(scope);
        const programAccountsFragment = getProgramAccountsFragment(scope);
        const programInstructionsFragment = getProgramInstructionsFragment(scope);
        renderMap.add(
          `programs/${camelCase12(node.name)}.ts`,
          render2("programsPage.njk", {
            imports: new ImportMap().mergeWith(programFragment, programAccountsFragment, programInstructionsFragment).toString(dependencyMap, useGranularImports),
            programAccountsFragment,
            programFragment,
            programInstructionsFragment
          })
        );
        renderMap.mergeWith(
          ...getAllInstructionsWithSubs2(node, {
            leavesOnly: !renderParentInstructions
          }).map((ix) => visit6(ix, self))
        );
        return renderMap;
      },
      visitRoot(node, { self }) {
        const isNotInternal = (n) => !internalNodes.includes(n.name);
        const programsToExport = getAllPrograms(node).filter(isNotInternal);
        const programsWithErrorsToExport = programsToExport.filter((p) => p.errors.length > 0);
        const pdasToExport = getAllPdas(node);
        const accountsToExport = getAllAccounts(node).filter(isNotInternal);
        const instructionsToExport = getAllInstructionsWithSubs2(node, {
          leavesOnly: !renderParentInstructions
        }).filter(isNotInternal);
        const definedTypesToExport = getAllDefinedTypes(node).filter(isNotInternal);
        const hasAnythingToExport = programsToExport.length > 0 || accountsToExport.length > 0 || instructionsToExport.length > 0 || definedTypesToExport.length > 0;
        const ctx = {
          accountsToExport,
          definedTypesToExport,
          hasAnythingToExport,
          instructionsToExport,
          pdasToExport,
          programsToExport,
          programsWithErrorsToExport,
          root: node
        };
        const map = new RenderMap();
        if (hasAnythingToExport) {
          map.add(
            "shared/index.ts",
            render2("sharedPage.njk", {
              ...ctx,
              imports: new ImportMap().add("solanaAddresses", [
                "type Address",
                "isProgramDerivedAddress",
                "type ProgramDerivedAddress"
              ]).add("solanaInstructions", [
                "AccountRole",
                "type IAccountMeta",
                "upgradeRoleToSigner"
              ]).add("solanaSigners", [
                "type IAccountSignerMeta",
                "isTransactionSigner",
                "type TransactionSigner"
              ]).addAlias("solanaSigners", "isTransactionSigner", "kitIsTransactionSigner").toString(dependencyMap, useGranularImports)
            })
          );
        }
        if (programsToExport.length > 0) {
          map.add("programs/index.ts", render2("programsIndex.njk", ctx));
        }
        if (programsWithErrorsToExport.length > 0) {
          map.add("errors/index.ts", render2("errorsIndex.njk", ctx));
        }
        if (accountsToExport.length > 0) {
          map.add("accounts/index.ts", render2("accountsIndex.njk", ctx));
        }
        if (pdasToExport.length > 0) {
          map.add("pdas/index.ts", render2("pdasIndex.njk", ctx));
        }
        if (instructionsToExport.length > 0) {
          map.add("instructions/index.ts", render2("instructionsIndex.njk", ctx));
        }
        if (definedTypesToExport.length > 0) {
          map.add("types/index.ts", render2("definedTypesIndex.njk", ctx));
        }
        return map.add("index.ts", render2("rootIndex.njk", ctx)).mergeWith(...getAllPrograms(node).map((p) => visit6(p, self)));
      }
    }),
    (v) => recordNodeStackVisitor2(v, stack),
    (v) => recordLinkablesOnFirstVisitVisitor(v, linkables)
  );
}
function getRenamedArgsMap(instruction) {
  const argNames = [
    ...instruction.arguments.map((a) => a.name),
    ...(instruction.extraArguments ?? []).map((a) => a.name)
  ];
  const duplicateArgs = argNames.filter((e, i, a) => a.indexOf(e) !== i);
  if (duplicateArgs.length > 0) {
    throw new Error(`Duplicate args found: [${duplicateArgs.join(", ")}] in instruction [${instruction.name}].`);
  }
  const allNames = [...instruction.accounts.map((account) => account.name), ...argNames];
  const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);
  if (duplicates.length === 0) return /* @__PURE__ */ new Map();
  logWarn(
    `[JavaScript] Accounts and args of instruction [${instruction.name}] have the following conflicting attributes [${duplicates.join(", ")}]. Thus, the arguments have been renamed to avoid conflicts in the input type.`
  );
  return new Map(duplicates.map((name) => [camelCase12(name), camelCase12(`${name}Arg`)]));
}

// src/renderVisitor.ts
import { deleteDirectory } from "@codama/renderers-core";
import { rootNodeVisitor, visit as visit7 } from "@codama/visitors-core";
import * as estreePlugin from "prettier/plugins/estree";
import * as typeScriptPlugin from "prettier/plugins/typescript";
import { format } from "prettier/standalone";
var DEFAULT_PRETTIER_OPTIONS = {
  arrowParens: "always",
  parser: "typescript",
  plugins: [estreePlugin, typeScriptPlugin],
  printWidth: 80,
  semi: true,
  singleQuote: true,
  tabWidth: 2,
  trailingComma: "es5",
  useTabs: false
};
function renderVisitor(path, options = {}) {
  return rootNodeVisitor(async (root) => {
    if (options.deleteFolderBeforeRendering ?? true) {
      deleteDirectory(path);
    }
    const renderMap = visit7(root, getRenderMapVisitor(options));
    if (options.formatCode ?? true) {
      const prettierOptions = { ...DEFAULT_PRETTIER_OPTIONS, ...options.prettierOptions };
      await renderMap.mapContentAsync((code) => format(code, prettierOptions));
    }
    renderMap.write(path);
  });
}
export {
  DEFAULT_NAME_TRANSFORMERS,
  ImportMap,
  renderVisitor as default,
  getNameApi,
  getRenderMapVisitor,
  getTypeManifestVisitor,
  mergeManifests,
  renderVisitor,
  typeManifest
};
//# sourceMappingURL=index.node.mjs.map