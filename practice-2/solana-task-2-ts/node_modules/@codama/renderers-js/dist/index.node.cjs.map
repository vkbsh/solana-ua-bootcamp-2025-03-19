{"version":3,"sources":["../src/index.ts","../src/ImportMap.ts","../src/fragments/accountFetchHelpers.ts","../src/fragments/common.ts","../src/utils/async.ts","../src/utils/codecs.ts","../src/utils/customData.ts","../src/utils/linkOverrides.ts","../src/utils/render.ts","../src/fragments/accountPdaHelpers.ts","../src/fragments/accountSizeHelpers.ts","../src/fragments/accountType.ts","../src/fragments/type.ts","../src/fragments/typeDecoder.ts","../src/fragments/typeEncoder.ts","../src/fragments/typeCodec.ts","../src/fragments/typeWithCodec.ts","../src/fragments/discriminatorCondition.ts","../src/fragments/instructionAccountMeta.ts","../src/fragments/instructionAccountTypeParam.ts","../src/fragments/instructionByteDelta.ts","../src/fragments/instructionData.ts","../src/fragments/discriminatorConstants.ts","../src/fragments/instructionExtraArgs.ts","../src/fragments/instructionFunction.ts","../src/fragments/instructionInputResolved.ts","../src/fragments/instructionInputDefault.ts","../src/fragments/instructionInputType.ts","../src/fragments/instructionRemainingAccounts.ts","../src/fragments/instructionParseFunction.ts","../src/fragments/instructionType.ts","../src/fragments/pdaFunction.ts","../src/fragments/program.ts","../src/fragments/programAccounts.ts","../src/fragments/programErrors.ts","../src/fragments/programInstructions.ts","../src/fragments/typeDiscriminatedUnionHelpers.ts","../src/TypeManifest.ts","../src/getRenderMapVisitor.ts","../src/getTypeManifestVisitor.ts","../src/nameTransformers.ts","../src/renderVisitor.ts"],"sourcesContent":["export * from './ImportMap';\nexport * from './TypeManifest';\nexport * from './getRenderMapVisitor';\nexport * from './getTypeManifestVisitor';\nexport * from './nameTransformers';\nexport * from './renderVisitor';\n\nexport { renderVisitor as default } from './renderVisitor';\n","import { Fragment } from './fragments';\nimport { TypeManifest } from './TypeManifest';\n\nconst DEFAULT_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/kit',\n    solanaAddresses: '@solana/kit',\n    solanaCodecsCore: '@solana/kit',\n    solanaCodecsDataStructures: '@solana/kit',\n    solanaCodecsNumbers: '@solana/kit',\n    solanaCodecsStrings: '@solana/kit',\n    solanaErrors: '@solana/kit',\n    solanaInstructions: '@solana/kit',\n    solanaOptions: '@solana/kit',\n    solanaPrograms: '@solana/kit',\n    solanaRpcTypes: '@solana/kit',\n    solanaSigners: '@solana/kit',\n};\n\nconst DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP: Record<string, string> = {\n    solanaAccounts: '@solana/accounts',\n    solanaAddresses: '@solana/addresses',\n    solanaCodecsCore: '@solana/codecs',\n    solanaCodecsDataStructures: '@solana/codecs',\n    solanaCodecsNumbers: '@solana/codecs',\n    solanaCodecsStrings: '@solana/codecs',\n    solanaErrors: '@solana/errors',\n    solanaInstructions: '@solana/instructions',\n    solanaOptions: '@solana/codecs',\n    solanaPrograms: '@solana/programs',\n    solanaRpcTypes: '@solana/rpc-types',\n    solanaSigners: '@solana/signers',\n};\n\nconst DEFAULT_INTERNAL_MODULE_MAP: Record<string, string> = {\n    errors: '../errors',\n    generated: '..',\n    generatedAccounts: '../accounts',\n    generatedErrors: '../errors',\n    generatedInstructions: '../instructions',\n    generatedPdas: '../pdas',\n    generatedPrograms: '../programs',\n    generatedTypes: '../types',\n    hooked: '../../hooked',\n    shared: '../shared',\n    types: '../types',\n};\n\nexport class ImportMap {\n    protected readonly _imports: Map<string, Set<string>> = new Map();\n\n    protected readonly _aliases: Map<string, Record<string, string>> = new Map();\n\n    add(module: string, imports: Set<string> | string[] | string): ImportMap {\n        const newImports = new Set(typeof imports === 'string' ? [imports] : imports);\n        if (newImports.size === 0) return this;\n        const currentImports = this._imports.get(module) ?? new Set();\n        newImports.forEach(i => currentImports.add(i));\n        this._imports.set(module, currentImports);\n        return this;\n    }\n\n    remove(module: string, imports: Set<string> | string[] | string): ImportMap {\n        const importsToRemove = new Set(typeof imports === 'string' ? [imports] : imports);\n        if (importsToRemove.size === 0) return this;\n        const currentImports = this._imports.get(module) ?? new Set();\n        importsToRemove.forEach(i => currentImports.delete(i));\n        if (currentImports.size === 0) {\n            this._imports.delete(module);\n        } else {\n            this._imports.set(module, currentImports);\n        }\n        return this;\n    }\n\n    mergeWith(...others: (Fragment | ImportMap)[]): ImportMap {\n        others.forEach(rawOther => {\n            const other = 'imports' in rawOther ? rawOther.imports : rawOther;\n            other._imports.forEach((imports, module) => {\n                this.add(module, imports);\n            });\n            other._aliases.forEach((aliases, module) => {\n                Object.entries(aliases).forEach(([name, alias]) => {\n                    this.addAlias(module, name, alias);\n                });\n            });\n        });\n        return this;\n    }\n\n    mergeWithManifest(manifest: TypeManifest): ImportMap {\n        return this.mergeWith(manifest.strictType, manifest.looseType, manifest.encoder, manifest.decoder);\n    }\n\n    addAlias(module: string, name: string, alias: string): ImportMap {\n        const currentAliases = this._aliases.get(module) ?? {};\n        currentAliases[name] = alias;\n        this._aliases.set(module, currentAliases);\n        return this;\n    }\n\n    isEmpty(): boolean {\n        return this._imports.size === 0;\n    }\n\n    resolve(dependencies: Record<string, string> = {}, useGranularImports = false): Map<string, Set<string>> {\n        // Resolve aliases.\n        const aliasedMap = new Map<string, Set<string>>(\n            [...this._imports.entries()].map(([module, imports]) => {\n                const aliasMap = this._aliases.get(module) ?? {};\n                const joinedImports = [...imports].map(i => (aliasMap[i] ? `${i} as ${aliasMap[i]}` : i));\n                return [module, new Set(joinedImports)];\n            }),\n        );\n\n        // Resolve dependency mappings.\n        const dependencyMap = {\n            ...(useGranularImports ? DEFAULT_GRANULAR_EXTERNAL_MODULE_MAP : DEFAULT_EXTERNAL_MODULE_MAP),\n            ...DEFAULT_INTERNAL_MODULE_MAP,\n            ...dependencies,\n        };\n        const resolvedMap = new Map<string, Set<string>>();\n        aliasedMap.forEach((imports, module) => {\n            const resolvedModule: string = dependencyMap[module] ?? module;\n            const currentImports = resolvedMap.get(resolvedModule) ?? new Set();\n            imports.forEach(i => currentImports.add(i));\n            resolvedMap.set(resolvedModule, currentImports);\n        });\n\n        return resolvedMap;\n    }\n\n    toString(dependencies: Record<string, string> = {}, useGranularImports = false): string {\n        return [...this.resolve(dependencies, useGranularImports).entries()]\n            .sort(([a], [b]) => {\n                const aIsRelative = a.startsWith('.');\n                const bIsRelative = b.startsWith('.');\n                if (aIsRelative && !bIsRelative) return 1;\n                if (!aIsRelative && bIsRelative) return -1;\n                return a.localeCompare(b);\n            })\n            .map(([module, imports]) => {\n                const joinedImports = [...imports]\n                    .sort()\n                    .filter(i => {\n                        // import of a type can either be '<Type>' or 'type <Type>', so\n                        // we filter out 'type <Type>' variation if there is a '<Type>'\n                        const name = i.split(' ');\n                        if (name.length > 1) {\n                            return !imports.has(name[1]);\n                        }\n                        return true;\n                    })\n                    .join(', ');\n                return `import { ${joinedImports} } from '${module}';`;\n            })\n            .join('\\n');\n    }\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getAccountFetchHelpersFragment(\n    scope: Pick<GlobalFragmentScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const hasCustomData = customAccountData.has(accountNode.name);\n    const accountTypeFragment = hasCustomData\n        ? typeManifest.strictType.clone()\n        : fragment(nameApi.dataType(accountNode.name));\n    const decoderFunctionFragment = hasCustomData\n        ? typeManifest.decoder.clone()\n        : fragment(`${nameApi.decoderFunction(accountNode.name)}()`);\n\n    return fragmentFromTemplate('accountFetchHelpers.njk', {\n        accountType: accountTypeFragment.render,\n        decodeFunction: nameApi.accountDecodeFunction(accountNode.name),\n        decoderFunction: decoderFunctionFragment.render,\n        fetchAllFunction: nameApi.accountFetchAllFunction(accountNode.name),\n        fetchAllMaybeFunction: nameApi.accountFetchAllMaybeFunction(accountNode.name),\n        fetchFunction: nameApi.accountFetchFunction(accountNode.name),\n        fetchMaybeFunction: nameApi.accountFetchMaybeFunction(accountNode.name),\n    })\n        .mergeImportsWith(accountTypeFragment, decoderFunctionFragment)\n        .addImports('solanaAddresses', ['type Address'])\n        .addImports('solanaAccounts', [\n            'type Account',\n            'assertAccountExists',\n            'assertAccountsExist',\n            'decodeAccount',\n            'type EncodedAccount',\n            'fetchEncodedAccount',\n            'fetchEncodedAccounts',\n            'type FetchAccountConfig',\n            'type FetchAccountsConfig',\n            'type MaybeAccount',\n            'type MaybeEncodedAccount',\n        ]);\n}\n","import { join } from 'node:path';\n\nimport { ConfigureOptions } from 'nunjucks';\n\nimport { ImportMap } from '../ImportMap';\nimport { render } from '../utils';\n\nexport function fragment(render: string, imports?: ImportMap): Fragment {\n    return new Fragment(render, imports);\n}\n\nexport function fragmentFromTemplate(fragmentFile: string, context?: object, options?: ConfigureOptions): Fragment {\n    return fragment(render(join('fragments', fragmentFile), context, options));\n}\n\nexport function mergeFragments(fragments: Fragment[], mergeRenders: (renders: string[]) => string): Fragment {\n    return new Fragment(\n        mergeRenders(fragments.map(f => f.render)),\n        new ImportMap().mergeWith(...fragments),\n        new Set(fragments.flatMap(f => [...f.features])),\n    );\n}\n\nexport class Fragment {\n    public render: string;\n\n    public imports: ImportMap;\n\n    public features: Set<FragmentFeature>;\n\n    constructor(render: string, imports?: ImportMap, features?: Set<FragmentFeature>) {\n        this.render = render;\n        this.imports = imports ? new ImportMap().mergeWith(imports) : new ImportMap();\n        this.features = new Set([...(features ?? [])]);\n    }\n\n    setRender(render: string): this {\n        this.render = render;\n        return this;\n    }\n\n    mapRender(fn: (render: string) => string): this {\n        this.render = fn(this.render);\n        return this;\n    }\n\n    addImports(module: string, imports: Set<string> | string[] | string): this {\n        this.imports.add(module, imports);\n        return this;\n    }\n\n    removeImports(module: string, imports: Set<string> | string[] | string): this {\n        this.imports.remove(module, imports);\n        return this;\n    }\n\n    mergeImportsWith(...others: (Fragment | ImportMap)[]): this {\n        this.imports.mergeWith(...others);\n        return this;\n    }\n\n    addImportAlias(module: string, name: string, alias: string): this {\n        this.imports.addAlias(module, name, alias);\n        return this;\n    }\n\n    addFeatures(features: FragmentFeature | FragmentFeature[]): this {\n        const featureArray = typeof features === 'string' ? [features] : features;\n        featureArray.forEach(f => this.features.add(f));\n        return this;\n    }\n\n    removeFeatures(features: FragmentFeature | FragmentFeature[]): this {\n        const featureArray = typeof features === 'string' ? [features] : features;\n        featureArray.forEach(f => this.features.delete(f));\n        return this;\n    }\n\n    hasFeatures(features: FragmentFeature | FragmentFeature[]): boolean {\n        const featureArray = typeof features === 'string' ? [features] : features;\n        return featureArray.every(f => this.features.has(f));\n    }\n\n    mergeFeaturesWith(...others: Fragment[]): this {\n        others.forEach(f => this.addFeatures([...f.features]));\n        return this;\n    }\n\n    clone(): Fragment {\n        return new Fragment(this.render).mergeImportsWith(this.imports);\n    }\n\n    toString(): string {\n        return this.render;\n    }\n}\n\nexport type FragmentFeature = 'instruction:resolverScopeVariable';\n","import {\n    AccountValueNode,\n    accountValueNode,\n    ArgumentValueNode,\n    argumentValueNode,\n    CamelCaseString,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n} from '@codama/nodes';\nimport { deduplicateInstructionDependencies, ResolvedInstructionInput } from '@codama/visitors-core';\n\nexport function hasAsyncFunction(\n    instructionNode: InstructionNode,\n    resolvedInputs: ResolvedInstructionInput[],\n    asyncResolvers: string[],\n): boolean {\n    const hasByteDeltasAsync = (instructionNode.byteDeltas ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n    const hasRemainingAccountsAsync = (instructionNode.remainingAccounts ?? []).some(\n        ({ value }) => isNode(value, 'resolverValueNode') && asyncResolvers.includes(value.name),\n    );\n\n    return hasAsyncDefaultValues(resolvedInputs, asyncResolvers) || hasByteDeltasAsync || hasRemainingAccountsAsync;\n}\n\nexport function hasAsyncDefaultValues(resolvedInputs: ResolvedInstructionInput[], asyncResolvers: string[]): boolean {\n    return resolvedInputs.some(\n        input => !!input.defaultValue && isAsyncDefaultValue(input.defaultValue, asyncResolvers),\n    );\n}\n\nexport function isAsyncDefaultValue(defaultValue: InstructionInputValueNode, asyncResolvers: string[]): boolean {\n    switch (defaultValue.kind) {\n        case 'pdaValueNode':\n            return true;\n        case 'resolverValueNode':\n            return asyncResolvers.includes(defaultValue.name);\n        case 'conditionalValueNode':\n            return (\n                isAsyncDefaultValue(defaultValue.condition, asyncResolvers) ||\n                (defaultValue.ifFalse == null ? false : isAsyncDefaultValue(defaultValue.ifFalse, asyncResolvers)) ||\n                (defaultValue.ifTrue == null ? false : isAsyncDefaultValue(defaultValue.ifTrue, asyncResolvers))\n            );\n        default:\n            return false;\n    }\n}\n\nexport function getInstructionDependencies(\n    input: InstructionAccountNode | InstructionArgumentNode | InstructionNode,\n    asyncResolvers: string[],\n    useAsync: boolean,\n): (AccountValueNode | ArgumentValueNode)[] {\n    if (isNode(input, 'instructionNode')) {\n        return deduplicateInstructionDependencies([\n            ...input.accounts.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...input.arguments.flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n            ...(input.extraArguments ?? []).flatMap(x => getInstructionDependencies(x, asyncResolvers, useAsync)),\n        ]);\n    }\n\n    if (!input.defaultValue) return [];\n\n    const getNestedDependencies = (\n        defaultValue: InstructionInputValueNode | undefined,\n    ): (AccountValueNode | ArgumentValueNode)[] => {\n        if (!defaultValue) return [];\n        return getInstructionDependencies({ ...input, defaultValue }, asyncResolvers, useAsync);\n    };\n\n    if (isNode(input.defaultValue, ['accountValueNode', 'accountBumpValueNode'])) {\n        return [accountValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, ['argumentValueNode'])) {\n        return [argumentValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, 'pdaValueNode')) {\n        const dependencies = new Map<CamelCaseString, AccountValueNode | ArgumentValueNode>();\n        input.defaultValue.seeds.forEach(seed => {\n            if (isNode(seed.value, ['accountValueNode', 'argumentValueNode'])) {\n                dependencies.set(seed.value.name, { ...seed.value });\n            }\n        });\n        return [...dependencies.values()];\n    }\n\n    if (isNode(input.defaultValue, 'resolverValueNode')) {\n        const isSynchronousResolver = !asyncResolvers.includes(input.defaultValue.name);\n        if (useAsync || isSynchronousResolver) {\n            return input.defaultValue.dependsOn ?? [];\n        }\n    }\n\n    if (isNode(input.defaultValue, 'conditionalValueNode')) {\n        return deduplicateInstructionDependencies([\n            ...getNestedDependencies(input.defaultValue.condition),\n            ...getNestedDependencies(input.defaultValue.ifTrue),\n            ...getNestedDependencies(input.defaultValue.ifFalse),\n        ]);\n    }\n\n    return [];\n}\n","import { BytesValueNode } from '@codama/nodes';\nimport { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport function getBytesFromBytesValueNode(node: BytesValueNode): Uint8Array {\n    switch (node.encoding) {\n        case 'utf8':\n            return getUtf8Encoder().encode(node.data) as Uint8Array;\n        case 'base16':\n            return getBase16Encoder().encode(node.data) as Uint8Array;\n        case 'base58':\n            return getBase58Encoder().encode(node.data) as Uint8Array;\n        case 'base64':\n        default:\n            return getBase64Encoder().encode(node.data) as Uint8Array;\n    }\n}\n","import {\n    AccountNode,\n    camelCase,\n    CamelCaseString,\n    DefinedTypeLinkNode,\n    definedTypeLinkNode,\n    DefinedTypeNode,\n    definedTypeNode,\n    InstructionNode,\n    isNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\n\nexport type CustomDataOptions =\n    | string\n    | {\n          extract?: boolean;\n          extractAs?: string;\n          importAs?: string;\n          importFrom?: string;\n          name: string;\n      };\n\nexport type ParsedCustomDataOptions = Map<\n    CamelCaseString,\n    {\n        extract: boolean;\n        extractAs: CamelCaseString;\n        importAs: CamelCaseString;\n        importFrom: string;\n        linkNode: DefinedTypeLinkNode;\n    }\n>;\n\nexport const parseCustomDataOptions = (\n    customDataOptions: CustomDataOptions[],\n    defaultSuffix: string,\n): ParsedCustomDataOptions =>\n    new Map(\n        customDataOptions.map(o => {\n            const options = typeof o === 'string' ? { name: o } : o;\n            const importAs = camelCase(options.importAs ?? `${options.name}${defaultSuffix}`);\n            const importFrom = options.importFrom ?? 'hooked';\n            return [\n                camelCase(options.name),\n                {\n                    extract: options.extract ?? false,\n                    extractAs: options.extractAs ? camelCase(options.extractAs) : importAs,\n                    importAs,\n                    importFrom,\n                    linkNode: definedTypeLinkNode(importAs),\n                },\n            ];\n        }),\n    );\n\nexport const getDefinedTypeNodesToExtract = (\n    nodes: AccountNode[] | InstructionNode[],\n    parsedCustomDataOptions: ParsedCustomDataOptions,\n): DefinedTypeNode[] =>\n    nodes.flatMap(node => {\n        const options = parsedCustomDataOptions.get(node.name);\n        if (!options || !options.extract) return [];\n\n        if (isNode(node, 'accountNode')) {\n            return [definedTypeNode({ name: options.extractAs, type: { ...node.data } })];\n        }\n\n        return [\n            definedTypeNode({\n                name: options.extractAs,\n                type: structTypeNodeFromInstructionArgumentNodes(node.arguments),\n            }),\n        ];\n    });\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport {\n    AccountLinkNode,\n    DefinedTypeLinkNode,\n    InstructionLinkNode,\n    PdaLinkNode,\n    ProgramLinkNode,\n    ResolverValueNode,\n} from '@codama/nodes';\n\nimport { ParsedCustomDataOptions } from './customData';\n\nexport type LinkOverrides = {\n    accounts?: Record<string, string>;\n    definedTypes?: Record<string, string>;\n    instructions?: Record<string, string>;\n    pdas?: Record<string, string>;\n    programs?: Record<string, string>;\n    resolvers?: Record<string, string>;\n};\n\ntype OverridableNodes =\n    | AccountLinkNode\n    | DefinedTypeLinkNode\n    | InstructionLinkNode\n    | PdaLinkNode\n    | ProgramLinkNode\n    | ResolverValueNode;\n\nexport type GetImportFromFunction = (node: OverridableNodes, fallback?: string) => string;\n\nexport function getImportFromFactory(\n    overrides: LinkOverrides,\n    customAccountData: ParsedCustomDataOptions,\n    customInstructionData: ParsedCustomDataOptions,\n): GetImportFromFunction {\n    const customDataOverrides = Object.fromEntries(\n        [...customAccountData.values(), ...customInstructionData.values()].map(({ importFrom, importAs }) => [\n            importAs,\n            importFrom,\n        ]),\n    );\n    const linkOverrides = {\n        accounts: overrides.accounts ?? {},\n        definedTypes: { ...customDataOverrides, ...overrides.definedTypes },\n        instructions: overrides.instructions ?? {},\n        pdas: overrides.pdas ?? {},\n        programs: overrides.programs ?? {},\n        resolvers: overrides.resolvers ?? {},\n    };\n\n    return (node: OverridableNodes) => {\n        const kind = node.kind;\n        switch (kind) {\n            case 'accountLinkNode':\n                return linkOverrides.accounts[node.name] ?? 'generatedAccounts';\n            case 'definedTypeLinkNode':\n                return linkOverrides.definedTypes[node.name] ?? 'generatedTypes';\n            case 'instructionLinkNode':\n                return linkOverrides.instructions[node.name] ?? 'generatedInstructions';\n            case 'pdaLinkNode':\n                return linkOverrides.pdas[node.name] ?? 'generatedPdas';\n            case 'programLinkNode':\n                return linkOverrides.programs[node.name] ?? 'generatedPrograms';\n            case 'resolverValueNode':\n                return linkOverrides.resolvers[node.name] ?? 'hooked';\n            default:\n                throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n                    expectedKinds: [\n                        'AccountLinkNode',\n                        'DefinedTypeLinkNode',\n                        'InstructionLinkNode',\n                        'PdaLinkNode',\n                        'ProgramLinkNode',\n                        'resolverValueNode',\n                    ],\n                    kind: kind satisfies never,\n                    node,\n                });\n        }\n    };\n}\n","import { dirname as pathDirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport { camelCase, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\nimport nunjucks, { ConfigureOptions as NunJucksOptions } from 'nunjucks';\n\nexport function jsDocblock(docs: string[]): string {\n    if (docs.length <= 0) return '';\n    if (docs.length === 1) return `/** ${docs[0]} */\\n`;\n    const lines = docs.map(doc => ` * ${doc}`);\n    return `/**\\n${lines.join('\\n')}\\n */\\n`;\n}\n\nexport const render = (template: string, context?: object, options?: NunJucksOptions): string => {\n    // @ts-expect-error import.meta will be used in the right environment.\n    const dirname = __ESM__ ? pathDirname(fileURLToPath(import.meta.url)) : __dirname;\n    const templates = __TEST__ ? join(dirname, '..', '..', 'public', 'templates') : join(dirname, 'templates'); // Path to templates from bundled output file.\n    const env = nunjucks.configure(templates, { autoescape: false, trimBlocks: true, ...options });\n    env.addFilter('pascalCase', pascalCase);\n    env.addFilter('camelCase', camelCase);\n    env.addFilter('snakeCase', snakeCase);\n    env.addFilter('kebabCase', kebabCase);\n    env.addFilter('titleCase', titleCase);\n    env.addFilter('jsDocblock', jsDocblock);\n    return env.render(template, context);\n};\n","import { AccountNode, isNodeFilter } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport type { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getAccountPdaHelpersFragment(\n    scope: Pick<GlobalFragmentScope, 'customAccountData' | 'linkables' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment {\n    const { accountPath, nameApi, linkables, customAccountData, typeManifest } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    const programNode = findProgramNodeFromPath(accountPath)!;\n    const pdaNode = accountNode.pda ? linkables.get([...accountPath, accountNode.pda]) : undefined;\n    if (!pdaNode) {\n        return fragment('');\n    }\n\n    const accountTypeFragment = customAccountData.has(accountNode.name)\n        ? typeManifest.strictType.clone()\n        : fragment(nameApi.dataType(accountNode.name));\n\n    // Here we cannot use the `getImportFrom` function because\n    // we need to know the seeds of the PDA in order to know\n    // if we need to render a `seeds` argument or not.\n    const importFrom = 'generatedPdas';\n    const pdaSeedsType = nameApi.pdaSeedsType(pdaNode.name);\n    const findPdaFunction = nameApi.pdaFindFunction(pdaNode.name);\n    const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n\n    return fragmentFromTemplate('accountPdaHelpers.njk', {\n        accountType: accountTypeFragment.render,\n        fetchFromSeedsFunction: nameApi.accountFetchFromSeedsFunction(accountNode.name),\n        fetchFunction: nameApi.accountFetchFunction(accountNode.name),\n        fetchMaybeFromSeedsFunction: nameApi.accountFetchMaybeFromSeedsFunction(accountNode.name),\n        fetchMaybeFunction: nameApi.accountFetchMaybeFunction(accountNode.name),\n        findPdaFunction,\n        hasVariableSeeds,\n        pdaSeedsType,\n        program: programNode,\n    })\n        .mergeImportsWith(accountTypeFragment)\n        .addImports(importFrom, hasVariableSeeds ? [pdaSeedsType, findPdaFunction] : [findPdaFunction])\n        .addImports('solanaAddresses', ['type Address'])\n        .addImports('solanaAccounts', [\n            'type Account',\n            'assertAccountExists',\n            'type FetchAccountConfig',\n            'type MaybeAccount',\n        ]);\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getAccountSizeHelpersFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & { accountPath: NodePath<AccountNode> },\n): Fragment {\n    const { accountPath, nameApi } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n    if (accountNode.size == null) {\n        return fragment('');\n    }\n\n    return fragmentFromTemplate('accountSizeHelpers.njk', {\n        account: accountNode,\n        getSizeFunction: nameApi.accountGetSizeFunction(accountNode.name),\n    });\n}\n","import { AccountNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment } from './common';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getAccountTypeFragment(\n    scope: Pick<GlobalFragmentScope, 'customAccountData' | 'nameApi'> & {\n        accountPath: NodePath<AccountNode>;\n        typeManifest: TypeManifest;\n    },\n): Fragment {\n    const { accountPath, typeManifest, nameApi, customAccountData } = scope;\n    const accountNode = getLastNodeFromPath(accountPath);\n\n    if (customAccountData.has(accountNode.name)) {\n        return fragment('');\n    }\n\n    return getTypeWithCodecFragment({\n        manifest: typeManifest,\n        name: accountNode.name,\n        nameApi,\n    });\n}\n","import type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getTypeFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: TypeManifest;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi, docs = [] } = scope;\n    const typeFragment = fragmentFromTemplate('type.njk', {\n        docs,\n        looseName: nameApi.dataArgsType(name),\n        manifest,\n        strictName: nameApi.dataType(name),\n    });\n\n    if (!manifest.isEnum) {\n        typeFragment.mergeImportsWith(manifest.strictType, manifest.looseType);\n    }\n\n    return typeFragment;\n}\n","import type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getTypeDecoderFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'decoder'>;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi, docs = [] } = scope;\n    return fragmentFromTemplate('typeDecoder.njk', {\n        decoderFunction: nameApi.decoderFunction(name),\n        docs,\n        looseName: nameApi.dataArgsType(name),\n        manifest,\n        strictName: nameApi.dataType(name),\n    })\n        .mergeImportsWith(manifest.decoder)\n        .addImports('solanaCodecsCore', 'type Decoder');\n}\n","import type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getTypeEncoderFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        docs?: string[];\n        manifest: Pick<TypeManifest, 'encoder'>;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi, docs = [] } = scope;\n    return fragmentFromTemplate('typeEncoder.njk', {\n        docs,\n        encoderFunction: nameApi.encoderFunction(name),\n        looseName: nameApi.dataArgsType(name),\n        manifest,\n        strictName: nameApi.dataType(name),\n    })\n        .mergeImportsWith(manifest.encoder)\n        .addImports('solanaCodecsCore', 'type Encoder');\n}\n","import { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragmentFromTemplate, mergeFragments } from './common';\nimport { getTypeDecoderFragment } from './typeDecoder';\nimport { getTypeEncoderFragment } from './typeEncoder';\n\nexport function getTypeCodecFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: Pick<TypeManifest, 'decoder' | 'encoder'>;\n        name: string;\n    },\n): Fragment {\n    const { name, manifest, nameApi } = scope;\n    return mergeFragments(\n        [\n            getTypeEncoderFragment({ ...scope, docs: scope.encoderDocs }),\n            getTypeDecoderFragment({ ...scope, docs: scope.decoderDocs }),\n            fragmentFromTemplate('typeCodec.njk', {\n                codecFunction: nameApi.codecFunction(name),\n                decoderFunction: nameApi.decoderFunction(name),\n                docs: scope.codecDocs,\n                encoderFunction: nameApi.encoderFunction(name),\n                looseName: nameApi.dataArgsType(name),\n                manifest,\n                strictName: nameApi.dataType(name),\n            }).addImports('solanaCodecsCore', ['type Codec', 'combineCodec']),\n        ],\n        renders => renders.join('\\n\\n'),\n    );\n}\n","import type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, mergeFragments } from './common';\nimport { getTypeFragment } from './type';\nimport { getTypeCodecFragment } from './typeCodec';\n\nexport function getTypeWithCodecFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        codecDocs?: string[];\n        decoderDocs?: string[];\n        encoderDocs?: string[];\n        manifest: TypeManifest;\n        name: string;\n        typeDocs?: string[];\n    },\n): Fragment {\n    return mergeFragments([getTypeFragment({ ...scope, docs: scope.typeDocs }), getTypeCodecFragment(scope)], renders =>\n        renders.join('\\n\\n'),\n    );\n}\n","import {\n    type ConstantDiscriminatorNode,\n    constantDiscriminatorNode,\n    constantValueNode,\n    constantValueNodeFromBytes,\n    type DiscriminatorNode,\n    type FieldDiscriminatorNode,\n    isNode,\n    isNodeFilter,\n    type ProgramNode,\n    type SizeDiscriminatorNode,\n    type StructTypeNode,\n} from '@codama/nodes';\nimport { visit } from '@codama/visitors-core';\nimport { getBase64Decoder } from '@solana/codecs-strings';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\n\n/**\n * ```\n * if (data.length === 72) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, getU32Encoder().encode(42), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n *\n * if (containsBytes(data, new Uint8Array([1, 2, 3]), offset)) {\n *   return splTokenAccounts.TOKEN;\n * }\n * ```\n */\nexport function getDiscriminatorConditionFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        dataName: string;\n        discriminators: DiscriminatorNode[];\n        ifTrue: string;\n        programNode: ProgramNode;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    return mergeFragments(\n        scope.discriminators.flatMap(discriminator => {\n            if (isNode(discriminator, 'sizeDiscriminatorNode')) {\n                return [getSizeConditionFragment(discriminator, scope)];\n            }\n            if (isNode(discriminator, 'constantDiscriminatorNode')) {\n                return [getByteConditionFragment(discriminator, scope)];\n            }\n            if (isNode(discriminator, 'fieldDiscriminatorNode')) {\n                return [getFieldConditionFragment(discriminator, scope)];\n            }\n            return [];\n        }),\n        r => r.join(' && '),\n    ).mapRender(r => `if (${r}) { ${scope.ifTrue}; }`);\n}\n\nfunction getSizeConditionFragment(\n    discriminator: SizeDiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName } = scope;\n    return fragment(`${dataName}.length === ${discriminator.size}`);\n}\n\nfunction getByteConditionFragment(\n    discriminator: ConstantDiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'typeManifestVisitor'> & {\n        dataName: string;\n    },\n): Fragment {\n    const { dataName, typeManifestVisitor } = scope;\n    const constant = visit(discriminator.constant, typeManifestVisitor).value;\n    return constant\n        .mapRender(r => `containsBytes(${dataName}, ${r}, ${discriminator.offset})`)\n        .addImports('solanaCodecsCore', 'containsBytes');\n}\n\nfunction getFieldConditionFragment(\n    discriminator: FieldDiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'typeManifestVisitor'> & {\n        dataName: string;\n        struct: StructTypeNode;\n    },\n): Fragment {\n    const field = scope.struct.fields.find(f => f.name === discriminator.name);\n    if (!field || !field.defaultValue) {\n        // TODO: Coded error.\n        throw new Error(\n            `Field discriminator \"${discriminator.name}\" does not have a matching argument with default value.`,\n        );\n    }\n\n    // This handles the case where a field uses an u8 array to represent its discriminator.\n    // In this case, we can simplify the generated code by delegating to a constantDiscriminatorNode.\n    if (\n        isNode(field.type, 'arrayTypeNode') &&\n        isNode(field.type.item, 'numberTypeNode') &&\n        field.type.item.format === 'u8' &&\n        isNode(field.type.count, 'fixedCountNode') &&\n        isNode(field.defaultValue, 'arrayValueNode') &&\n        field.defaultValue.items.every(isNodeFilter('numberValueNode'))\n    ) {\n        const base64Bytes = getBase64Decoder().decode(\n            new Uint8Array(field.defaultValue.items.map(node => node.number)),\n        );\n        return getByteConditionFragment(\n            constantDiscriminatorNode(constantValueNodeFromBytes('base64', base64Bytes), discriminator.offset),\n            scope,\n        );\n    }\n\n    return getByteConditionFragment(\n        constantDiscriminatorNode(constantValueNode(field.type, field.defaultValue), discriminator.offset),\n        scope,\n    );\n}\n","import { InstructionAccountNode, pascalCase } from '@codama/nodes';\n\nimport { Fragment, fragment } from './common';\n\nexport function getInstructionAccountMetaFragment(instructionAccountNode: InstructionAccountNode): Fragment {\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n\n    // Writable, signer.\n    if (instructionAccountNode.isSigner === true && instructionAccountNode.isWritable) {\n        return fragment(`WritableSignerAccount<${typeParam}> & IAccountSignerMeta<${typeParam}>`)\n            .addImports('solanaInstructions', ['type WritableSignerAccount'])\n            .addImports('solanaSigners', ['type IAccountSignerMeta']);\n    }\n\n    // Readonly, signer.\n    if (instructionAccountNode.isSigner === true) {\n        return fragment(`ReadonlySignerAccount<${typeParam}> & IAccountSignerMeta<${typeParam}>`)\n            .addImports('solanaInstructions', ['type ReadonlySignerAccount'])\n            .addImports('solanaSigners', ['type IAccountSignerMeta']);\n    }\n\n    // Writable, non-signer or optional signer.\n    if (instructionAccountNode.isWritable) {\n        return fragment(`WritableAccount<${typeParam}>`).addImports('solanaInstructions', 'type WritableAccount');\n    }\n\n    // Readonly, non-signer or optional signer.\n    return fragment(`ReadonlyAccount<${typeParam}>`).addImports('solanaInstructions', 'type ReadonlyAccount');\n}\n","import { InstructionAccountNode, InstructionInputValueNode, pascalCase } from '@codama/nodes';\nimport {\n    findInstructionNodeFromPath,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    LinkableDictionary,\n    NodePath,\n} from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { ImportMap } from '../ImportMap';\nimport { Fragment, fragment } from './common';\n\nexport function getInstructionAccountTypeParamFragment(\n    scope: Pick<GlobalFragmentScope, 'linkables'> & {\n        allowAccountMeta: boolean;\n        instructionAccountPath: NodePath<InstructionAccountNode>;\n    },\n): Fragment {\n    const { instructionAccountPath, allowAccountMeta, linkables } = scope;\n    const instructionAccountNode = getLastNodeFromPath(instructionAccountPath);\n    const instructionNode = findInstructionNodeFromPath(instructionAccountPath)!;\n    const programNode = findProgramNodeFromPath(instructionAccountPath)!;\n    const typeParam = `TAccount${pascalCase(instructionAccountNode.name)}`;\n    const accountMeta = allowAccountMeta ? ' | IAccountMeta<string>' : '';\n    const imports = new ImportMap();\n    if (allowAccountMeta) {\n        imports.add('solanaInstructions', 'type IAccountMeta');\n    }\n\n    if (instructionNode.optionalAccountStrategy === 'omitted' && instructionAccountNode.isOptional) {\n        return fragment(`${typeParam} extends string${accountMeta} | undefined = undefined`, imports);\n    }\n\n    const defaultAddress = getDefaultAddress(instructionAccountNode.defaultValue, programNode.publicKey, linkables);\n\n    return fragment(`${typeParam} extends string${accountMeta} = ${defaultAddress}`, imports);\n}\n\nfunction getDefaultAddress(\n    defaultValue: InstructionInputValueNode | undefined,\n    programId: string,\n    linkables: LinkableDictionary,\n): string {\n    switch (defaultValue?.kind) {\n        case 'publicKeyValueNode':\n            return `\"${defaultValue.publicKey}\"`;\n        case 'programLinkNode':\n            // eslint-disable-next-line no-case-declarations\n            const programNode = linkables.get([defaultValue]);\n            return programNode ? `\"${programNode.publicKey}\"` : 'string';\n        case 'programIdValueNode':\n            return `\"${programId}\"`;\n        default:\n            return 'string';\n    }\n}\n","import { assertIsNode, camelCase, InstructionByteDeltaNode, InstructionNode, isNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\n\nexport function getInstructionByteDeltaFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment {\n    const { byteDeltas } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (byteDeltas ?? []).flatMap(r => getByteDeltaFragment(r, scope));\n    if (fragments.length === 0) return fragment('');\n    return mergeFragments(\n        fragments,\n        r =>\n            `// Bytes created or reallocated by the instruction.\\n` +\n            `const byteDelta: number = [${r.join(',')}].reduce((a, b) => a + b, 0);`,\n    );\n}\n\nfunction getByteDeltaFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment[] {\n    const bytesFragment = ((): Fragment | null => {\n        if (isNode(byteDelta.value, 'numberValueNode')) {\n            return getNumberValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(byteDelta);\n        }\n        if (isNode(byteDelta.value, 'accountLinkNode')) {\n            return getAccountLinkNodeFragment(byteDelta, scope);\n        }\n        if (isNode(byteDelta.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(byteDelta, scope);\n        }\n        return null;\n    })();\n\n    if (bytesFragment === null) return [];\n\n    if (byteDelta.withHeader) {\n        bytesFragment.mapRender(r => `${r} + BASE_ACCOUNT_SIZE`).addImports('solanaAccounts', 'BASE_ACCOUNT_SIZE');\n    }\n\n    if (byteDelta.subtract) {\n        bytesFragment.mapRender(r => `- (${r})`);\n    }\n\n    return [bytesFragment];\n}\n\nfunction getNumberValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'numberValueNode');\n    return fragment(byteDelta.value.number.toString());\n}\n\nfunction getArgumentValueNodeFragment(byteDelta: InstructionByteDeltaNode): Fragment {\n    assertIsNode(byteDelta.value, 'argumentValueNode');\n    const argumentName = camelCase(byteDelta.value.name);\n    return fragment(`Number(args.${argumentName})`);\n}\n\nfunction getAccountLinkNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<GlobalFragmentScope, 'getImportFrom' | 'nameApi'>,\n): Fragment {\n    assertIsNode(byteDelta.value, 'accountLinkNode');\n    const functionName = scope.nameApi.accountGetSizeFunction(byteDelta.value.name);\n    return fragment(`${functionName}()`).addImports(scope.getImportFrom(byteDelta.value), functionName);\n}\n\nfunction getResolverValueNodeFragment(\n    byteDelta: InstructionByteDeltaNode,\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(byteDelta.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(byteDelta.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = scope.nameApi.resolverFunction(byteDelta.value.name);\n    return fragment(`${awaitKeyword}${functionName}(resolverScope)`)\n        .addImports(scope.getImportFrom(byteDelta.value), functionName)\n        .addFeatures(['instruction:resolverScopeVariable']);\n}\n","import { InstructionNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment } from './common';\nimport { getTypeWithCodecFragment } from './typeWithCodec';\n\nexport function getInstructionDataFragment(\n    scope: Pick<GlobalFragmentScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if (instructionNode.arguments.length === 0 || customInstructionData.has(instructionNode.name)) {\n        return fragment('');\n    }\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    return getTypeWithCodecFragment({\n        manifest: dataArgsManifest,\n        name: instructionDataName,\n        nameApi,\n    });\n}\n","import {\n    camelCase,\n    ConstantDiscriminatorNode,\n    DiscriminatorNode,\n    FieldDiscriminatorNode,\n    InstructionArgumentNode,\n    isNode,\n    isNodeFilter,\n    StructFieldTypeNode,\n    VALUE_NODES,\n} from '@codama/nodes';\nimport { visit } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, mergeFragments } from './common';\n\nexport function getDiscriminatorConstantsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment {\n    const fragments = scope.discriminatorNodes\n        .map(node => getDiscriminatorConstantFragment(node, scope))\n        .filter(Boolean) as Fragment[];\n\n    return mergeFragments(fragments, r => r.join('\\n\\n'));\n}\n\nexport function getDiscriminatorConstantFragment(\n    discriminatorNode: DiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    switch (discriminatorNode.kind) {\n        case 'constantDiscriminatorNode':\n            return getConstantDiscriminatorConstantFragment(discriminatorNode, scope);\n        case 'fieldDiscriminatorNode':\n            return getFieldDiscriminatorConstantFragment(discriminatorNode, scope);\n        default:\n            return null;\n    }\n}\n\nexport function getConstantDiscriminatorConstantFragment(\n    discriminatorNode: ConstantDiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        discriminatorNodes: DiscriminatorNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { discriminatorNodes, typeManifestVisitor, prefix } = scope;\n\n    const index = discriminatorNodes.filter(isNodeFilter('constantDiscriminatorNode')).indexOf(discriminatorNode);\n    const suffix = index <= 0 ? '' : `_${index + 1}`;\n\n    const name = camelCase(`${prefix}_discriminator${suffix}`);\n    const encoder = visit(discriminatorNode.constant.type, typeManifestVisitor).encoder;\n    const value = visit(discriminatorNode.constant.value, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nexport function getFieldDiscriminatorConstantFragment(\n    discriminatorNode: FieldDiscriminatorNode,\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        fields: InstructionArgumentNode[] | StructFieldTypeNode[];\n        prefix: string;\n    },\n): Fragment | null {\n    const { fields, prefix, typeManifestVisitor } = scope;\n\n    const field = fields.find(f => f.name === discriminatorNode.name);\n    if (!field || !field.defaultValue || !isNode(field.defaultValue, VALUE_NODES)) {\n        return null;\n    }\n\n    const name = camelCase(`${prefix}_${discriminatorNode.name}`);\n    const encoder = visit(field.type, typeManifestVisitor).encoder;\n    const value = visit(field.defaultValue, typeManifestVisitor).value;\n    return getConstantFragment({ ...scope, encoder, name, value });\n}\n\nfunction getConstantFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        encoder: Fragment;\n        name: string;\n        value: Fragment;\n    },\n): Fragment {\n    const { encoder, name, nameApi, value } = scope;\n    const constantName = nameApi.constant(name);\n    const constantFunction = nameApi.constantFunction(name);\n\n    return mergeFragments(\n        [\n            value.mapRender(r => `export const ${constantName} = ${r};`),\n            encoder.mapRender(r => `export function ${constantFunction}() { return ${r}.encode(${constantName}); }`),\n        ],\n        r => r.join('\\n\\n'),\n    );\n}\n","import { InstructionNode } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getInstructionExtraArgsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, extraArgsManifest, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    if ((instructionNode.extraArguments ?? []).length === 0) {\n        return fragment('');\n    }\n\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    return fragmentFromTemplate('instructionExtraArgs.njk', {\n        looseName: nameApi.dataArgsType(instructionExtraName),\n        manifest: extraArgsManifest,\n        strictName: nameApi.dataType(instructionExtraName),\n    }).mergeImportsWith(extraArgsManifest.looseType);\n}\n","import { camelCase, InstructionArgumentNode, InstructionNode, isNode, isNodeFilter, pascalCase } from '@codama/nodes';\nimport {\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    NodePath,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { NameApi } from '../nameTransformers';\nimport { TypeManifest } from '../TypeManifest';\nimport { getInstructionDependencies, hasAsyncFunction, isAsyncDefaultValue } from '../utils';\nimport { Fragment, fragment, fragmentFromTemplate, mergeFragments } from './common';\nimport { getInstructionByteDeltaFragment } from './instructionByteDelta';\nimport { getInstructionInputResolvedFragment } from './instructionInputResolved';\nimport { getInstructionInputTypeFragment } from './instructionInputType';\nimport { getInstructionRemainingAccountsFragment } from './instructionRemainingAccounts';\n\nexport function getInstructionFunctionFragment(\n    scope: Pick<\n        GlobalFragmentScope,\n        'asyncResolvers' | 'customInstructionData' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'\n    > & {\n        dataArgsManifest: TypeManifest;\n        extraArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const {\n        useAsync,\n        instructionPath,\n        resolvedInputs,\n        renamedArgs,\n        dataArgsManifest,\n        asyncResolvers,\n        nameApi,\n        customInstructionData,\n    } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    if (useAsync && !hasAsyncFunction(instructionNode, resolvedInputs, asyncResolvers)) {\n        return fragment('');\n    }\n\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const hasLegacyOptionalAccounts =\n        instructionNode.optionalAccountStrategy === 'omitted' &&\n        instructionNode.accounts.some(account => account.isOptional);\n    const instructionDependencies = getInstructionDependencies(instructionNode, asyncResolvers, useAsync);\n    const argDependencies = instructionDependencies.filter(isNodeFilter('argumentValueNode')).map(node => node.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n    const argIsNotOmitted = (arg: InstructionArgumentNode) =>\n        !(arg.defaultValue && arg.defaultValueStrategy === 'omitted');\n    const argIsDependent = (arg: InstructionArgumentNode) => argDependencies.includes(arg.name);\n    const argHasDefaultValue = (arg: InstructionArgumentNode) => {\n        if (!arg.defaultValue) return false;\n        if (useAsync) return true;\n        return !isAsyncDefaultValue(arg.defaultValue, asyncResolvers);\n    };\n    const hasDataArgs = !!customData || instructionNode.arguments.filter(argIsNotOmitted).length > 0;\n    const hasExtraArgs =\n        (instructionNode.extraArguments ?? []).filter(\n            field => argIsNotOmitted(field) && (argIsDependent(field) || argHasDefaultValue(field)),\n        ).length > 0;\n    const hasRemainingAccountArgs =\n        (instructionNode.remainingAccounts ?? []).filter(({ value }) => isNode(value, 'argumentValueNode')).length > 0;\n    const hasAnyArgs = hasDataArgs || hasExtraArgs || hasRemainingAccountArgs;\n    const hasInput = hasAccounts || hasAnyArgs;\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n    const encoderFunction = customData\n        ? dataArgsManifest.encoder.render\n        : `${nameApi.encoderFunction(instructionDataName)}()`;\n    const argsTypeFragment = fragment(\n        customData ? dataArgsManifest.looseType.render : nameApi.dataArgsType(instructionDataName),\n    );\n    if (customData) {\n        argsTypeFragment.mergeImportsWith(dataArgsManifest.looseType, dataArgsManifest.encoder);\n    }\n\n    const functionName = useAsync\n        ? nameApi.instructionAsyncFunction(instructionNode.name)\n        : nameApi.instructionSyncFunction(instructionNode.name);\n\n    const typeParamsFragment = getTypeParams(instructionNode, programAddressConstant);\n    const instructionTypeFragment = getInstructionType(scope);\n\n    // Input.\n    const inputTypeFragment = getInstructionInputTypeFragment(scope);\n    const inputTypeCallFragment = getInputTypeCall(scope);\n    const renamedArgsText = [...renamedArgs.entries()].map(([k, v]) => `${k}: input.${v}`).join(', ');\n\n    const resolvedInputsFragment = getInstructionInputResolvedFragment(scope);\n    const remainingAccountsFragment = getInstructionRemainingAccountsFragment(scope);\n    const byteDeltaFragment = getInstructionByteDeltaFragment(scope);\n    const resolvedFragment = mergeFragments(\n        [resolvedInputsFragment, remainingAccountsFragment, byteDeltaFragment],\n        renders => renders.join('\\n\\n'),\n    );\n    const hasRemainingAccounts = remainingAccountsFragment.render !== '';\n    const hasByteDeltas = byteDeltaFragment.render !== '';\n    const hasResolver = resolvedFragment.hasFeatures('instruction:resolverScopeVariable');\n    const getReturnType = (instructionType: string) => {\n        let returnType = instructionType;\n        if (hasByteDeltas) {\n            returnType = `${returnType} & IInstructionWithByteDelta`;\n        }\n        return useAsync ? `Promise<${returnType}>` : returnType;\n    };\n\n    const functionFragment = fragmentFromTemplate('instructionFunction.njk', {\n        argsTypeFragment,\n        encoderFunction,\n        functionName,\n        getReturnType,\n        hasAccounts,\n        hasAnyArgs,\n        hasByteDeltas,\n        hasData,\n        hasDataArgs,\n        hasExtraArgs,\n        hasInput,\n        hasLegacyOptionalAccounts,\n        hasRemainingAccounts,\n        hasResolver,\n        inputTypeCallFragment,\n        inputTypeFragment,\n        instruction: instructionNode,\n        instructionTypeFragment,\n        programAddressConstant,\n        renamedArgs: renamedArgsText,\n        resolvedFragment,\n        typeParamsFragment,\n        useAsync,\n    })\n        .mergeImportsWith(\n            typeParamsFragment,\n            instructionTypeFragment,\n            inputTypeFragment,\n            inputTypeCallFragment,\n            resolvedFragment,\n            argsTypeFragment,\n        )\n        .addImports('generatedPrograms', [programAddressConstant])\n        .addImports('solanaAddresses', ['type Address']);\n\n    if (hasAccounts) {\n        functionFragment\n            .addImports('solanaInstructions', ['type IAccountMeta'])\n            .addImports('shared', ['getAccountMetaFactory', 'type ResolvedAccount']);\n    }\n\n    if (hasByteDeltas) {\n        functionFragment.addImports('shared', ['type IInstructionWithByteDelta']);\n    }\n\n    return functionFragment;\n}\n\nfunction getTypeParams(instructionNode: InstructionNode, programAddressConstant: string): Fragment {\n    const typeParams = instructionNode.accounts.map(account => `TAccount${pascalCase(account.name)} extends string`);\n    // after all accounts, add an optional type for program address\n    typeParams.push(`TProgramAddress extends Address = typeof ${programAddressConstant}`);\n    return fragment(typeParams.filter(x => !!x).join(', '))\n        .mapRender(r => `<${r}>`)\n        .addImports('generatedPrograms', [programAddressConstant]);\n}\n\nfunction getInstructionType(scope: { instructionPath: NodePath<InstructionNode>; nameApi: NameApi }): Fragment {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionTypeName = nameApi.instructionType(instructionNode.name);\n    const programAddressFragment = fragment('TProgramAddress');\n    const accountTypeParamsFragments = instructionNode.accounts.map(account => {\n        const typeParam = `TAccount${pascalCase(account.name)}`;\n        const camelName = camelCase(account.name);\n\n        if (account.isSigner === 'either') {\n            const signerRole = account.isWritable ? 'WritableSignerAccount' : 'ReadonlySignerAccount';\n            return fragment(\n                `typeof input[\"${camelName}\"] extends TransactionSigner<${typeParam}> ` +\n                    `? ${signerRole}<${typeParam}> & IAccountSignerMeta<${typeParam}> ` +\n                    `: ${typeParam}`,\n            )\n                .addImports('solanaInstructions', [`type ${signerRole}`])\n                .addImports('solanaSigners', ['type IAccountSignerMeta']);\n        }\n\n        return fragment(typeParam);\n    });\n\n    return mergeFragments([programAddressFragment, ...accountTypeParamsFragments], renders =>\n        renders.join(', '),\n    ).mapRender(r => `${instructionTypeName}<${r}>`);\n}\n\nfunction getInputTypeCall(scope: {\n    instructionPath: NodePath<InstructionNode>;\n    nameApi: NameApi;\n    useAsync: boolean;\n}): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const inputTypeName = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    if (instructionNode.accounts.length === 0) return fragment(inputTypeName);\n    const accountTypeParams = instructionNode.accounts.map(account => `TAccount${pascalCase(account.name)}`).join(', ');\n\n    return fragment(`${inputTypeName}<${accountTypeParams}>`);\n}\n","import { camelCase, InstructionNode, isNode, parseOptionalAccountStrategy } from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath, ResolvedInstructionInput } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\nimport { getInstructionInputDefaultFragment } from './instructionInputDefault';\n\nexport function getInstructionInputResolvedFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    const resolvedInputFragments = scope.resolvedInputs.flatMap((input: ResolvedInstructionInput): Fragment[] => {\n        const inputFragment = getInstructionInputDefaultFragment({\n            ...scope,\n            input,\n            optionalAccountStrategy: parseOptionalAccountStrategy(instructionNode.optionalAccountStrategy),\n        });\n        if (!inputFragment.render) return [];\n        const camelName = camelCase(input.name);\n        return [\n            inputFragment.mapRender(r =>\n                isNode(input, 'instructionArgumentNode')\n                    ? `if (!args.${camelName}) {\\n${r}\\n}`\n                    : `if (!accounts.${camelName}.value) {\\n${r}\\n}`,\n            ),\n        ];\n    });\n\n    if (resolvedInputFragments.length === 0) {\n        return fragment('');\n    }\n\n    return mergeFragments([fragment('// Resolve default values.'), ...resolvedInputFragments], renders =>\n        renders.join('\\n'),\n    );\n}\n","/* eslint-disable no-case-declarations */\nimport { camelCase, InstructionInputValueNode, isNode, OptionalAccountStrategy } from '@codama/nodes';\nimport { ResolvedInstructionInput, visit } from '@codama/visitors-core';\n\nimport { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { isAsyncDefaultValue } from '../utils';\nimport { Fragment, fragment, mergeFragments } from './common';\n\nexport function getInstructionInputDefaultFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi' | 'typeManifestVisitor'> & {\n        input: ResolvedInstructionInput;\n        optionalAccountStrategy: OptionalAccountStrategy;\n        useAsync: boolean;\n    },\n): Fragment {\n    const { input, optionalAccountStrategy, asyncResolvers, useAsync, nameApi, typeManifestVisitor, getImportFrom } =\n        scope;\n    if (!input.defaultValue) {\n        return fragment('');\n    }\n\n    if (!useAsync && isAsyncDefaultValue(input.defaultValue, asyncResolvers)) {\n        return fragment('');\n    }\n\n    const { defaultValue } = input;\n    const defaultFragment = (renderedValue: string, isWritable?: boolean): Fragment => {\n        const inputName = camelCase(input.name);\n        if (input.kind === 'instructionAccountNode' && isNode(defaultValue, 'resolverValueNode')) {\n            return fragment(`accounts.${inputName} = { ...accounts.${inputName}, ...${renderedValue} };`);\n        }\n        if (input.kind === 'instructionAccountNode' && isWritable === undefined) {\n            return fragment(`accounts.${inputName}.value = ${renderedValue};`);\n        }\n        if (input.kind === 'instructionAccountNode') {\n            return fragment(\n                `accounts.${inputName}.value = ${renderedValue};\\n` +\n                    `accounts.${inputName}.isWritable = ${isWritable ? 'true' : 'false'}`,\n            );\n        }\n        return fragment(`args.${inputName} = ${renderedValue};`);\n    };\n\n    switch (defaultValue.kind) {\n        case 'accountValueNode':\n            const name = camelCase(defaultValue.name);\n            if (input.kind === 'instructionAccountNode' && input.resolvedIsSigner && !input.isSigner) {\n                return defaultFragment(`expectTransactionSigner(accounts.${name}.value).address`).addImports(\n                    'shared',\n                    'expectTransactionSigner',\n                );\n            }\n            if (input.kind === 'instructionAccountNode') {\n                return defaultFragment(`expectSome(accounts.${name}.value)`).addImports('shared', 'expectSome');\n            }\n            return defaultFragment(`expectAddress(accounts.${name}.value)`).addImports('shared', 'expectAddress');\n\n        case 'pdaValueNode':\n            // Inlined PDA value.\n            if (isNode(defaultValue.pda, 'pdaNode')) {\n                const pdaProgram = defaultValue.pda.programId\n                    ? fragment(\n                          `'${defaultValue.pda.programId}' as Address<'${defaultValue.pda.programId}'>`,\n                      ).addImports('solanaAddresses', 'type Address')\n                    : fragment('programAddress');\n                const pdaSeeds = defaultValue.pda.seeds.flatMap((seed): Fragment[] => {\n                    if (isNode(seed, 'constantPdaSeedNode') && isNode(seed.value, 'programIdValueNode')) {\n                        return [\n                            fragment(`getAddressEncoder().encode(${pdaProgram.render})`)\n                                .mergeImportsWith(pdaProgram)\n                                .addImports('solanaAddresses', 'getAddressEncoder'),\n                        ];\n                    }\n                    if (isNode(seed, 'constantPdaSeedNode') && !isNode(seed.value, 'programIdValueNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueManifest = visit(seed.value, typeManifestVisitor);\n                        return [\n                            fragment(\n                                `${typeManifest.encoder.render}.encode(${valueManifest.value.render})`,\n                            ).mergeImportsWith(typeManifest.encoder, valueManifest.value),\n                        ];\n                    }\n                    if (isNode(seed, 'variablePdaSeedNode')) {\n                        const typeManifest = visit(seed.type, typeManifestVisitor);\n                        const valueSeed = defaultValue.seeds.find(s => s.name === seed.name)?.value;\n                        if (!valueSeed) return [];\n                        if (isNode(valueSeed, 'accountValueNode')) {\n                            return [\n                                fragment(\n                                    `${typeManifest.encoder.render}.encode(expectAddress(accounts.${camelCase(valueSeed.name)}.value))`,\n                                )\n                                    .mergeImportsWith(typeManifest.encoder)\n                                    .addImports('shared', 'expectAddress'),\n                            ];\n                        }\n                        if (isNode(valueSeed, 'argumentValueNode')) {\n                            return [\n                                fragment(\n                                    `${typeManifest.encoder.render}.encode(expectSome(args.${camelCase(valueSeed.name)}))`,\n                                )\n                                    .mergeImportsWith(typeManifest.encoder)\n                                    .addImports('shared', 'expectSome'),\n                            ];\n                        }\n                        const valueManifest = visit(valueSeed, typeManifestVisitor);\n                        return [\n                            fragment(\n                                `${typeManifest.encoder.render}.encode(${valueManifest.value.render})`,\n                            ).mergeImportsWith(typeManifest.encoder, valueManifest.value),\n                        ];\n                    }\n                    return [];\n                });\n                const pdaStatement = mergeFragments([pdaProgram, ...pdaSeeds], ([p, ...s]) => {\n                    const programAddress = p === 'programAddress' ? p : `programAddress: ${p}`;\n                    return `await getProgramDerivedAddress({ ${programAddress}, seeds: [${s.join(', ')}] })`;\n                }).addImports('solanaAddresses', 'getProgramDerivedAddress');\n                return defaultFragment(pdaStatement.render).mergeImportsWith(pdaStatement);\n            }\n\n            // Linked PDA value.\n            const pdaFunction = nameApi.pdaFindFunction(defaultValue.pda.name);\n            const pdaArgs = [];\n            const pdaSeeds = defaultValue.seeds.map((seed): Fragment => {\n                if (isNode(seed.value, 'accountValueNode')) {\n                    return fragment(\n                        `${seed.name}: expectAddress(accounts.${camelCase(seed.value.name)}.value)`,\n                    ).addImports('shared', 'expectAddress');\n                }\n                if (isNode(seed.value, 'argumentValueNode')) {\n                    return fragment(`${seed.name}: expectSome(args.${camelCase(seed.value.name)})`).addImports(\n                        'shared',\n                        'expectSome',\n                    );\n                }\n                return visit(seed.value, typeManifestVisitor).value.mapRender(r => `${seed.name}: ${r}`);\n            });\n            const pdaSeedsFragment = mergeFragments(pdaSeeds, renders => renders.join(', ')).mapRender(r => `{ ${r} }`);\n            if (pdaSeeds.length > 0) {\n                pdaArgs.push(pdaSeedsFragment.render);\n            }\n            return defaultFragment(`await ${pdaFunction}(${pdaArgs.join(', ')})`)\n                .mergeImportsWith(pdaSeedsFragment)\n                .addImports(getImportFrom(defaultValue.pda), pdaFunction);\n\n        case 'publicKeyValueNode':\n            return defaultFragment(`'${defaultValue.publicKey}' as Address<'${defaultValue.publicKey}'>`).addImports(\n                'solanaAddresses',\n                'type Address',\n            );\n\n        case 'programLinkNode':\n            const programAddress = nameApi.programAddressConstant(defaultValue.name);\n            return defaultFragment(programAddress, false).addImports(getImportFrom(defaultValue), programAddress);\n\n        case 'programIdValueNode':\n            if (\n                optionalAccountStrategy === 'programId' &&\n                input.kind === 'instructionAccountNode' &&\n                input.isOptional\n            ) {\n                return fragment('');\n            }\n            return defaultFragment('programAddress', false);\n\n        case 'identityValueNode':\n        case 'payerValueNode':\n            return fragment('');\n\n        case 'accountBumpValueNode':\n            return defaultFragment(\n                `expectProgramDerivedAddress(accounts.${camelCase(defaultValue.name)}.value)[1]`,\n            ).addImports('shared', 'expectProgramDerivedAddress');\n\n        case 'argumentValueNode':\n            return defaultFragment(`expectSome(args.${camelCase(defaultValue.name)})`).addImports(\n                'shared',\n                'expectSome',\n            );\n\n        case 'resolverValueNode':\n            const resolverFunction = nameApi.resolverFunction(defaultValue.name);\n            const resolverAwait = useAsync && asyncResolvers.includes(defaultValue.name) ? 'await ' : '';\n            return defaultFragment(`${resolverAwait}${resolverFunction}(resolverScope)`)\n                .addImports(getImportFrom(defaultValue), resolverFunction)\n                .addFeatures(['instruction:resolverScopeVariable']);\n\n        case 'conditionalValueNode':\n            const ifTrueRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifTrue,\n            });\n            const ifFalseRenderer = renderNestedInstructionDefault({\n                ...scope,\n                defaultValue: defaultValue.ifFalse,\n            });\n            if (!ifTrueRenderer && !ifFalseRenderer) {\n                return fragment('');\n            }\n            const conditionalFragment = fragment('');\n            if (ifTrueRenderer) {\n                conditionalFragment.mergeImportsWith(ifTrueRenderer).mergeFeaturesWith(ifTrueRenderer);\n            }\n            if (ifFalseRenderer) {\n                conditionalFragment.mergeImportsWith(ifFalseRenderer).mergeFeaturesWith(ifFalseRenderer);\n            }\n            const negatedCondition = !ifTrueRenderer;\n            let condition = 'true';\n\n            if (isNode(defaultValue.condition, 'resolverValueNode')) {\n                const conditionalResolverFunction = nameApi.resolverFunction(defaultValue.condition.name);\n                conditionalFragment\n                    .addImports(getImportFrom(defaultValue.condition), conditionalResolverFunction)\n                    .addFeatures(['instruction:resolverScopeVariable']);\n                const conditionalResolverAwait =\n                    useAsync && asyncResolvers.includes(defaultValue.condition.name) ? 'await ' : '';\n                condition = `${conditionalResolverAwait}${conditionalResolverFunction}(resolverScope)`;\n                condition = negatedCondition ? `!${condition}` : condition;\n            } else {\n                const comparedInputName = isNode(defaultValue.condition, 'accountValueNode')\n                    ? `accounts.${camelCase(defaultValue.condition.name)}.value`\n                    : `args.${camelCase(defaultValue.condition.name)}`;\n                if (defaultValue.value) {\n                    const comparedValue = visit(defaultValue.value, typeManifestVisitor).value;\n                    conditionalFragment.mergeImportsWith(comparedValue).mergeFeaturesWith(comparedValue);\n                    const operator = negatedCondition ? '!==' : '===';\n                    condition = `${comparedInputName} ${operator} ${comparedValue.render}`;\n                } else {\n                    condition = negatedCondition ? `!${comparedInputName}` : comparedInputName;\n                }\n            }\n\n            if (ifTrueRenderer && ifFalseRenderer) {\n                return conditionalFragment.setRender(\n                    `if (${condition}) {\\n${ifTrueRenderer.render}\\n} else {\\n${ifFalseRenderer.render}\\n}`,\n                );\n            }\n\n            return conditionalFragment.setRender(\n                `if (${condition}) {\\n${ifTrueRenderer ? ifTrueRenderer.render : ifFalseRenderer?.render}\\n}`,\n            );\n\n        default:\n            const valueManifest = visit(defaultValue, typeManifestVisitor).value;\n            return defaultFragment(valueManifest.render).mergeImportsWith(valueManifest);\n    }\n}\n\nfunction renderNestedInstructionDefault(\n    scope: Parameters<typeof getInstructionInputDefaultFragment>[0] & {\n        defaultValue: InstructionInputValueNode | undefined;\n    },\n): Fragment | undefined {\n    const { input, defaultValue } = scope;\n    if (!defaultValue) return undefined;\n    return getInstructionInputDefaultFragment({\n        ...scope,\n        input: { ...input, defaultValue },\n    });\n}\n","import {\n    camelCase,\n    getAllInstructionArguments,\n    InstructionArgumentNode,\n    InstructionNode,\n    isNode,\n    parseDocs,\n    pascalCase,\n} from '@codama/nodes';\nimport {\n    getLastNodeFromPath,\n    NodePath,\n    ResolvedInstructionAccount,\n    ResolvedInstructionArgument,\n    ResolvedInstructionInput,\n} from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { isAsyncDefaultValue, jsDocblock } from '../utils';\nimport { Fragment, fragment, fragmentFromTemplate, mergeFragments } from './common';\n\nexport function getInstructionInputTypeFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, useAsync, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const instructionInputType = useAsync\n        ? nameApi.instructionAsyncInputType(instructionNode.name)\n        : nameApi.instructionSyncInputType(instructionNode.name);\n    const accountsFragment = getAccountsFragment(scope);\n    const [dataArgumentsFragment, customDataArgumentsFragment] = getDataArgumentsFragments(scope);\n    const extraArgumentsFragment = getExtraArgumentsFragment(scope);\n    const remainingAccountsFragment = getRemainingAccountsFragment(instructionNode);\n\n    return fragmentFromTemplate('instructionInputType.njk', {\n        accountsFragment,\n        customDataArgumentsFragment,\n        dataArgumentsFragment,\n        extraArgumentsFragment,\n        instruction: instructionNode,\n        instructionInputType,\n        remainingAccountsFragment,\n    })\n        .mergeImportsWith(\n            accountsFragment,\n            dataArgumentsFragment,\n            customDataArgumentsFragment,\n            extraArgumentsFragment,\n            remainingAccountsFragment,\n        )\n        .addImports('solanaAddresses', ['type Address']);\n}\n\nfunction getAccountsFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'customInstructionData' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        resolvedInputs: ResolvedInstructionInput[];\n        useAsync: boolean;\n    },\n): Fragment {\n    const { instructionPath, resolvedInputs, useAsync, asyncResolvers } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const fragments = instructionNode.accounts.map(account => {\n        const resolvedAccount = resolvedInputs.find(\n            input => input.kind === 'instructionAccountNode' && input.name === account.name,\n        ) as ResolvedInstructionAccount;\n        const hasDefaultValue =\n            !!resolvedAccount.defaultValue &&\n            !isNode(resolvedAccount.defaultValue, ['identityValueNode', 'payerValueNode']) &&\n            (useAsync || !isAsyncDefaultValue(resolvedAccount.defaultValue, asyncResolvers));\n        const accountDocs = parseDocs(account.docs);\n        const docblock = accountDocs.length > 0 ? jsDocblock(accountDocs) : '';\n        const optionalSign = hasDefaultValue || resolvedAccount.isOptional ? '?' : '';\n        return getAccountTypeFragment(resolvedAccount).mapRender(\n            r => `${docblock}${camelCase(account.name)}${optionalSign}: ${r};`,\n        );\n    });\n\n    return mergeFragments(fragments, r => r.join('\\n'));\n}\n\nfunction getAccountTypeFragment(account: Pick<ResolvedInstructionAccount, 'isPda' | 'isSigner' | 'name'>): Fragment {\n    const typeParam = `TAccount${pascalCase(account.name)}`;\n\n    if (account.isPda && account.isSigner === false) {\n        return fragment(`ProgramDerivedAddress<${typeParam}>`).addImports('solanaAddresses', [\n            'type ProgramDerivedAddress',\n        ]);\n    }\n\n    if (account.isPda && account.isSigner === 'either') {\n        return fragment(`ProgramDerivedAddress<${typeParam}> | TransactionSigner<${typeParam}>`)\n            .addImports('solanaAddresses', ['type ProgramDerivedAddress'])\n            .addImports('solanaSigners', ['type TransactionSigner']);\n    }\n\n    if (account.isSigner === 'either') {\n        return fragment(`Address<${typeParam}> | TransactionSigner<${typeParam}>`)\n            .addImports('solanaAddresses', ['type Address'])\n            .addImports('solanaSigners', ['type TransactionSigner']);\n    }\n\n    if (account.isSigner) {\n        return fragment(`TransactionSigner<${typeParam}>`).addImports('solanaSigners', ['type TransactionSigner']);\n    }\n\n    return fragment(`Address<${typeParam}>`).addImports('solanaAddresses', ['type Address']);\n}\n\nfunction getDataArgumentsFragments(\n    scope: Pick<GlobalFragmentScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): [Fragment, Fragment] {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n\n    const customData = scope.customInstructionData.get(instructionNode.name);\n    if (customData) {\n        return [\n            fragment(''),\n            fragment(nameApi.dataArgsType(customData.importAs))\n                .mergeImportsWith(scope.dataArgsManifest.looseType)\n                .mapRender(r => `${r} & `),\n        ];\n    }\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const dataArgsType = nameApi.dataArgsType(instructionDataName);\n\n    const fragments = instructionNode.arguments.flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, fragment(dataArgsType), scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n\n    return [mergeFragments(fragments, r => r.join('\\n')), fragment('')];\n}\n\nfunction getExtraArgumentsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        renamedArgs: Map<string, string>;\n        resolvedInputs: ResolvedInstructionInput[];\n    },\n): Fragment {\n    const { instructionPath, nameApi } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const instructionExtraName = nameApi.instructionExtraType(instructionNode.name);\n    const extraArgsType = nameApi.dataArgsType(instructionExtraName);\n\n    const fragments = (instructionNode.extraArguments ?? []).flatMap(arg => {\n        const argFragment = getArgumentFragment(arg, fragment(extraArgsType), scope.resolvedInputs, scope.renamedArgs);\n        return argFragment ? [argFragment] : [];\n    });\n\n    return mergeFragments(fragments, r => r.join('\\n'));\n}\n\nfunction getArgumentFragment(\n    arg: InstructionArgumentNode,\n    argsType: Fragment,\n    resolvedInputs: ResolvedInstructionInput[],\n    renamedArgs: Map<string, string>,\n): Fragment | null {\n    const resolvedArg = resolvedInputs.find(\n        input => isNode(input, 'instructionArgumentNode') && input.name === arg.name,\n    ) as ResolvedInstructionArgument | undefined;\n    if (arg.defaultValue && arg.defaultValueStrategy === 'omitted') return null;\n    const renamedName = renamedArgs.get(arg.name) ?? arg.name;\n    const optionalSign = arg.defaultValue || resolvedArg?.defaultValue ? '?' : '';\n    return argsType.mapRender(r => `${camelCase(renamedName)}${optionalSign}: ${r}[\"${camelCase(arg.name)}\"];`);\n}\n\nfunction getRemainingAccountsFragment(instructionNode: InstructionNode): Fragment {\n    const fragments = (instructionNode.remainingAccounts ?? []).flatMap(remainingAccountsNode => {\n        if (isNode(remainingAccountsNode.value, 'resolverValueNode')) return [];\n\n        const { name } = remainingAccountsNode.value;\n        const allArguments = getAllInstructionArguments(instructionNode);\n        const argumentExists = allArguments.some(arg => arg.name === name);\n        if (argumentExists) return [];\n\n        const isSigner = remainingAccountsNode.isSigner ?? false;\n        const optionalSign = (remainingAccountsNode.isOptional ?? false) ? '?' : '';\n        const signerFragment = fragment(`TransactionSigner`).addImports('solanaSigners', ['type TransactionSigner']);\n        const addressFragment = fragment(`Address`).addImports('solanaAddresses', ['type Address']);\n        return (() => {\n            if (isSigner === 'either') {\n                return mergeFragments([signerFragment, addressFragment], r => r.join(' | '));\n            }\n            return isSigner ? signerFragment : addressFragment;\n        })().mapRender(r => `${camelCase(name)}${optionalSign}: Array<${r}>;`);\n    });\n\n    return mergeFragments(fragments, r => r.join('\\n'));\n}\n","import {\n    assertIsNode,\n    camelCase,\n    getAllInstructionArguments,\n    InstructionNode,\n    InstructionRemainingAccountsNode,\n    isNode,\n} from '@codama/nodes';\nimport { getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\n\nexport function getInstructionRemainingAccountsFragment(\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment {\n    const { remainingAccounts } = getLastNodeFromPath(scope.instructionPath);\n    const fragments = (remainingAccounts ?? []).flatMap(r => getRemainingAccountsFragment(r, scope));\n    if (fragments.length === 0) return fragment('');\n    return mergeFragments(\n        fragments,\n        r =>\n            `// Remaining accounts.\\n` +\n            `const remainingAccounts: IAccountMeta[] = ${r.length === 1 ? r[0] : `[...${r.join(', ...')}]`}`,\n    ).addImports('solanaInstructions', ['type IAccountMeta']);\n}\n\nfunction getRemainingAccountsFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n        useAsync: boolean;\n    },\n): Fragment[] {\n    const remainingAccountsFragment = ((): Fragment | null => {\n        if (isNode(remainingAccounts.value, 'argumentValueNode')) {\n            return getArgumentValueNodeFragment(remainingAccounts, scope);\n        }\n        if (isNode(remainingAccounts.value, 'resolverValueNode')) {\n            return getResolverValueNodeFragment(remainingAccounts, scope);\n        }\n        return null;\n    })();\n\n    if (remainingAccountsFragment === null) return [];\n    return [remainingAccountsFragment];\n}\n\nfunction getArgumentValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: { instructionPath: NodePath<InstructionNode> },\n): Fragment {\n    const instructionNode = getLastNodeFromPath(scope.instructionPath);\n    assertIsNode(remainingAccounts.value, 'argumentValueNode');\n    const argumentName = camelCase(remainingAccounts.value.name);\n    const isOptional = remainingAccounts.isOptional ?? false;\n    const isSigner = remainingAccounts.isSigner ?? false;\n    const isWritable = remainingAccounts.isWritable ?? false;\n    const nonSignerRole = isWritable ? 'AccountRole.WRITABLE' : 'AccountRole.READONLY';\n    const signerRole = isWritable ? 'AccountRole.WRITABLE_SIGNER' : 'AccountRole.READONLY_SIGNER';\n    const role = isSigner === true ? signerRole : nonSignerRole;\n    const argumentArray = isOptional ? `(args.${argumentName} ?? [])` : `args.${argumentName}`;\n\n    // The argument already exists or was added as `Array<Address>`.\n    const allArguments = getAllInstructionArguments(instructionNode);\n    const argumentExists = allArguments.some(arg => arg.name === remainingAccounts.value.name);\n    if (argumentExists || isSigner === false) {\n        return fragment(`${argumentArray}.map((address) => ({ address, role: ${role} }))`).addImports(\n            'solanaInstructions',\n            ['AccountRole'],\n        );\n    }\n\n    // The argument was added as `Array<TransactionSigner | Address>`.\n    if (isSigner === 'either') {\n        return fragment(\n            `${argumentArray}.map((addressOrSigner) => (` +\n                `isTransactionSigner(addressOrSigner)\\n` +\n                `? { address: addressOrSigner.address, role: ${role}, signer: addressOrSigner }\\n` +\n                `: { address: addressOrSigner, role: ${role} }\\n` +\n                `))`,\n        )\n            .addImports('solanaInstructions', ['AccountRole'])\n            .addImports('shared', ['isTransactionSigner']);\n    }\n\n    // The argument was added as `Array<TransactionSigner>`.\n    return fragment(\n        `${argumentArray}.map((signer) => ({ address: signer.address, role: ${signerRole}, signer }))`,\n    ).addImports('solanaInstructions', ['AccountRole']);\n}\n\nfunction getResolverValueNodeFragment(\n    remainingAccounts: InstructionRemainingAccountsNode,\n    scope: Pick<GlobalFragmentScope, 'asyncResolvers' | 'getImportFrom' | 'nameApi'> & {\n        useAsync: boolean;\n    },\n): Fragment | null {\n    assertIsNode(remainingAccounts.value, 'resolverValueNode');\n    const isAsync = scope.asyncResolvers.includes(remainingAccounts.value.name);\n    if (!scope.useAsync && isAsync) return null;\n\n    const awaitKeyword = scope.useAsync && isAsync ? 'await ' : '';\n    const functionName = scope.nameApi.resolverFunction(remainingAccounts.value.name);\n    return fragment(`${awaitKeyword}${functionName}(resolverScope)`)\n        .addImports(scope.getImportFrom(remainingAccounts.value), functionName)\n        .addFeatures(['instruction:resolverScopeVariable']);\n}\n","import { InstructionNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { TypeManifest } from '../TypeManifest';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getInstructionParseFunctionFragment(\n    scope: Pick<GlobalFragmentScope, 'customInstructionData' | 'nameApi'> & {\n        dataArgsManifest: TypeManifest;\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, dataArgsManifest, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const hasOptionalAccounts = instructionNode.accounts.some(account => account.isOptional);\n    const minimumNumberOfAccounts =\n        instructionNode.optionalAccountStrategy === 'omitted'\n            ? instructionNode.accounts.filter(account => !account.isOptional).length\n            : instructionNode.accounts.length;\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n    const dataTypeFragment = fragment(\n        customData ? dataArgsManifest.strictType.render : nameApi.dataType(instructionDataName),\n    );\n    const decoderFunction = customData\n        ? dataArgsManifest.decoder.render\n        : `${nameApi.decoderFunction(instructionDataName)}()`;\n    if (customData) {\n        dataTypeFragment.mergeImportsWith(dataArgsManifest.strictType, dataArgsManifest.decoder);\n    }\n\n    return fragmentFromTemplate('instructionParseFunction.njk', {\n        dataTypeFragment,\n        decoderFunction,\n        hasAccounts,\n        hasData,\n        hasOptionalAccounts,\n        instruction: instructionNode,\n        instructionParseFunction: nameApi.instructionParseFunction(instructionNode.name),\n        instructionParsedType: nameApi.instructionParsedType(instructionNode.name),\n        minimumNumberOfAccounts,\n        programAddressConstant,\n    })\n        .mergeImportsWith(dataTypeFragment)\n        .addImports('generatedPrograms', [programAddressConstant])\n        .addImports('solanaInstructions', ['type IInstruction'])\n        .addImports('solanaInstructions', hasAccounts ? ['type IInstructionWithAccounts', 'type IAccountMeta'] : [])\n        .addImports('solanaInstructions', hasData ? ['type IInstructionWithData'] : []);\n}\n","import { InstructionNode, pascalCase } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragmentFromTemplate, mergeFragments } from './common';\nimport { getInstructionAccountMetaFragment } from './instructionAccountMeta';\nimport { getInstructionAccountTypeParamFragment } from './instructionAccountTypeParam';\n\nexport function getInstructionTypeFragment(\n    scope: Pick<GlobalFragmentScope, 'customInstructionData' | 'linkables' | 'nameApi'> & {\n        instructionPath: NodePath<InstructionNode>;\n    },\n): Fragment {\n    const { instructionPath, nameApi, customInstructionData } = scope;\n    const instructionNode = getLastNodeFromPath(instructionPath);\n    const programNode = findProgramNodeFromPath(instructionPath)!;\n    const hasAccounts = instructionNode.accounts.length > 0;\n    const customData = customInstructionData.get(instructionNode.name);\n    const hasData = !!customData || instructionNode.arguments.length > 0;\n    const instructionDataName = nameApi.instructionDataType(instructionNode.name);\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n    const dataType = customData ? pascalCase(customData.importAs) : pascalCase(instructionDataName);\n    const accountTypeParamsFragment = mergeFragments(\n        instructionNode.accounts.map(account =>\n            getInstructionAccountTypeParamFragment({\n                ...scope,\n                allowAccountMeta: true,\n                instructionAccountPath: [...instructionPath, account],\n            }),\n        ),\n        renders => renders.join(', '),\n    );\n    const usesLegacyOptionalAccounts = instructionNode.optionalAccountStrategy === 'omitted';\n    const accountMetasFragment = mergeFragments(\n        instructionNode.accounts.map(account =>\n            getInstructionAccountMetaFragment(account).mapRender(r => {\n                const typeParam = `TAccount${pascalCase(account.name)}`;\n                const isLegacyOptional = account.isOptional && usesLegacyOptionalAccounts;\n                const type = `${typeParam} extends string ? ${r} : ${typeParam}`;\n                if (!isLegacyOptional) return type;\n                return `...(${typeParam} extends undefined ? [] : [${type}])`;\n            }),\n        ),\n        renders => renders.join(', '),\n    );\n\n    const fragment = fragmentFromTemplate('instructionType.njk', {\n        accountMetas: accountMetasFragment.render,\n        accountTypeParams: accountTypeParamsFragment.render,\n        dataType,\n        hasAccounts,\n        hasData,\n        instruction: instructionNode,\n        instructionType: nameApi.instructionType(instructionNode.name),\n        programAddressConstant,\n    })\n        .mergeImportsWith(accountTypeParamsFragment, accountMetasFragment)\n        .addImports('generatedPrograms', [programAddressConstant])\n        .addImports('solanaInstructions', [\n            'type IAccountMeta',\n            'type IInstruction',\n            'type IInstructionWithAccounts',\n            ...(hasData ? ['type IInstructionWithData'] : []),\n        ]);\n\n    // TODO: if link, add import for data type. Unless we don't need to inject the data type in IInstructionWithData.\n\n    return fragment;\n}\n","import { isNode, isNodeFilter, PdaNode } from '@codama/nodes';\nimport { findProgramNodeFromPath, getLastNodeFromPath, NodePath, visit } from '@codama/visitors-core';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { ImportMap } from '../ImportMap';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getPdaFunctionFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        pdaPath: NodePath<PdaNode>;\n    },\n): Fragment {\n    const { pdaPath, typeManifestVisitor, nameApi } = scope;\n    const pdaNode = getLastNodeFromPath(pdaPath);\n    const programNode = findProgramNodeFromPath(pdaPath)!;\n\n    // Seeds.\n    const imports = new ImportMap();\n    const seeds = pdaNode.seeds.map(seed => {\n        if (isNode(seed, 'variablePdaSeedNode')) {\n            const seedManifest = visit(seed.type, typeManifestVisitor);\n            imports.mergeWith(seedManifest.looseType, seedManifest.encoder);\n            return { ...seed, typeManifest: seedManifest };\n        }\n        if (isNode(seed.value, 'programIdValueNode')) {\n            imports.add('solanaAddresses', 'getAddressEncoder');\n            return seed;\n        }\n        const seedManifest = visit(seed.type, typeManifestVisitor);\n        imports.mergeWith(seedManifest.encoder);\n        const valueManifest = visit(seed.value, typeManifestVisitor).value;\n        imports.mergeWith(valueManifest.imports);\n        return { ...seed, typeManifest: seedManifest, valueManifest };\n    });\n    const hasVariableSeeds = pdaNode.seeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n\n    return fragmentFromTemplate('pdaFunction.njk', {\n        findPdaFunction: nameApi.pdaFindFunction(pdaNode.name),\n        hasVariableSeeds,\n        pdaSeedsType: nameApi.pdaSeedsType(pdaNode.name),\n        programAddress: pdaNode.programId ?? programNode.publicKey,\n        seeds,\n    })\n        .mergeImportsWith(imports)\n        .addImports('solanaAddresses', ['type Address', 'getProgramDerivedAddress', 'type ProgramDerivedAddress']);\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getProgramFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n\n    return fragmentFromTemplate('program.njk', {\n        program: programNode,\n        programAddressConstant: nameApi.programAddressConstant(programNode.name),\n    }).addImports('solanaAddresses', ['type Address']);\n}\n","import { ProgramNode, resolveNestedTypeNode } from '@codama/nodes';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramAccountsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    if (scope.programNode.accounts.length === 0) return fragment('');\n    return mergeFragments(\n        [getProgramAccountsEnumFragment(scope), getProgramAccountsIdentifierFunctionFragment(scope)],\n        r => `${r.join('\\n\\n')}\\n`,\n    );\n}\n\nfunction getProgramAccountsEnumFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsEnumVariants = programNode.accounts.map(account =>\n        nameApi.programAccountsEnumVariant(account.name),\n    );\n    return fragment(`export enum ${programAccountsEnum} { ` + `${programAccountsEnumVariants.join(', ')}` + ` }`);\n}\n\nfunction getProgramAccountsIdentifierFunctionFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const accountsWithDiscriminators = programNode.accounts.filter(\n        account => (account.discriminators ?? []).length > 0,\n    );\n    const hasAccountDiscriminators = accountsWithDiscriminators.length > 0;\n    if (!hasAccountDiscriminators) return fragment('');\n\n    const programAccountsEnum = nameApi.programAccountsEnum(programNode.name);\n    const programAccountsIdentifierFunction = nameApi.programAccountsIdentifierFunction(programNode.name);\n    const discriminatorsFragment = mergeFragments(\n        accountsWithDiscriminators.map((account): Fragment => {\n            const variant = nameApi.programAccountsEnumVariant(account.name);\n            return getDiscriminatorConditionFragment({\n                ...scope,\n                dataName: 'data',\n                discriminators: account.discriminators ?? [],\n                ifTrue: `return ${programAccountsEnum}.${variant};`,\n                struct: resolveNestedTypeNode(account.data),\n            });\n        }),\n        r => r.join('\\n'),\n    );\n\n    return discriminatorsFragment\n        .mapRender(\n            discriminators =>\n                `export function ${programAccountsIdentifierFunction}(` +\n                `account: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                `): ${programAccountsEnum} {\\n` +\n                `const data = 'data' in account ? account.data : account;\\n` +\n                `${discriminators}\\n` +\n                `throw new Error(\"The provided account could not be identified as a ${programNode.name} account.\")\\n` +\n                `}`,\n        )\n        .addImports('solanaCodecsCore', 'type ReadonlyUint8Array');\n}\n","import { ProgramNode } from '@codama/nodes';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragmentFromTemplate } from './common';\n\nexport function getProgramErrorsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi } = scope;\n    const programAddressConstant = nameApi.programAddressConstant(programNode.name);\n    return fragmentFromTemplate('programErrors.njk', {\n        errors: programNode.errors,\n        getProgramErrorConstant: (name: string) =>\n            nameApi.programErrorConstantPrefix(programNode.name) + nameApi.programErrorConstant(name),\n        programAddressConstant,\n        programErrorMessagesMap: nameApi.programErrorMessagesMap(programNode.name),\n        programErrorUnion: nameApi.programErrorUnion(programNode.name),\n        programGetErrorMessageFunction: nameApi.programGetErrorMessageFunction(programNode.name),\n        programIsErrorFunction: nameApi.programIsErrorFunction(programNode.name),\n    })\n        .addImports('generatedPrograms', [programAddressConstant])\n        .addImports('solanaPrograms', ['isProgramError'])\n        .addImports('solanaErrors', ['type SolanaError', 'type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM'])\n        .addImports('solanaAddresses', ['type Address']);\n}\n","import {\n    getAllInstructionsWithSubs,\n    InstructionNode,\n    ProgramNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, mergeFragments } from './common';\nimport { getDiscriminatorConditionFragment } from './discriminatorCondition';\n\nexport function getProgramInstructionsFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'renderParentInstructions' | 'typeManifestVisitor'> & {\n        programNode: ProgramNode;\n    },\n): Fragment {\n    if (scope.programNode.instructions.length === 0) return fragment('');\n    const allInstructions = getAllInstructionsWithSubs(scope.programNode, {\n        leavesOnly: !scope.renderParentInstructions,\n        subInstructionsFirst: true,\n    });\n    const scopeWithInstructions = { ...scope, allInstructions };\n    return mergeFragments(\n        [\n            getProgramInstructionsEnumFragment(scopeWithInstructions),\n            getProgramInstructionsIdentifierFunctionFragment(scopeWithInstructions),\n            getProgramInstructionsParsedUnionTypeFragment(scopeWithInstructions),\n        ],\n        r => `${r.join('\\n\\n')}\\n`,\n    );\n}\n\nfunction getProgramInstructionsEnumFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsEnumVariants = allInstructions.map(instruction =>\n        nameApi.programInstructionsEnumVariant(instruction.name),\n    );\n    return fragment(\n        `export enum ${programInstructionsEnum} { ` + `${programInstructionsEnumVariants.join(', ')}` + ` }`,\n    );\n}\n\nfunction getProgramInstructionsIdentifierFunctionFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi' | 'typeManifestVisitor'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, nameApi, allInstructions } = scope;\n    const instructionsWithDiscriminators = allInstructions.filter(\n        instruction => (instruction.discriminators ?? []).length > 0,\n    );\n    const hasInstructionDiscriminators = instructionsWithDiscriminators.length > 0;\n    if (!hasInstructionDiscriminators) return fragment('');\n\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n    const programInstructionsIdentifierFunction = nameApi.programInstructionsIdentifierFunction(programNode.name);\n    const discriminatorsFragment = mergeFragments(\n        instructionsWithDiscriminators.map((instruction): Fragment => {\n            const variant = nameApi.programInstructionsEnumVariant(instruction.name);\n            return getDiscriminatorConditionFragment({\n                ...scope,\n                dataName: 'data',\n                discriminators: instruction.discriminators ?? [],\n                ifTrue: `return ${programInstructionsEnum}.${variant};`,\n                struct: structTypeNodeFromInstructionArgumentNodes(instruction.arguments),\n            });\n        }),\n        r => r.join('\\n'),\n    );\n\n    return discriminatorsFragment\n        .mapRender(\n            discriminators =>\n                `export function ${programInstructionsIdentifierFunction}(` +\n                `instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array` +\n                `): ${programInstructionsEnum} {\\n` +\n                `const data = 'data' in instruction ? instruction.data : instruction;\\n` +\n                `${discriminators}\\n` +\n                `throw new Error(\"The provided instruction could not be identified as a ${programNode.name} instruction.\")\\n` +\n                `}`,\n        )\n        .addImports('solanaCodecsCore', 'type ReadonlyUint8Array');\n}\n\nfunction getProgramInstructionsParsedUnionTypeFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        allInstructions: InstructionNode[];\n        programNode: ProgramNode;\n    },\n): Fragment {\n    const { programNode, allInstructions, nameApi } = scope;\n\n    const programAddress = programNode.publicKey;\n\n    const programInstructionsType = nameApi.programInstructionsParsedUnionType(programNode.name);\n\n    const programInstructionsEnum = nameApi.programInstructionsEnum(programNode.name);\n\n    const typeVariants = allInstructions.map((instruction): Fragment => {\n        const instructionEnumVariant = nameApi.programInstructionsEnumVariant(instruction.name);\n\n        const parsedInstructionType = nameApi.instructionParsedType(instruction.name);\n\n        return fragment(\n            `| { instructionType: ${programInstructionsEnum}.${instructionEnumVariant} } & ${parsedInstructionType}<TProgram>`,\n        ).addImports('generatedInstructions', `type ${parsedInstructionType}`);\n    });\n\n    return mergeFragments(\n        [\n            fragment(`export type ${programInstructionsType}<TProgram extends string = '${programAddress}'> =`),\n            ...typeVariants,\n        ],\n        r => r.join('\\n'),\n    );\n}\n","import { isDataEnum, isNode, TypeNode } from '@codama/nodes';\n\nimport type { GlobalFragmentScope } from '../getRenderMapVisitor';\nimport { Fragment, fragment, fragmentFromTemplate } from './common';\n\nexport function getTypeDiscriminatedUnionHelpersFragment(\n    scope: Pick<GlobalFragmentScope, 'nameApi'> & {\n        name: string;\n        typeNode: TypeNode;\n    },\n): Fragment {\n    const { name, typeNode, nameApi } = scope;\n    const isDiscriminatedUnion = isNode(typeNode, 'enumTypeNode') && isDataEnum(typeNode);\n\n    if (!isDiscriminatedUnion) {\n        return fragment('');\n    }\n\n    return fragmentFromTemplate('typeDiscriminatedUnionHelpers.njk', {\n        discriminatedUnionDiscriminator: nameApi.discriminatedUnionDiscriminator(name),\n        discriminatedUnionFunction: nameApi.discriminatedUnionFunction(name),\n        getVariant: (variant: string) => nameApi.discriminatedUnionVariant(variant),\n        isDiscriminatedUnionFunction: nameApi.isDiscriminatedUnionFunction(name),\n        looseName: nameApi.dataArgsType(name),\n        strictName: nameApi.dataType(name),\n        typeNode,\n    }).addImports('solanaCodecsDataStructures', [\n        'type GetDiscriminatedUnionVariantContent',\n        'type GetDiscriminatedUnionVariant',\n    ]);\n}\n","import { Fragment, fragment, mergeFragments } from './fragments';\n\nexport type TypeManifest = {\n    decoder: Fragment;\n    encoder: Fragment;\n    isEnum: boolean;\n    looseType: Fragment;\n    strictType: Fragment;\n    value: Fragment;\n};\n\nexport function typeManifest(): TypeManifest {\n    return {\n        decoder: fragment(''),\n        encoder: fragment(''),\n        isEnum: false,\n        looseType: fragment(''),\n        strictType: fragment(''),\n        value: fragment(''),\n    };\n}\n\nexport function mergeManifests(\n    manifests: TypeManifest[],\n    options: {\n        mergeCodecs?: (renders: string[]) => string;\n        mergeTypes?: (renders: string[]) => string;\n        mergeValues?: (renders: string[]) => string;\n    } = {},\n): TypeManifest {\n    const { mergeTypes, mergeCodecs, mergeValues } = options;\n    const merge = (fragmentFn: (m: TypeManifest) => Fragment, mergeFn?: (r: string[]) => string) =>\n        mergeFn ? mergeFragments(manifests.map(fragmentFn), mergeFn) : fragment('');\n    return {\n        decoder: merge(m => m.decoder, mergeCodecs),\n        encoder: merge(m => m.encoder, mergeCodecs),\n        isEnum: false,\n        looseType: merge(m => m.looseType, mergeTypes),\n        strictType: merge(m => m.strictType, mergeTypes),\n        value: merge(m => m.value, mergeValues),\n    };\n}\n","import { join } from 'node:path';\n\nimport { logWarn } from '@codama/errors';\nimport {\n    camelCase,\n    CamelCaseString,\n    definedTypeNode,\n    getAllAccounts,\n    getAllDefinedTypes,\n    getAllInstructionsWithSubs,\n    getAllPdas,\n    getAllPrograms,\n    InstructionNode,\n    resolveNestedTypeNode,\n    structTypeNodeFromInstructionArgumentNodes,\n} from '@codama/nodes';\nimport { RenderMap } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    findProgramNodeFromPath,\n    getResolvedInstructionInputsVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n} from '@codama/visitors-core';\nimport type { ConfigureOptions } from 'nunjucks';\n\nimport {\n    getAccountFetchHelpersFragment,\n    getAccountPdaHelpersFragment,\n    getAccountSizeHelpersFragment,\n    getAccountTypeFragment,\n    getDiscriminatorConstantsFragment,\n    getInstructionDataFragment,\n    getInstructionExtraArgsFragment,\n    getInstructionFunctionFragment,\n    getInstructionParseFunctionFragment,\n    getInstructionTypeFragment,\n    getPdaFunctionFragment,\n    getProgramAccountsFragment,\n    getProgramErrorsFragment,\n    getProgramFragment,\n    getProgramInstructionsFragment,\n    getTypeDiscriminatedUnionHelpersFragment,\n    getTypeWithCodecFragment,\n} from './fragments';\nimport { getTypeManifestVisitor, TypeManifestVisitor } from './getTypeManifestVisitor';\nimport { ImportMap } from './ImportMap';\nimport { DEFAULT_NAME_TRANSFORMERS, getNameApi, NameApi, NameTransformers } from './nameTransformers';\nimport {\n    CustomDataOptions,\n    getDefinedTypeNodesToExtract,\n    getImportFromFactory,\n    GetImportFromFunction,\n    LinkOverrides,\n    parseCustomDataOptions,\n    ParsedCustomDataOptions,\n    render as baseRender,\n} from './utils';\n\nexport type GetRenderMapOptions = {\n    asyncResolvers?: string[];\n    customAccountData?: CustomDataOptions[];\n    customInstructionData?: CustomDataOptions[];\n    dependencyMap?: Record<string, string>;\n    internalNodes?: string[];\n    linkOverrides?: LinkOverrides;\n    nameTransformers?: Partial<NameTransformers>;\n    nonScalarEnums?: string[];\n    renderParentInstructions?: boolean;\n    useGranularImports?: boolean;\n};\n\nexport type GlobalFragmentScope = {\n    asyncResolvers: CamelCaseString[];\n    customAccountData: ParsedCustomDataOptions;\n    customInstructionData: ParsedCustomDataOptions;\n    getImportFrom: GetImportFromFunction;\n    linkables: LinkableDictionary;\n    nameApi: NameApi;\n    nonScalarEnums: CamelCaseString[];\n    renderParentInstructions: boolean;\n    typeManifestVisitor: TypeManifestVisitor;\n};\n\nexport function getRenderMapVisitor(options: GetRenderMapOptions = {}) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    const nameTransformers = {\n        ...DEFAULT_NAME_TRANSFORMERS,\n        ...options.nameTransformers,\n    };\n    const nameApi = getNameApi(nameTransformers);\n    const renderParentInstructions = options.renderParentInstructions ?? false;\n    const dependencyMap = options.dependencyMap ?? {};\n    const useGranularImports = options.useGranularImports ?? false;\n    const asyncResolvers = (options.asyncResolvers ?? []).map(camelCase);\n    const nonScalarEnums = (options.nonScalarEnums ?? []).map(camelCase);\n    const internalNodes = (options.internalNodes ?? []).map(camelCase);\n    const customAccountData = parseCustomDataOptions(options.customAccountData ?? [], 'AccountData');\n    const customInstructionData = parseCustomDataOptions(options.customInstructionData ?? [], 'InstructionData');\n    const getImportFrom = getImportFromFactory(options.linkOverrides ?? {}, customAccountData, customInstructionData);\n\n    const typeManifestVisitor = getTypeManifestVisitor({\n        customAccountData,\n        customInstructionData,\n        getImportFrom,\n        linkables,\n        nameApi,\n        nonScalarEnums,\n        stack,\n    });\n    const resolvedInstructionInputVisitor = getResolvedInstructionInputsVisitor();\n\n    const globalScope: GlobalFragmentScope = {\n        asyncResolvers,\n        customAccountData,\n        customInstructionData,\n        getImportFrom,\n        linkables,\n        nameApi,\n        nonScalarEnums,\n        renderParentInstructions,\n        typeManifestVisitor,\n    };\n\n    const render = (template: string, context?: object, renderOptions?: ConfigureOptions): string => {\n        return baseRender(join('pages', template), context, renderOptions);\n    };\n\n    return pipe(\n        staticVisitor(() => new RenderMap(), {\n            keys: ['rootNode', 'programNode', 'pdaNode', 'accountNode', 'definedTypeNode', 'instructionNode'],\n        }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node) {\n                    const accountPath = stack.getPath('accountNode');\n                    if (!findProgramNodeFromPath(accountPath)) {\n                        throw new Error('Account must be visited inside a program.');\n                    }\n\n                    const scope = {\n                        ...globalScope,\n                        accountPath,\n                        typeManifest: visit(node, typeManifestVisitor),\n                    };\n\n                    const fields = resolveNestedTypeNode(node.data).fields;\n                    const accountDiscriminatorConstantsFragment = getDiscriminatorConstantsFragment({\n                        ...scope,\n                        discriminatorNodes: node.discriminators ?? [],\n                        fields,\n                        prefix: node.name,\n                    });\n                    const accountTypeFragment = getAccountTypeFragment(scope);\n                    const accountFetchHelpersFragment = getAccountFetchHelpersFragment(scope);\n                    const accountSizeHelpersFragment = getAccountSizeHelpersFragment(scope);\n                    const accountPdaHelpersFragment = getAccountPdaHelpersFragment(scope);\n                    const imports = new ImportMap().mergeWith(\n                        accountDiscriminatorConstantsFragment,\n                        accountTypeFragment,\n                        accountFetchHelpersFragment,\n                        accountSizeHelpersFragment,\n                        accountPdaHelpersFragment,\n                    );\n\n                    return new RenderMap().add(\n                        `accounts/${camelCase(node.name)}.ts`,\n                        render('accountsPage.njk', {\n                            accountDiscriminatorConstantsFragment,\n                            accountFetchHelpersFragment,\n                            accountPdaHelpersFragment,\n                            accountSizeHelpersFragment,\n                            accountTypeFragment,\n                            imports: imports.toString(dependencyMap, useGranularImports),\n                        }),\n                    );\n                },\n\n                visitDefinedType(node) {\n                    const scope = {\n                        ...globalScope,\n                        codecDocs: [],\n                        decoderDocs: [],\n                        encoderDocs: [],\n                        manifest: visit(node, typeManifestVisitor),\n                        name: node.name,\n                        typeDocs: node.docs,\n                        typeNode: node.type,\n                    };\n\n                    const typeWithCodecFragment = getTypeWithCodecFragment(scope);\n                    const typeDiscriminatedUnionHelpersFragment = getTypeDiscriminatedUnionHelpersFragment(scope);\n                    const imports = new ImportMap()\n                        .mergeWith(typeWithCodecFragment, typeDiscriminatedUnionHelpersFragment)\n                        .remove('generatedTypes', [\n                            nameApi.dataType(node.name),\n                            nameApi.dataArgsType(node.name),\n                            nameApi.encoderFunction(node.name),\n                            nameApi.decoderFunction(node.name),\n                            nameApi.codecFunction(node.name),\n                        ]);\n\n                    return new RenderMap().add(\n                        `types/${camelCase(node.name)}.ts`,\n                        render('definedTypesPage.njk', {\n                            imports: imports.toString({\n                                ...dependencyMap,\n                                generatedTypes: '.',\n                            }),\n                            typeDiscriminatedUnionHelpersFragment,\n                            typeWithCodecFragment,\n                        }),\n                    );\n                },\n\n                visitInstruction(node) {\n                    const instructionPath = stack.getPath('instructionNode');\n                    if (!findProgramNodeFromPath(instructionPath)) {\n                        throw new Error('Instruction must be visited inside a program.');\n                    }\n\n                    const instructionExtraName = nameApi.instructionExtraType(node.name);\n                    const scope = {\n                        ...globalScope,\n                        dataArgsManifest: visit(node, typeManifestVisitor),\n                        extraArgsManifest: visit(\n                            definedTypeNode({\n                                name: instructionExtraName,\n                                type: structTypeNodeFromInstructionArgumentNodes(node.extraArguments ?? []),\n                            }),\n                            typeManifestVisitor,\n                        ),\n                        instructionPath,\n                        renamedArgs: getRenamedArgsMap(node),\n                        resolvedInputs: visit(node, resolvedInstructionInputVisitor),\n                    };\n\n                    // Fragments.\n                    const instructionDiscriminatorConstantsFragment = getDiscriminatorConstantsFragment({\n                        ...scope,\n                        discriminatorNodes: node.discriminators ?? [],\n                        fields: node.arguments,\n                        prefix: node.name,\n                    });\n                    const instructionTypeFragment = getInstructionTypeFragment(scope);\n                    const instructionDataFragment = getInstructionDataFragment(scope);\n                    const instructionExtraArgsFragment = getInstructionExtraArgsFragment(scope);\n                    const instructionFunctionAsyncFragment = getInstructionFunctionFragment({\n                        ...scope,\n                        useAsync: true,\n                    });\n                    const instructionFunctionSyncFragment = getInstructionFunctionFragment({\n                        ...scope,\n                        useAsync: false,\n                    });\n                    const instructionParseFunctionFragment = getInstructionParseFunctionFragment(scope);\n\n                    // Imports and interfaces.\n                    const imports = new ImportMap().mergeWith(\n                        instructionDiscriminatorConstantsFragment,\n                        instructionTypeFragment,\n                        instructionDataFragment,\n                        instructionExtraArgsFragment,\n                        instructionFunctionAsyncFragment,\n                        instructionFunctionSyncFragment,\n                        instructionParseFunctionFragment,\n                    );\n\n                    return new RenderMap().add(\n                        `instructions/${camelCase(node.name)}.ts`,\n                        render('instructionsPage.njk', {\n                            imports: imports.toString(dependencyMap, useGranularImports),\n                            instruction: node,\n                            instructionDataFragment,\n                            instructionDiscriminatorConstantsFragment,\n                            instructionExtraArgsFragment,\n                            instructionFunctionAsyncFragment,\n                            instructionFunctionSyncFragment,\n                            instructionParseFunctionFragment,\n                            instructionTypeFragment,\n                        }),\n                    );\n                },\n\n                visitPda(node) {\n                    const pdaPath = stack.getPath('pdaNode');\n                    if (!findProgramNodeFromPath(pdaPath)) {\n                        throw new Error('Account must be visited inside a program.');\n                    }\n\n                    const scope = { ...globalScope, pdaPath };\n                    const pdaFunctionFragment = getPdaFunctionFragment(scope);\n                    const imports = new ImportMap().mergeWith(pdaFunctionFragment);\n\n                    return new RenderMap().add(\n                        `pdas/${camelCase(node.name)}.ts`,\n                        render('pdasPage.njk', {\n                            imports: imports.toString(dependencyMap, useGranularImports),\n                            pdaFunctionFragment,\n                        }),\n                    );\n                },\n\n                visitProgram(node, { self }) {\n                    const customDataDefinedType = [\n                        ...getDefinedTypeNodesToExtract(node.accounts, customAccountData),\n                        ...getDefinedTypeNodesToExtract(node.instructions, customInstructionData),\n                    ];\n                    const scope = { ...globalScope, programNode: node };\n                    const renderMap = new RenderMap()\n                        .mergeWith(...node.pdas.map(p => visit(p, self)))\n                        .mergeWith(...node.accounts.map(a => visit(a, self)))\n                        .mergeWith(...node.definedTypes.map(t => visit(t, self)))\n                        .mergeWith(...customDataDefinedType.map(t => visit(t, self)));\n\n                    if (node.errors.length > 0) {\n                        const programErrorsFragment = getProgramErrorsFragment(scope);\n                        renderMap.add(\n                            `errors/${camelCase(node.name)}.ts`,\n                            render('errorsPage.njk', {\n                                imports: new ImportMap()\n                                    .mergeWith(programErrorsFragment)\n                                    .toString(dependencyMap, useGranularImports),\n                                programErrorsFragment,\n                            }),\n                        );\n                    }\n\n                    const programFragment = getProgramFragment(scope);\n                    const programAccountsFragment = getProgramAccountsFragment(scope);\n                    const programInstructionsFragment = getProgramInstructionsFragment(scope);\n                    renderMap.add(\n                        `programs/${camelCase(node.name)}.ts`,\n                        render('programsPage.njk', {\n                            imports: new ImportMap()\n                                .mergeWith(programFragment, programAccountsFragment, programInstructionsFragment)\n                                .toString(dependencyMap, useGranularImports),\n                            programAccountsFragment,\n                            programFragment,\n                            programInstructionsFragment,\n                        }),\n                    );\n\n                    renderMap.mergeWith(\n                        ...getAllInstructionsWithSubs(node, {\n                            leavesOnly: !renderParentInstructions,\n                        }).map(ix => visit(ix, self)),\n                    );\n                    return renderMap;\n                },\n\n                visitRoot(node, { self }) {\n                    const isNotInternal = (n: { name: CamelCaseString }) => !internalNodes.includes(n.name);\n                    const programsToExport = getAllPrograms(node).filter(isNotInternal);\n                    const programsWithErrorsToExport = programsToExport.filter(p => p.errors.length > 0);\n                    const pdasToExport = getAllPdas(node);\n                    const accountsToExport = getAllAccounts(node).filter(isNotInternal);\n                    const instructionsToExport = getAllInstructionsWithSubs(node, {\n                        leavesOnly: !renderParentInstructions,\n                    }).filter(isNotInternal);\n                    const definedTypesToExport = getAllDefinedTypes(node).filter(isNotInternal);\n                    const hasAnythingToExport =\n                        programsToExport.length > 0 ||\n                        accountsToExport.length > 0 ||\n                        instructionsToExport.length > 0 ||\n                        definedTypesToExport.length > 0;\n\n                    const ctx = {\n                        accountsToExport,\n                        definedTypesToExport,\n                        hasAnythingToExport,\n                        instructionsToExport,\n                        pdasToExport,\n                        programsToExport,\n                        programsWithErrorsToExport,\n                        root: node,\n                    };\n\n                    const map = new RenderMap();\n                    if (hasAnythingToExport) {\n                        map.add(\n                            'shared/index.ts',\n                            render('sharedPage.njk', {\n                                ...ctx,\n                                imports: new ImportMap()\n                                    .add('solanaAddresses', [\n                                        'type Address',\n                                        'isProgramDerivedAddress',\n                                        'type ProgramDerivedAddress',\n                                    ])\n                                    .add('solanaInstructions', [\n                                        'AccountRole',\n                                        'type IAccountMeta',\n                                        'upgradeRoleToSigner',\n                                    ])\n                                    .add('solanaSigners', [\n                                        'type IAccountSignerMeta',\n                                        'isTransactionSigner',\n                                        'type TransactionSigner',\n                                    ])\n                                    .addAlias('solanaSigners', 'isTransactionSigner', 'kitIsTransactionSigner')\n                                    .toString(dependencyMap, useGranularImports),\n                            }),\n                        );\n                    }\n                    if (programsToExport.length > 0) {\n                        map.add('programs/index.ts', render('programsIndex.njk', ctx));\n                    }\n                    if (programsWithErrorsToExport.length > 0) {\n                        map.add('errors/index.ts', render('errorsIndex.njk', ctx));\n                    }\n                    if (accountsToExport.length > 0) {\n                        map.add('accounts/index.ts', render('accountsIndex.njk', ctx));\n                    }\n                    if (pdasToExport.length > 0) {\n                        map.add('pdas/index.ts', render('pdasIndex.njk', ctx));\n                    }\n                    if (instructionsToExport.length > 0) {\n                        map.add('instructions/index.ts', render('instructionsIndex.njk', ctx));\n                    }\n                    if (definedTypesToExport.length > 0) {\n                        map.add('types/index.ts', render('definedTypesIndex.njk', ctx));\n                    }\n\n                    return map\n                        .add('index.ts', render('rootIndex.njk', ctx))\n                        .mergeWith(...getAllPrograms(node).map(p => visit(p, self)));\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n\nfunction getRenamedArgsMap(instruction: InstructionNode): Map<string, string> {\n    const argNames = [\n        ...instruction.arguments.map(a => a.name),\n        ...(instruction.extraArguments ?? []).map(a => a.name),\n    ];\n    const duplicateArgs = argNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicateArgs.length > 0) {\n        throw new Error(`Duplicate args found: [${duplicateArgs.join(', ')}] in instruction [${instruction.name}].`);\n    }\n\n    const allNames = [...instruction.accounts.map(account => account.name), ...argNames];\n    const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);\n    if (duplicates.length === 0) return new Map();\n\n    logWarn(\n        `[JavaScript] Accounts and args of instruction [${instruction.name}] have the following ` +\n            `conflicting attributes [${duplicates.join(', ')}]. ` +\n            `Thus, the arguments have been renamed to avoid conflicts in the input type.`,\n    );\n\n    return new Map(duplicates.map(name => [camelCase(name), camelCase(`${name}Arg`)]));\n}\n","import {\n    camelCase,\n    CamelCaseString,\n    CountNode,\n    isNode,\n    isNodeFilter,\n    isScalarEnum,\n    parseDocs,\n    REGISTERED_TYPE_NODE_KINDS,\n    REGISTERED_VALUE_NODE_KINDS,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    structTypeNodeFromInstructionArgumentNodes,\n    TypeNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    findLastNodeFromPath,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\nimport { Fragment, fragment, mergeFragments } from './fragments';\nimport { ImportMap } from './ImportMap';\nimport { NameApi } from './nameTransformers';\nimport { mergeManifests, TypeManifest, typeManifest } from './TypeManifest';\nimport { getBytesFromBytesValueNode, GetImportFromFunction, jsDocblock, ParsedCustomDataOptions } from './utils';\n\nexport type TypeManifestVisitor = ReturnType<typeof getTypeManifestVisitor>;\n\nexport function getTypeManifestVisitor(input: {\n    customAccountData: ParsedCustomDataOptions;\n    customInstructionData: ParsedCustomDataOptions;\n    getImportFrom: GetImportFromFunction;\n    linkables: LinkableDictionary;\n    nameApi: NameApi;\n    nonScalarEnums: CamelCaseString[];\n    stack?: NodeStack;\n}) {\n    const { nameApi, linkables, nonScalarEnums, customAccountData, customInstructionData, getImportFrom } = input;\n    const stack = input.stack ?? new NodeStack();\n    let parentName: { loose: string; strict: string } | null = null;\n\n    return pipe(\n        staticVisitor(\n            () =>\n                ({\n                    decoder: fragment(''),\n                    encoder: fragment(''),\n                    isEnum: false,\n                    looseType: fragment(''),\n                    strictType: fragment(''),\n                    value: fragment(''),\n                }) as TypeManifest,\n            {\n                keys: [\n                    ...REGISTERED_TYPE_NODE_KINDS,\n                    ...REGISTERED_VALUE_NODE_KINDS,\n                    'definedTypeLinkNode',\n                    'definedTypeNode',\n                    'accountNode',\n                    'instructionNode',\n                ],\n            },\n        ),\n        visitor =>\n            extendVisitor(visitor, {\n                visitAccount(account, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(account.name),\n                        strict: nameApi.dataType(account.name),\n                    };\n                    const link = customAccountData.get(account.name)?.linkNode;\n                    const manifest = link ? visit(link, self) : visit(account.data, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitAmountType(amountType, { self }) {\n                    return visit(amountType.number, self);\n                },\n\n                visitArrayType(arrayType, { self }) {\n                    const childManifest = visit(arrayType.item, self);\n                    childManifest.looseType.mapRender(r => `Array<${r}>`);\n                    childManifest.strictType.mapRender(r => `Array<${r}>`);\n                    const sizeManifest = getArrayLikeSizeOption(arrayType.count, self);\n                    const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : '';\n                    const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : '';\n                    childManifest.encoder\n                        .mapRender(r => `getArrayEncoder(${r + encoderOptions})`)\n                        .mergeImportsWith(sizeManifest.encoder)\n                        .addImports('solanaCodecsDataStructures', 'getArrayEncoder');\n                    childManifest.decoder\n                        .mapRender(r => `getArrayDecoder(${r + decoderOptions})`)\n                        .mergeImportsWith(sizeManifest.decoder)\n                        .addImports('solanaCodecsDataStructures', 'getArrayDecoder');\n                    return childManifest;\n                },\n\n                visitArrayValue(node, { self }) {\n                    return mergeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitBooleanType(booleanType, { self }) {\n                    const encoderImports = new ImportMap().add('solanaCodecsDataStructures', 'getBooleanEncoder');\n                    const decoderImports = new ImportMap().add('solanaCodecsDataStructures', 'getBooleanDecoder');\n\n                    let sizeEncoder = '';\n                    let sizeDecoder = '';\n                    const resolvedSize = resolveNestedTypeNode(booleanType.size);\n                    if (resolvedSize.format !== 'u8' || resolvedSize.endian !== 'le') {\n                        const size = visit(booleanType.size, self);\n                        encoderImports.mergeWith(size.encoder);\n                        decoderImports.mergeWith(size.decoder);\n                        sizeEncoder = `{ size: ${size.encoder.render} }`;\n                        sizeDecoder = `{ size: ${size.decoder.render} }`;\n                    }\n\n                    return {\n                        decoder: fragment(`getBooleanDecoder(${sizeDecoder})`, decoderImports),\n                        encoder: fragment(`getBooleanEncoder(${sizeEncoder})`, encoderImports),\n                        isEnum: false,\n                        looseType: fragment('boolean'),\n                        strictType: fragment('boolean'),\n                        value: fragment(''),\n                    };\n                },\n\n                visitBooleanValue(node) {\n                    const manifest = typeManifest();\n                    manifest.value.setRender(JSON.stringify(node.boolean));\n                    return manifest;\n                },\n\n                visitBytesType() {\n                    return {\n                        decoder: fragment(`getBytesDecoder()`).addImports(\n                            'solanaCodecsDataStructures',\n                            'getBytesDecoder',\n                        ),\n                        encoder: fragment(`getBytesEncoder()`).addImports(\n                            'solanaCodecsDataStructures',\n                            'getBytesEncoder',\n                        ),\n                        isEnum: false,\n                        looseType: fragment('ReadonlyUint8Array').addImports(\n                            'solanaCodecsCore',\n                            'type ReadonlyUint8Array',\n                        ),\n                        strictType: fragment('ReadonlyUint8Array').addImports(\n                            'solanaCodecsCore',\n                            'type ReadonlyUint8Array',\n                        ),\n                        value: fragment(''),\n                    };\n                },\n\n                visitBytesValue(node) {\n                    const manifest = typeManifest();\n                    const bytes = getBytesFromBytesValueNode(node);\n                    manifest.value.setRender(`new Uint8Array([${Array.from(bytes).join(', ')}])`);\n                    return manifest;\n                },\n\n                visitConstantValue(node, { self }) {\n                    if (isNode(node.type, 'bytesTypeNode') && isNode(node.value, 'bytesValueNode')) {\n                        return visit(node.value, self);\n                    }\n                    return {\n                        ...typeManifest(),\n                        value: mergeFragments(\n                            [visit(node.type, self).encoder, visit(node.value, self).value],\n                            ([encoderFunction, value]) => `${encoderFunction}.encode(${value})`,\n                        ),\n                    };\n                },\n\n                visitDateTimeType(dateTimeType, { self }) {\n                    return visit(dateTimeType.number, self);\n                },\n\n                visitDefinedType(definedType, { self }) {\n                    parentName = {\n                        loose: nameApi.dataArgsType(definedType.name),\n                        strict: nameApi.dataType(definedType.name),\n                    };\n                    const manifest = visit(definedType.type, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const strictName = nameApi.dataType(node.name);\n                    const looseName = nameApi.dataArgsType(node.name);\n                    const encoderFunction = nameApi.encoderFunction(node.name);\n                    const decoderFunction = nameApi.decoderFunction(node.name);\n                    const importFrom = getImportFrom(node);\n\n                    return {\n                        decoder: fragment(`${decoderFunction}()`).addImports(importFrom, decoderFunction),\n                        encoder: fragment(`${encoderFunction}()`).addImports(importFrom, encoderFunction),\n                        isEnum: false,\n                        looseType: fragment(looseName).addImports(importFrom, `type ${looseName}`),\n                        strictType: fragment(strictName).addImports(importFrom, `type ${strictName}`),\n                        value: fragment(''),\n                    };\n                },\n\n                visitEnumEmptyVariantType(enumEmptyVariantType) {\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(camelCase(parentName?.strict ?? ''));\n                    const name = nameApi.discriminatedUnionVariant(enumEmptyVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    return {\n                        decoder: fragment(`['${name}', getUnitDecoder()]`).addImports(\n                            'solanaCodecsDataStructures',\n                            'getUnitDecoder',\n                        ),\n                        encoder: fragment(`['${name}', getUnitEncoder()]`).addImports(\n                            'solanaCodecsDataStructures',\n                            'getUnitEncoder',\n                        ),\n                        isEnum: false,\n                        looseType: fragment(`{ ${kindAttribute} }`),\n                        strictType: fragment(`{ ${kindAttribute} }`),\n                        value: fragment(''),\n                    };\n                },\n\n                visitEnumStructVariantType(enumStructVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumStructVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n\n                    parentName = null;\n                    const structManifest = visit(enumStructVariantType.struct, self);\n                    parentName = currentParentName;\n\n                    structManifest.strictType.mapRender(r => `{ ${kindAttribute},${r.slice(1, -1)}}`);\n                    structManifest.looseType.mapRender(r => `{ ${kindAttribute},${r.slice(1, -1)}}`);\n                    structManifest.encoder.mapRender(r => `['${name}', ${r}]`);\n                    structManifest.decoder.mapRender(r => `['${name}', ${r}]`);\n                    return structManifest;\n                },\n\n                visitEnumTupleVariantType(enumTupleVariantType, { self }) {\n                    const currentParentName = parentName;\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    const name = nameApi.discriminatedUnionVariant(enumTupleVariantType.name);\n                    const kindAttribute = `${discriminator}: \"${name}\"`;\n                    const struct = structTypeNode([\n                        structFieldTypeNode({\n                            name: 'fields',\n                            type: enumTupleVariantType.tuple,\n                        }),\n                    ]);\n\n                    parentName = null;\n                    const structManifest = visit(struct, self);\n                    parentName = currentParentName;\n\n                    structManifest.strictType.mapRender(r => `{ ${kindAttribute},${r.slice(1, -1)}}`);\n                    structManifest.looseType.mapRender(r => `{ ${kindAttribute},${r.slice(1, -1)}}`);\n                    structManifest.encoder.mapRender(r => `['${name}', ${r}]`);\n                    structManifest.decoder.mapRender(r => `['${name}', ${r}]`);\n                    return structManifest;\n                },\n\n                visitEnumType(enumType, { self }) {\n                    const currentParentName = parentName;\n                    const encoderImports = new ImportMap();\n                    const decoderImports = new ImportMap();\n                    const encoderOptions: string[] = [];\n                    const decoderOptions: string[] = [];\n\n                    const enumSize = resolveNestedTypeNode(enumType.size);\n                    if (enumSize.format !== 'u8' || enumSize.endian !== 'le') {\n                        const sizeManifest = visit(enumType.size, self);\n                        encoderImports.mergeWith(sizeManifest.encoder);\n                        decoderImports.mergeWith(sizeManifest.decoder);\n                        encoderOptions.push(`size: ${sizeManifest.encoder.render}`);\n                        decoderOptions.push(`size: ${sizeManifest.decoder.render}`);\n                    }\n\n                    const discriminator = nameApi.discriminatedUnionDiscriminator(\n                        camelCase(currentParentName?.strict ?? ''),\n                    );\n                    if (!isScalarEnum(enumType) && discriminator !== '__kind') {\n                        encoderOptions.push(`discriminator: '${discriminator}'`);\n                        decoderOptions.push(`discriminator: '${discriminator}'`);\n                    }\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n\n                    if (isScalarEnum(enumType)) {\n                        if (currentParentName === null) {\n                            throw new Error(\n                                'Scalar enums cannot be inlined and must be introduced ' +\n                                    'via a defined type. Ensure you are not inlining a ' +\n                                    'defined type that is a scalar enum through a visitor.',\n                            );\n                        }\n                        const variantNames = enumType.variants.map(({ name }) => nameApi.enumVariant(name));\n                        return {\n                            decoder: fragment(\n                                `getEnumDecoder(${currentParentName.strict + decoderOptionsAsString})`,\n                                decoderImports.add('solanaCodecsDataStructures', 'getEnumDecoder'),\n                            ),\n                            encoder: fragment(\n                                `getEnumEncoder(${currentParentName.strict + encoderOptionsAsString})`,\n                                encoderImports.add('solanaCodecsDataStructures', 'getEnumEncoder'),\n                            ),\n                            isEnum: true,\n                            looseType: fragment(`{ ${variantNames.join(', ')} }`),\n                            strictType: fragment(`{ ${variantNames.join(', ')} }`),\n                            value: fragment(''),\n                        };\n                    }\n\n                    const mergedManifest = mergeManifests(\n                        enumType.variants.map(variant => visit(variant, self)),\n                        {\n                            mergeCodecs: renders => renders.join(', '),\n                            mergeTypes: renders => renders.join(' | '),\n                        },\n                    );\n                    mergedManifest.encoder\n                        .mapRender(r => `getDiscriminatedUnionEncoder([${r}]${encoderOptionsAsString})`)\n                        .mergeImportsWith(encoderImports)\n                        .addImports('solanaCodecsDataStructures', ['getDiscriminatedUnionEncoder']);\n                    mergedManifest.decoder\n                        .mapRender(r => `getDiscriminatedUnionDecoder([${r}]${decoderOptionsAsString})`)\n                        .mergeImportsWith(decoderImports)\n                        .addImports('solanaCodecsDataStructures', ['getDiscriminatedUnionDecoder']);\n                    return mergedManifest;\n                },\n\n                visitEnumValue(node, { self }) {\n                    const manifest = typeManifest();\n                    const enumName = nameApi.dataType(node.enum.name);\n                    const enumFunction = nameApi.discriminatedUnionFunction(node.enum.name);\n                    const importFrom = getImportFrom(node.enum);\n\n                    const enumNode = linkables.get([...stack.getPath(), node.enum])?.type;\n                    const isScalar =\n                        enumNode && isNode(enumNode, 'enumTypeNode')\n                            ? isScalarEnum(enumNode)\n                            : !nonScalarEnums.includes(node.enum.name);\n\n                    if (!node.value && isScalar) {\n                        const variantName = nameApi.enumVariant(node.variant);\n                        manifest.value.setRender(`${enumName}.${variantName}`).addImports(importFrom, enumName);\n                        return manifest;\n                    }\n\n                    const variantName = nameApi.discriminatedUnionVariant(node.variant);\n                    if (!node.value) {\n                        manifest.value\n                            .setRender(`${enumFunction}('${variantName}')`)\n                            .addImports(importFrom, enumFunction);\n                        return manifest;\n                    }\n\n                    manifest.value = visit(node.value, self)\n                        .value.mapRender(r => `${enumFunction}('${variantName}', ${r})`)\n                        .addImports(importFrom, enumFunction);\n                    return manifest;\n                },\n\n                visitFixedSizeType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    manifest.encoder\n                        .mapRender(r => `fixEncoderSize(${r}, ${node.size})`)\n                        .addImports('solanaCodecsCore', 'fixEncoderSize');\n                    manifest.decoder\n                        .mapRender(r => `fixDecoderSize(${r}, ${node.size})`)\n                        .addImports('solanaCodecsCore', 'fixDecoderSize');\n                    return manifest;\n                },\n\n                visitHiddenPrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefixes = node.prefix.map(c => visit(c, self).value);\n                    const prefixEncoders = fragment(prefixes.map(c => `getConstantEncoder(${c.render})`).join(', '))\n                        .addImports('solanaCodecsCore', 'getConstantEncoder')\n                        .mergeImportsWith(...prefixes);\n                    const prefixDecoders = fragment(prefixes.map(c => `getConstantDecoder(${c.render})`).join(', '))\n                        .addImports('solanaCodecsCore', 'getConstantDecoder')\n                        .mergeImportsWith(...prefixes);\n                    manifest.encoder\n                        .mapRender(r => `getHiddenPrefixEncoder(${r}, [${prefixEncoders.render}])`)\n                        .mergeImportsWith(prefixEncoders)\n                        .addImports('solanaCodecsDataStructures', 'getHiddenPrefixEncoder');\n                    manifest.decoder\n                        .mapRender(r => `getHiddenPrefixDecoder(${r}, [${prefixDecoders.render}])`)\n                        .mergeImportsWith(prefixDecoders)\n                        .addImports('solanaCodecsDataStructures', 'getHiddenPrefixDecoder');\n                    return manifest;\n                },\n\n                visitHiddenSuffixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const suffixes = node.suffix.map(c => visit(c, self).value);\n                    const suffixEncoders = fragment(suffixes.map(c => `getConstantEncoder(${c.render})`).join(', '))\n                        .addImports('solanaCodecsCore', 'getConstantEncoder')\n                        .mergeImportsWith(...suffixes);\n                    const suffixDecoders = fragment(suffixes.map(c => `getConstantDecoder(${c.render})`).join(', '))\n                        .addImports('solanaCodecsCore', 'getConstantDecoder')\n                        .mergeImportsWith(...suffixes);\n                    manifest.encoder\n                        .mapRender(r => `getHiddenSuffixEncoder(${r}, [${suffixEncoders.render}])`)\n                        .mergeImportsWith(suffixEncoders)\n                        .addImports('solanaCodecsDataStructures', 'getHiddenSuffixEncoder');\n                    manifest.decoder\n                        .mapRender(r => `getHiddenSuffixDecoder(${r}, [${suffixDecoders.render}])`)\n                        .mergeImportsWith(suffixDecoders)\n                        .addImports('solanaCodecsDataStructures', 'getHiddenSuffixDecoder');\n                    return manifest;\n                },\n\n                visitInstruction(instruction, { self }) {\n                    const instructionDataName = nameApi.instructionDataType(instruction.name);\n                    parentName = {\n                        loose: nameApi.dataArgsType(instructionDataName),\n                        strict: nameApi.dataType(instructionDataName),\n                    };\n                    const link = customInstructionData.get(instruction.name)?.linkNode;\n                    const struct = structTypeNodeFromInstructionArgumentNodes(instruction.arguments);\n                    const manifest = link ? visit(link, self) : visit(struct, self);\n                    parentName = null;\n                    return manifest;\n                },\n\n                visitMapEntryValue(node, { self }) {\n                    return mergeManifests([visit(node.key, self), visit(node.value, self)], {\n                        mergeValues: renders => `[${renders.join(', ')}]`,\n                    });\n                },\n\n                visitMapType(mapType, { self }) {\n                    const key = visit(mapType.key, self);\n                    const value = visit(mapType.value, self);\n                    const mergedManifest = mergeManifests([key, value], {\n                        mergeCodecs: ([k, v]) => `${k}, ${v}`,\n                        mergeTypes: ([k, v]) => `Map<${k}, ${v}>`,\n                    });\n                    const sizeManifest = getArrayLikeSizeOption(mapType.count, self);\n                    const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : '';\n                    const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : '';\n                    mergedManifest.encoder\n                        .mapRender(r => `getMapEncoder(${r}${encoderOptions})`)\n                        .addImports('solanaCodecsDataStructures', 'getMapEncoder');\n                    mergedManifest.decoder\n                        .mapRender(r => `getMapDecoder(${r}${decoderOptions})`)\n                        .addImports('solanaCodecsDataStructures', 'getMapDecoder');\n                    return mergedManifest;\n                },\n\n                visitMapValue(node, { self }) {\n                    const entryFragments = node.entries.map(entry => visit(entry, self));\n                    return mergeManifests(entryFragments, {\n                        mergeValues: renders => `new Map([${renders.join(', ')}])`,\n                    });\n                },\n\n                visitNoneValue() {\n                    const manifest = typeManifest();\n                    manifest.value.setRender('none()').addImports('solanaOptions', 'none');\n                    return manifest;\n                },\n\n                visitNumberType(numberType) {\n                    const encoderFunction = nameApi.encoderFunction(numberType.format);\n                    const decoderFunction = nameApi.decoderFunction(numberType.format);\n                    const isBigNumber = ['u64', 'u128', 'i64', 'i128'].includes(numberType.format);\n                    const encoderImports = new ImportMap().add('solanaCodecsNumbers', encoderFunction);\n                    const decoderImports = new ImportMap().add('solanaCodecsNumbers', decoderFunction);\n                    let endianness = '';\n                    if (numberType.endian === 'be') {\n                        encoderImports.add('solanaCodecsNumbers', 'Endian');\n                        decoderImports.add('solanaCodecsNumbers', 'Endian');\n                        endianness = '{ endian: Endian.Big }';\n                    }\n                    return {\n                        decoder: fragment(`${decoderFunction}(${endianness})`, decoderImports),\n                        encoder: fragment(`${encoderFunction}(${endianness})`, encoderImports),\n                        isEnum: false,\n                        looseType: fragment(isBigNumber ? 'number | bigint' : 'number'),\n                        strictType: fragment(isBigNumber ? 'bigint' : 'number'),\n                        value: fragment(''),\n                    };\n                },\n\n                visitNumberValue(node) {\n                    const manifest = typeManifest();\n                    manifest.value.setRender(JSON.stringify(node.number));\n                    return manifest;\n                },\n\n                visitOptionType(optionType, { self }) {\n                    const childManifest = visit(optionType.item, self);\n                    childManifest.strictType.mapRender(r => `Option<${r}>`).addImports('solanaOptions', 'type Option');\n                    childManifest.looseType\n                        .mapRender(r => `OptionOrNullable<${r}>`)\n                        .addImports('solanaOptions', 'type OptionOrNullable');\n                    const encoderOptions: string[] = [];\n                    const decoderOptions: string[] = [];\n\n                    // Prefix option.\n                    const optionPrefix = resolveNestedTypeNode(optionType.prefix);\n                    if (optionPrefix.format !== 'u8' || optionPrefix.endian !== 'le') {\n                        const prefixManifest = visit(optionType.prefix, self);\n                        childManifest.encoder.mergeImportsWith(prefixManifest.encoder);\n                        childManifest.decoder.mergeImportsWith(prefixManifest.decoder);\n                        encoderOptions.push(`prefix: ${prefixManifest.encoder.render}`);\n                        decoderOptions.push(`prefix: ${prefixManifest.decoder.render}`);\n                    }\n\n                    // Fixed option.\n                    if (optionType.fixed) {\n                        encoderOptions.push(`noneValue: \"zeroes\"`);\n                        decoderOptions.push(`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n                    childManifest.encoder\n                        .mapRender(r => `getOptionEncoder(${r + encoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionEncoder');\n                    childManifest.decoder\n                        .mapRender(r => `getOptionDecoder(${r + decoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionDecoder');\n                    return childManifest;\n                },\n\n                visitPostOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        manifest.encoder\n                            .mapRender(r => `padRightEncoder(${r}, ${node.offset})`)\n                            .addImports('solanaCodecsCore', 'padRightEncoder');\n                        manifest.decoder\n                            .mapRender(r => `padRightDecoder(${r}, ${node.offset})`)\n                            .addImports('solanaCodecsCore', 'padRightDecoder');\n                        return manifest;\n                    }\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'preOffset':\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ postOffset }) => postOffset ${node.offset}`\n                                    : `({ postOffset }) => postOffset + ${node.offset}`;\n                        }\n                    })();\n                    manifest.encoder\n                        .mapRender(r => `offsetEncoder(${r}, { postOffset: ${fn} })`)\n                        .addImports('solanaCodecsCore', 'offsetEncoder');\n                    manifest.decoder\n                        .mapRender(r => `offsetDecoder(${r}, { postOffset: ${fn} })`)\n                        .addImports('solanaCodecsCore', 'offsetDecoder');\n                    return manifest;\n                },\n\n                visitPreOffsetType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    if (node.strategy === 'padded') {\n                        manifest.encoder\n                            .mapRender(r => `padLeftEncoder(${r}, ${node.offset})`)\n                            .addImports('solanaCodecsCore', 'padLeftEncoder');\n                        manifest.decoder\n                            .mapRender(r => `padLeftDecoder(${r}, ${node.offset})`)\n                            .addImports('solanaCodecsCore', 'padLeftDecoder');\n                        return manifest;\n                    }\n                    const fn = (() => {\n                        switch (node.strategy) {\n                            case 'absolute':\n                                return node.offset < 0\n                                    ? `({ wrapBytes }) => wrapBytes(${node.offset})`\n                                    : `() => ${node.offset}`;\n                            case 'relative':\n                            default:\n                                return node.offset < 0\n                                    ? `({ preOffset }) => preOffset ${node.offset}`\n                                    : `({ preOffset }) => preOffset + ${node.offset}`;\n                        }\n                    })();\n                    manifest.encoder\n                        .mapRender(r => `offsetEncoder(${r}, { preOffset: ${fn} })`)\n                        .addImports('solanaCodecsCore', 'offsetEncoder');\n                    manifest.decoder\n                        .mapRender(r => `offsetDecoder(${r}, { preOffset: ${fn} })`)\n                        .addImports('solanaCodecsCore', 'offsetDecoder');\n                    return manifest;\n                },\n\n                visitPublicKeyType() {\n                    const imports = new ImportMap().add('solanaAddresses', 'type Address');\n                    return {\n                        decoder: fragment('getAddressDecoder()').addImports('solanaAddresses', 'getAddressDecoder'),\n                        encoder: fragment('getAddressEncoder()').addImports('solanaAddresses', 'getAddressEncoder'),\n                        isEnum: false,\n                        looseType: fragment('Address', imports),\n                        strictType: fragment('Address', imports),\n                        value: fragment(''),\n                    };\n                },\n\n                visitPublicKeyValue(node) {\n                    const manifest = typeManifest();\n                    manifest.value.setRender(`address(\"${node.publicKey}\")`).addImports('solanaAddresses', 'address');\n                    return manifest;\n                },\n\n                visitRemainderOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    childManifest.strictType.mapRender(r => `Option<${r}>`).addImports('solanaOptions', 'type Option');\n                    childManifest.looseType\n                        .mapRender(r => `OptionOrNullable<${r}>`)\n                        .addImports('solanaOptions', 'type OptionOrNullable');\n                    const encoderOptions: string[] = ['prefix: null'];\n                    const decoderOptions: string[] = ['prefix: null'];\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n                    childManifest.encoder\n                        .mapRender(r => `getOptionEncoder(${r + encoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionEncoder');\n                    childManifest.decoder\n                        .mapRender(r => `getOptionDecoder(${r + decoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionDecoder');\n                    return childManifest;\n                },\n\n                visitSentinelType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const sentinel = visit(node.sentinel, self).value;\n                    manifest.encoder\n                        .mapRender(r => `addEncoderSentinel(${r}, ${sentinel.render})`)\n                        .mergeImportsWith(sentinel)\n                        .addImports('solanaCodecsCore', 'addEncoderSentinel');\n                    manifest.decoder\n                        .mapRender(r => `addDecoderSentinel(${r}, ${sentinel.render})`)\n                        .mergeImportsWith(sentinel)\n                        .addImports('solanaCodecsCore', 'addDecoderSentinel');\n                    return manifest;\n                },\n\n                visitSetType(setType, { self }) {\n                    const childManifest = visit(setType.item, self);\n                    childManifest.strictType.mapRender(r => `Set<${r}>`);\n                    childManifest.looseType.mapRender(r => `Set<${r}>`);\n\n                    const sizeManifest = getArrayLikeSizeOption(setType.count, self);\n                    const encoderOptions = sizeManifest.encoder.render ? `, { ${sizeManifest.encoder.render} }` : '';\n                    const decoderOptions = sizeManifest.decoder.render ? `, { ${sizeManifest.decoder.render} }` : '';\n                    childManifest.encoder\n                        .mergeImportsWith(sizeManifest.encoder)\n                        .mapRender(r => `getSetEncoder(${r + encoderOptions})`)\n                        .addImports('solanaCodecsDataStructures', 'getSetEncoder');\n                    childManifest.decoder\n                        .mergeImportsWith(sizeManifest.decoder)\n                        .mapRender(r => `getSetDecoder(${r + decoderOptions})`)\n                        .addImports('solanaCodecsDataStructures', 'getSetDecoder');\n\n                    return childManifest;\n                },\n\n                visitSetValue(node, { self }) {\n                    return mergeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `new Set([${renders.join(', ')}])` },\n                    );\n                },\n\n                visitSizePrefixType(node, { self }) {\n                    const manifest = visit(node.type, self);\n                    const prefix = visit(node.prefix, self);\n                    manifest.encoder\n                        .mapRender(r => `addEncoderSizePrefix(${r}, ${prefix.encoder.render})`)\n                        .mergeImportsWith(prefix.encoder)\n                        .addImports('solanaCodecsCore', 'addEncoderSizePrefix');\n                    manifest.decoder\n                        .mapRender(r => `addDecoderSizePrefix(${r}, ${prefix.decoder.render})`)\n                        .mergeImportsWith(prefix.decoder)\n                        .addImports('solanaCodecsCore', 'addDecoderSizePrefix');\n                    return manifest;\n                },\n\n                visitSolAmountType({ number }, { self }) {\n                    const numberManifest = visit(number, self);\n\n                    const lamportsType = 'Lamports';\n                    const lamportsImport = new ImportMap().add('solanaRpcTypes', 'type Lamports');\n\n                    return {\n                        ...numberManifest,\n                        decoder: numberManifest.decoder\n                            .mapRender(r => `getLamportsDecoder(${r})`)\n                            .addImports('solanaRpcTypes', 'getLamportsDecoder'),\n                        encoder: numberManifest.encoder\n                            .mapRender(r => `getLamportsEncoder(${r})`)\n                            .addImports('solanaRpcTypes', 'getLamportsEncoder'),\n                        looseType: fragment(lamportsType, lamportsImport),\n                        strictType: fragment(lamportsType, lamportsImport),\n                    };\n                },\n\n                visitSomeValue(node, { self }) {\n                    const manifest = typeManifest();\n                    manifest.value = visit(node.value, self)\n                        .value.mapRender(r => `some(${r})`)\n                        .addImports('solanaOptions', 'some');\n                    return manifest;\n                },\n\n                visitStringType(stringType) {\n                    const [encoder, decoder] = (() => {\n                        switch (stringType.encoding) {\n                            case 'base16':\n                                return ['getBase16Encoder', 'getBase16Decoder'];\n                            case 'base58':\n                                return ['getBase58Encoder', 'getBase58Decoder'];\n                            case 'base64':\n                                return ['getBase64Encoder', 'getBase64Decoder'];\n                            case 'utf8':\n                                return ['getUtf8Encoder', 'getUtf8Decoder'];\n                            default:\n                                throw new Error(`Unsupported string encoding: ${stringType.encoding as string}`);\n                        }\n                    })();\n                    return {\n                        decoder: fragment(`${decoder}()`).addImports('solanaCodecsStrings', decoder),\n                        encoder: fragment(`${encoder}()`).addImports('solanaCodecsStrings', encoder),\n                        isEnum: false,\n                        looseType: fragment('string'),\n                        strictType: fragment('string'),\n                        value: fragment(''),\n                    };\n                },\n\n                visitStringValue(node) {\n                    const manifest = typeManifest();\n                    manifest.value.setRender(JSON.stringify(node.string));\n                    return manifest;\n                },\n\n                visitStructFieldType(structFieldType, { self }) {\n                    const name = camelCase(structFieldType.name);\n                    const childManifest = visit(structFieldType.type, self);\n                    const structFieldDocs = parseDocs(structFieldType.docs);\n                    const docblock = structFieldDocs.length > 0 ? `\\n${jsDocblock(structFieldDocs)}` : '';\n                    const originalLooseType = childManifest.looseType.render;\n                    childManifest.strictType.mapRender(r => `${docblock}${name}: ${r}; `);\n                    childManifest.looseType.mapRender(r => `${docblock}${name}: ${r}; `);\n                    childManifest.encoder.mapRender(r => `['${name}', ${r}]`);\n                    childManifest.decoder.mapRender(r => `['${name}', ${r}]`);\n\n                    // No default value.\n                    if (!structFieldType.defaultValue) {\n                        return childManifest;\n                    }\n\n                    // Optional default value.\n                    if (structFieldType.defaultValueStrategy !== 'omitted') {\n                        childManifest.looseType.setRender(`${docblock}${name}?: ${originalLooseType}; `);\n                        return childManifest;\n                    }\n\n                    // Omitted default value.\n                    childManifest.looseType = fragment('');\n                    return childManifest;\n                },\n\n                visitStructFieldValue(node, { self }) {\n                    const manifest = typeManifest();\n                    manifest.value = visit(node.value, self).value.mapRender(r => `${node.name}: ${r}`);\n                    return manifest;\n                },\n\n                visitStructType(structType, { self }) {\n                    const optionalFields = structType.fields.filter(f => !!f.defaultValue);\n\n                    const mergedManifest = mergeManifests(\n                        structType.fields.map(field => visit(field, self)),\n                        {\n                            mergeCodecs: renders => `([${renders.join(', ')}])`,\n                            mergeTypes: renders => `{ ${renders.join('')} }`,\n                        },\n                    );\n\n                    mergedManifest.encoder\n                        .mapRender(r => `getStructEncoder${r}`)\n                        .addImports('solanaCodecsDataStructures', 'getStructEncoder');\n                    mergedManifest.decoder\n                        .mapRender(r => `getStructDecoder${r}`)\n                        .addImports('solanaCodecsDataStructures', 'getStructDecoder');\n\n                    if (optionalFields.length === 0) {\n                        return mergedManifest;\n                    }\n\n                    // Check if we are inside an instruction or account to use discriminator constants when available.\n                    const parentPath = stack.getPath();\n                    const instructionNode = findLastNodeFromPath(parentPath, 'instructionNode');\n                    const accountNode = findLastNodeFromPath(parentPath, 'accountNode');\n                    const discriminatorPrefix = instructionNode ? instructionNode.name : accountNode?.name;\n                    const discriminators =\n                        (instructionNode ? instructionNode.discriminators : accountNode?.discriminators) ?? [];\n                    const fieldDiscriminators = discriminators.filter(isNodeFilter('fieldDiscriminatorNode'));\n\n                    const defaultValues = optionalFields\n                        .map(f => {\n                            const key = camelCase(f.name);\n\n                            // If the field has an associated discriminator node, use the constant value instead.\n                            if (fieldDiscriminators.some(d => d.name === f.name)) {\n                                const constantName = nameApi.constant(camelCase(`${discriminatorPrefix}_${f.name}`));\n                                return f.defaultValueStrategy === 'omitted'\n                                    ? `${key}: ${constantName}`\n                                    : `${key}: value.${key} ?? ${constantName}`;\n                            }\n\n                            const defaultValue = f.defaultValue as NonNullable<typeof f.defaultValue>;\n                            const { render: renderedValue, imports } = visit(defaultValue, self).value;\n                            mergedManifest.encoder.mergeImportsWith(imports);\n                            return f.defaultValueStrategy === 'omitted'\n                                ? `${key}: ${renderedValue}`\n                                : `${key}: value.${key} ?? ${renderedValue}`;\n                        })\n                        .join(', ');\n                    mergedManifest.encoder\n                        .mapRender(r => `transformEncoder(${r}, (value) => ({ ...value, ${defaultValues} }))`)\n                        .addImports('solanaCodecsCore', 'transformEncoder');\n                    return mergedManifest;\n                },\n\n                visitStructValue(node, { self }) {\n                    return mergeManifests(\n                        node.fields.map(field => visit(field, self)),\n                        { mergeValues: renders => `{ ${renders.join(', ')} }` },\n                    );\n                },\n\n                visitTupleType(tupleType, { self }) {\n                    const items = tupleType.items.map(item => visit(item, self));\n                    const mergedManifest = mergeManifests(items, {\n                        mergeCodecs: codecs => `[${codecs.join(', ')}]`,\n                        mergeTypes: types => `readonly [${types.join(', ')}]`,\n                    });\n                    mergedManifest.encoder\n                        .mapRender(render => `getTupleEncoder(${render})`)\n                        .addImports('solanaCodecsDataStructures', 'getTupleEncoder');\n                    mergedManifest.decoder\n                        .mapRender(render => `getTupleDecoder(${render})`)\n                        .addImports('solanaCodecsDataStructures', 'getTupleDecoder');\n                    return mergedManifest;\n                },\n\n                visitTupleValue(node, { self }) {\n                    return mergeManifests(\n                        node.items.map(v => visit(v, self)),\n                        { mergeValues: renders => `[${renders.join(', ')}]` },\n                    );\n                },\n\n                visitZeroableOptionType(node, { self }) {\n                    const childManifest = visit(node.item, self);\n                    childManifest.strictType.mapRender(r => `Option<${r}>`).addImports('solanaOptions', 'type Option');\n                    childManifest.looseType\n                        .mapRender(r => `OptionOrNullable<${r}>`)\n                        .addImports('solanaOptions', 'type OptionOrNullable');\n                    const encoderOptions: string[] = ['prefix: null'];\n                    const decoderOptions: string[] = ['prefix: null'];\n\n                    // Zero-value option.\n                    if (node.zeroValue) {\n                        const zeroValueManifest = visit(node.zeroValue, self);\n                        childManifest.encoder.mergeImportsWith(zeroValueManifest.value);\n                        childManifest.decoder.mergeImportsWith(zeroValueManifest.value);\n                        encoderOptions.push(`noneValue: ${zeroValueManifest.value.render}`);\n                        decoderOptions.push(`noneValue: ${zeroValueManifest.value.render}`);\n                    } else {\n                        encoderOptions.push(`noneValue: \"zeroes\"`);\n                        decoderOptions.push(`noneValue: \"zeroes\"`);\n                    }\n\n                    const encoderOptionsAsString =\n                        encoderOptions.length > 0 ? `, { ${encoderOptions.join(', ')} }` : '';\n                    const decoderOptionsAsString =\n                        decoderOptions.length > 0 ? `, { ${decoderOptions.join(', ')} }` : '';\n                    childManifest.encoder\n                        .mapRender(r => `getOptionEncoder(${r + encoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionEncoder');\n                    childManifest.decoder\n                        .mapRender(r => `getOptionDecoder(${r + decoderOptionsAsString})`)\n                        .addImports('solanaOptions', 'getOptionDecoder');\n                    return childManifest;\n                },\n            }),\n        visitor => recordNodeStackVisitor(visitor, stack),\n    );\n}\n\nfunction getArrayLikeSizeOption(\n    count: CountNode,\n    visitor: Visitor<TypeManifest, TypeNode['kind']>,\n): {\n    decoder: Fragment;\n    encoder: Fragment;\n} {\n    if (isNode(count, 'fixedCountNode')) {\n        return {\n            decoder: fragment(`size: ${count.value}`),\n            encoder: fragment(`size: ${count.value}`),\n        };\n    }\n    if (isNode(count, 'remainderCountNode')) {\n        return {\n            decoder: fragment(`size: 'remainder'`),\n            encoder: fragment(`size: 'remainder'`),\n        };\n    }\n    const prefix = resolveNestedTypeNode(count.prefix);\n    if (prefix.format === 'u32' && prefix.endian === 'le') {\n        return { decoder: fragment(''), encoder: fragment('') };\n    }\n    const prefixManifest = visit(count.prefix, visitor);\n    prefixManifest.encoder.mapRender(r => `size: ${r}`);\n    prefixManifest.decoder.mapRender(r => `size: ${r}`);\n    return prefixManifest;\n}\n","import { camelCase, capitalize, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\n\nexport type NameTransformerHelpers = {\n    camelCase: (name: string) => string;\n    capitalize: (name: string) => string;\n    kebabCase: (name: string) => string;\n    pascalCase: (name: string) => string;\n    snakeCase: (name: string) => string;\n    titleCase: (name: string) => string;\n};\n\nexport type NameTransformer = (name: string, helpers: NameTransformerHelpers) => string;\n\nexport type NameTransformerKey =\n    | 'accountDecodeFunction'\n    | 'accountFetchAllFunction'\n    | 'accountFetchAllMaybeFunction'\n    | 'accountFetchFromSeedsFunction'\n    | 'accountFetchFunction'\n    | 'accountFetchMaybeFromSeedsFunction'\n    | 'accountFetchMaybeFunction'\n    | 'accountGetSizeFunction'\n    | 'codecFunction'\n    | 'constant'\n    | 'constantFunction'\n    | 'dataArgsType'\n    | 'dataType'\n    | 'decoderFunction'\n    | 'discriminatedUnionDiscriminator'\n    | 'discriminatedUnionFunction'\n    | 'discriminatedUnionVariant'\n    | 'encoderFunction'\n    | 'enumVariant'\n    | 'instructionAsyncFunction'\n    | 'instructionAsyncInputType'\n    | 'instructionDataType'\n    | 'instructionExtraType'\n    | 'instructionParsedType'\n    | 'instructionParseFunction'\n    | 'instructionSyncFunction'\n    | 'instructionSyncInputType'\n    | 'instructionType'\n    | 'isDiscriminatedUnionFunction'\n    | 'pdaFindFunction'\n    | 'pdaSeedsType'\n    | 'programAccountsEnum'\n    | 'programAccountsEnumVariant'\n    | 'programAccountsIdentifierFunction'\n    | 'programAddressConstant'\n    | 'programErrorConstant'\n    | 'programErrorConstantPrefix'\n    | 'programErrorMessagesMap'\n    | 'programErrorUnion'\n    | 'programGetErrorMessageFunction'\n    | 'programInstructionsEnum'\n    | 'programInstructionsEnumVariant'\n    | 'programInstructionsIdentifierFunction'\n    | 'programInstructionsParsedUnionType'\n    | 'programIsErrorFunction'\n    | 'resolverFunction';\n\nexport type NameTransformers = Record<NameTransformerKey, NameTransformer>;\n\nexport type NameApi = Record<NameTransformerKey, (name: string) => string>;\n\nexport function getNameApi(transformers: NameTransformers): NameApi {\n    const helpers = {\n        camelCase,\n        capitalize,\n        kebabCase,\n        pascalCase,\n        snakeCase,\n        titleCase,\n    };\n    return Object.fromEntries(\n        Object.entries(transformers).map(([key, transformer]) => [key, (name: string) => transformer(name, helpers)]),\n    ) as NameApi;\n}\n\nexport const DEFAULT_NAME_TRANSFORMERS: NameTransformers = {\n    accountDecodeFunction: name => `decode${pascalCase(name)}`,\n    accountFetchAllFunction: name => `fetchAll${pascalCase(name)}`,\n    accountFetchAllMaybeFunction: name => `fetchAllMaybe${pascalCase(name)}`,\n    accountFetchFromSeedsFunction: name => `fetch${pascalCase(name)}FromSeeds`,\n    accountFetchFunction: name => `fetch${pascalCase(name)}`,\n    accountFetchMaybeFromSeedsFunction: name => `fetchMaybe${pascalCase(name)}FromSeeds`,\n    accountFetchMaybeFunction: name => `fetchMaybe${pascalCase(name)}`,\n    accountGetSizeFunction: name => `get${pascalCase(name)}Size`,\n    codecFunction: name => `get${pascalCase(name)}Codec`,\n    constant: name => snakeCase(name).toUpperCase(),\n    constantFunction: name => `get${pascalCase(name)}Bytes`,\n    dataArgsType: name => `${pascalCase(name)}Args`,\n    dataType: name => `${pascalCase(name)}`,\n    decoderFunction: name => `get${pascalCase(name)}Decoder`,\n    discriminatedUnionDiscriminator: () => '__kind',\n    discriminatedUnionFunction: name => `${camelCase(name)}`,\n    discriminatedUnionVariant: name => `${pascalCase(name)}`,\n    encoderFunction: name => `get${pascalCase(name)}Encoder`,\n    enumVariant: name => `${pascalCase(name)}`,\n    instructionAsyncFunction: name => `get${pascalCase(name)}InstructionAsync`,\n    instructionAsyncInputType: name => `${pascalCase(name)}AsyncInput`,\n    instructionDataType: name => `${pascalCase(name)}InstructionData`,\n    instructionExtraType: name => `${pascalCase(name)}InstructionExtra`,\n    instructionParseFunction: name => `parse${pascalCase(name)}Instruction`,\n    instructionParsedType: name => `Parsed${pascalCase(name)}Instruction`,\n    instructionSyncFunction: name => `get${pascalCase(name)}Instruction`,\n    instructionSyncInputType: name => `${pascalCase(name)}Input`,\n    instructionType: name => `${pascalCase(name)}Instruction`,\n    isDiscriminatedUnionFunction: name => `is${pascalCase(name)}`,\n    pdaFindFunction: name => `find${pascalCase(name)}Pda`,\n    pdaSeedsType: name => `${pascalCase(name)}Seeds`,\n    programAccountsEnum: name => `${pascalCase(name)}Account`,\n    programAccountsEnumVariant: name => `${pascalCase(name)}`,\n    programAccountsIdentifierFunction: name => `identify${pascalCase(name)}Account`,\n    programAddressConstant: name => `${snakeCase(name).toUpperCase()}_PROGRAM_ADDRESS`,\n    programErrorConstant: name => snakeCase(name).toUpperCase(),\n    programErrorConstantPrefix: name => `${snakeCase(name).toUpperCase()}_ERROR__`,\n    programErrorMessagesMap: name => `${camelCase(name)}ErrorMessages`,\n    programErrorUnion: name => `${pascalCase(name)}Error`,\n    programGetErrorMessageFunction: name => `get${pascalCase(name)}ErrorMessage`,\n    programInstructionsEnum: name => `${pascalCase(name)}Instruction`,\n    programInstructionsEnumVariant: name => `${pascalCase(name)}`,\n    programInstructionsIdentifierFunction: name => `identify${pascalCase(name)}Instruction`,\n    programInstructionsParsedUnionType: name => `Parsed${pascalCase(name)}Instruction`,\n    programIsErrorFunction: name => `is${pascalCase(name)}Error`,\n    resolverFunction: name => `${camelCase(name)}`,\n};\n","import { deleteDirectory } from '@codama/renderers-core';\nimport { rootNodeVisitor, visit } from '@codama/visitors-core';\nimport { Plugin } from 'prettier';\nimport * as estreePlugin from 'prettier/plugins/estree';\nimport * as typeScriptPlugin from 'prettier/plugins/typescript';\nimport { format } from 'prettier/standalone';\n\nimport { GetRenderMapOptions, getRenderMapVisitor } from './getRenderMapVisitor';\n\ntype PrettierOptions = Parameters<typeof format>[1];\n\nexport type RenderOptions = GetRenderMapOptions & {\n    deleteFolderBeforeRendering?: boolean;\n    formatCode?: boolean;\n    prettierOptions?: PrettierOptions;\n};\n\nconst DEFAULT_PRETTIER_OPTIONS: PrettierOptions = {\n    arrowParens: 'always',\n    parser: 'typescript',\n    plugins: [estreePlugin as Plugin<unknown>, typeScriptPlugin],\n    printWidth: 80,\n    semi: true,\n    singleQuote: true,\n    tabWidth: 2,\n    trailingComma: 'es5',\n    useTabs: false,\n};\n\nexport function renderVisitor(path: string, options: RenderOptions = {}) {\n    return rootNodeVisitor(async root => {\n        // Delete existing generated folder.\n        if (options.deleteFolderBeforeRendering ?? true) {\n            deleteDirectory(path);\n        }\n\n        // Render the new files.\n        const renderMap = visit(root, getRenderMapVisitor(options));\n\n        // Format the code.\n        if (options.formatCode ?? true) {\n            const prettierOptions = { ...DEFAULT_PRETTIER_OPTIONS, ...options.prettierOptions };\n            await renderMap.mapContentAsync(code => format(code, prettierOptions));\n        }\n\n        renderMap.write(path);\n    });\n}\n"],"mappings":"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","names":["module","import_visitors_core","import_node_path","import_nodes","import_nodes","nunjucks","render","module","typeManifest","import_nodes","import_visitors_core","typeManifest","import_visitors_core","import_visitors_core","typeManifest","import_nodes","import_visitors_core","import_codecs_strings","import_nodes","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_visitors_core","import_nodes","import_visitors_core","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","pdaSeeds","typeManifest","valueManifest","programAddress","import_nodes","import_visitors_core","getAccountTypeFragment","import_nodes","import_visitors_core","getRemainingAccountsFragment","getArgumentValueNodeFragment","getResolverValueNodeFragment","import_visitors_core","import_nodes","import_visitors_core","fragment","import_nodes","import_visitors_core","seedManifest","import_nodes","import_nodes","import_nodes","import_node_path","import_errors","import_nodes","import_visitors_core","import_nodes","import_visitors_core","variantName","render","import_nodes","render","import_renderers_core","import_visitors_core"]}