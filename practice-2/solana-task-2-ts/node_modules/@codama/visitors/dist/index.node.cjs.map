{"version":3,"sources":["../src/index.ts","../src/addPdasVisitor.ts","../src/createSubInstructionsFromEnumArgsVisitor.ts","../src/flattenInstructionDataArgumentsVisitor.ts","../src/deduplicateIdenticalDefinedTypesVisitor.ts","../src/fillDefaultPdaSeedValuesVisitor.ts","../src/flattenStructVisitor.ts","../src/getDefinedTypeHistogramVisitor.ts","../src/setAccountDiscriminatorFromFieldVisitor.ts","../src/setFixedAccountSizesVisitor.ts","../src/setInstructionAccountDefaultValuesVisitor.ts","../src/setInstructionDiscriminatorsVisitor.ts","../src/setNumberWrappersVisitor.ts","../src/setStructDefaultValuesVisitor.ts","../src/transformDefinedTypesIntoAccountsVisitor.ts","../src/transformU8ArraysToBytesVisitor.ts","../src/unwrapDefinedTypesVisitor.ts","../src/unwrapInstructionArgsDefinedTypesVisitor.ts","../src/unwrapTupleEnumWithSingleStructVisitor.ts","../src/unwrapTypeDefinedLinksVisitor.ts","../src/updateAccountsVisitor.ts","../src/renameHelpers.ts","../src/updateDefinedTypesVisitor.ts","../src/updateErrorsVisitor.ts","../src/updateInstructionsVisitor.ts","../src/updateProgramsVisitor.ts"],"sourcesContent":["export * from '@codama/visitors-core';\n\nexport * from './addPdasVisitor';\nexport * from './createSubInstructionsFromEnumArgsVisitor';\nexport * from './deduplicateIdenticalDefinedTypesVisitor';\nexport * from './fillDefaultPdaSeedValuesVisitor';\nexport * from './flattenInstructionDataArgumentsVisitor';\nexport * from './flattenStructVisitor';\nexport * from './getDefinedTypeHistogramVisitor';\nexport * from './setAccountDiscriminatorFromFieldVisitor';\nexport * from './setFixedAccountSizesVisitor';\nexport * from './setInstructionAccountDefaultValuesVisitor';\nexport * from './setInstructionDiscriminatorsVisitor';\nexport * from './setNumberWrappersVisitor';\nexport * from './setStructDefaultValuesVisitor';\nexport * from './transformDefinedTypesIntoAccountsVisitor';\nexport * from './transformU8ArraysToBytesVisitor';\nexport * from './unwrapDefinedTypesVisitor';\nexport * from './unwrapInstructionArgsDefinedTypesVisitor';\nexport * from './unwrapTupleEnumWithSingleStructVisitor';\nexport * from './unwrapTypeDefinedLinksVisitor';\nexport * from './updateAccountsVisitor';\nexport * from './updateDefinedTypesVisitor';\nexport * from './updateErrorsVisitor';\nexport * from './updateInstructionsVisitor';\nexport * from './updateProgramsVisitor';\n","import { CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES, CodamaError } from '@codama/errors';\nimport { assertIsNode, camelCase, pdaNode, PdaSeedNode, programNode } from '@codama/nodes';\nimport { bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function addPdasVisitor(pdas: Record<string, { name: string; seeds: PdaSeedNode[] }[]>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(pdas).map(([uncasedProgramName, newPdas]) => {\n            const programName = camelCase(uncasedProgramName);\n            return {\n                select: `[programNode]${programName}`,\n                transform: node => {\n                    assertIsNode(node, 'programNode');\n                    const existingPdaNames = new Set(node.pdas.map(pda => pda.name));\n                    const newPdaNames = new Set(newPdas.map(pda => pda.name));\n                    const overlappingPdaNames = new Set([...existingPdaNames].filter(name => newPdaNames.has(name)));\n                    if (overlappingPdaNames.size > 0) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES, {\n                            duplicatedPdaNames: [...overlappingPdaNames],\n                            program: node,\n                            programName: node.name,\n                        });\n                    }\n                    return programNode({\n                        ...node,\n                        pdas: [...node.pdas, ...newPdas.map(pda => pdaNode({ name: pda.name, seeds: pda.seeds }))],\n                    });\n                },\n            };\n        }),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    EnumTypeNode,\n    instructionArgumentNode,\n    InstructionNode,\n    instructionNode,\n    isNode,\n    numberTypeNode,\n    numberValueNode,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n} from '@codama/visitors-core';\n\nimport { flattenInstructionArguments } from './flattenInstructionDataArgumentsVisitor';\n\nexport function createSubInstructionsFromEnumArgsVisitor(map: Record<string, string>) {\n    const linkables = new LinkableDictionary();\n\n    const visitor = bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, argNameInput]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[instructionNode]', selector],\n                transform: (node, stack) => {\n                    assertIsNode(node, 'instructionNode');\n\n                    const argFields = node.arguments;\n                    const argName = camelCase(argNameInput);\n                    const argFieldIndex = argFields.findIndex(field => field.name === argName);\n                    const argField = argFieldIndex >= 0 ? argFields[argFieldIndex] : null;\n                    if (!argField) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {\n                            argumentName: argName,\n                            instruction: node,\n                            instructionName: node.name,\n                        });\n                    }\n\n                    let argType: EnumTypeNode;\n                    if (isNode(argField.type, 'enumTypeNode')) {\n                        argType = argField.type;\n                    } else if (\n                        isNode(argField.type, 'definedTypeLinkNode') &&\n                        linkables.has([...stack.getPath(), argField.type])\n                    ) {\n                        const linkedType = linkables.get([...stack.getPath(), argField.type])?.type;\n                        assertIsNode(linkedType, 'enumTypeNode');\n                        argType = linkedType;\n                    } else {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {\n                            argumentName: argName,\n                            instruction: node,\n                            instructionName: node.name,\n                        });\n                    }\n\n                    const subInstructions = argType.variants.map((variant, index): InstructionNode => {\n                        const subName = camelCase(`${node.name} ${variant.name}`);\n                        const subFields = argFields.slice(0, argFieldIndex);\n                        subFields.push(\n                            instructionArgumentNode({\n                                defaultValue: numberValueNode(index),\n                                defaultValueStrategy: 'omitted',\n                                name: `${subName}Discriminator`,\n                                type: numberTypeNode('u8'),\n                            }),\n                        );\n                        if (isNode(variant, 'enumStructVariantTypeNode')) {\n                            subFields.push(\n                                instructionArgumentNode({\n                                    ...argField,\n                                    type: variant.struct,\n                                }),\n                            );\n                        } else if (isNode(variant, 'enumTupleVariantTypeNode')) {\n                            subFields.push(\n                                instructionArgumentNode({\n                                    ...argField,\n                                    type: variant.tuple,\n                                }),\n                            );\n                        }\n                        subFields.push(...argFields.slice(argFieldIndex + 1));\n\n                        return instructionNode({\n                            ...node,\n                            arguments: flattenInstructionArguments(subFields),\n                            name: subName,\n                        });\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        subInstructions: [...(node.subInstructions ?? []), ...subInstructions],\n                    });\n                },\n            }),\n        ),\n    );\n\n    return pipe(visitor, v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import { CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    instructionNode,\n    isNode,\n} from '@codama/nodes';\nimport { bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function flattenInstructionDataArgumentsVisitor() {\n    return bottomUpTransformerVisitor([\n        {\n            select: '[instructionNode]',\n            transform: instruction => {\n                assertIsNode(instruction, 'instructionNode');\n                return instructionNode({\n                    ...instruction,\n                    arguments: flattenInstructionArguments(instruction.arguments),\n                });\n            },\n        },\n    ]);\n}\n\nexport type FlattenInstructionArgumentsConfig = string[] | '*';\n\nexport const flattenInstructionArguments = (\n    nodes: InstructionArgumentNode[],\n    options: FlattenInstructionArgumentsConfig = '*',\n): InstructionArgumentNode[] => {\n    const camelCaseOptions = options === '*' ? options : options.map(camelCase);\n    const shouldInline = (node: InstructionArgumentNode): boolean =>\n        options === '*' || camelCaseOptions.includes(camelCase(node.name));\n    const inlinedArguments = nodes.flatMap(node => {\n        if (isNode(node.type, 'structTypeNode') && shouldInline(node)) {\n            return node.type.fields.map(field => instructionArgumentNode({ ...field }));\n        }\n        return node;\n    });\n\n    const inlinedFieldsNames = inlinedArguments.map(arg => arg.name);\n    const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);\n    const uniqueDuplicates = [...new Set(duplicates)];\n    const hasConflictingNames = uniqueDuplicates.length > 0;\n\n    if (hasConflictingNames) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {\n            conflictingAttributes: uniqueDuplicates,\n        });\n    }\n\n    return hasConflictingNames ? nodes : inlinedArguments;\n};\n","import { assertIsNode, DefinedTypeNode, getAllPrograms, ProgramNode } from '@codama/nodes';\nimport {\n    deleteNodesVisitor,\n    getUniqueHashStringVisitor,\n    NodeSelector,\n    rootNodeVisitor,\n    visit,\n} from '@codama/visitors-core';\n\ntype DefinedTypeWithProgram = {\n    program: ProgramNode;\n    type: DefinedTypeNode;\n};\n\nexport function deduplicateIdenticalDefinedTypesVisitor() {\n    return rootNodeVisitor(root => {\n        const typeMap = new Map<string, DefinedTypeWithProgram[]>();\n\n        // Fill the type map with all defined types.\n        const allPrograms = getAllPrograms(root);\n        allPrograms.forEach(program => {\n            program.definedTypes.forEach(type => {\n                const typeWithProgram = { program, type };\n                const list = typeMap.get(type.name) ?? [];\n                typeMap.set(type.name, [...list, typeWithProgram]);\n            });\n        });\n\n        // Remove all types that are not duplicated.\n        typeMap.forEach((list, name) => {\n            if (list.length <= 1) {\n                typeMap.delete(name);\n            }\n        });\n\n        // Remove duplicates whose types are not equal.\n        const hashVisitor = getUniqueHashStringVisitor({ removeDocs: true });\n        typeMap.forEach((list, name) => {\n            const types = list.map(item => visit(item.type, hashVisitor));\n            const typesAreEqual = types.every((type, _, arr) => type === arr[0]);\n            if (!typesAreEqual) {\n                typeMap.delete(name);\n            }\n        });\n\n        // Get the selectors for all defined types that needs deleting.\n        // Thus, we must select all but the first duplicate of each list.\n        const deleteSelectors = Array.from(typeMap.values())\n            // Order lists by program index, get their tails and flatten.\n            .flatMap(list => {\n                const sortedList = list.sort((a, b) => allPrograms.indexOf(a.program) - allPrograms.indexOf(b.program));\n                const [, ...sortedListTail] = sortedList;\n                return sortedListTail;\n            })\n            // Get selectors from the defined types and their programs.\n            .map(({ program, type }): NodeSelector => `[programNode]${program.name}.[definedTypeNode]${type.name}`);\n\n        // Delete the identified nodes if any.\n        if (deleteSelectors.length > 0) {\n            const newRoot = visit(root, deleteNodesVisitor(deleteSelectors));\n            assertIsNode(newRoot, 'rootNode');\n            return newRoot;\n        }\n\n        return root;\n    });\n}\n","import { CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES, CodamaError } from '@codama/errors';\nimport {\n    accountValueNode,\n    argumentValueNode,\n    assertIsNode,\n    getAllInstructionArguments,\n    INSTRUCTION_INPUT_VALUE_NODES,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n    isNodeFilter,\n    PdaNode,\n    PdaSeedValueNode,\n    pdaSeedValueNode,\n    pdaValueNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    getLastNodeFromPath,\n    identityVisitor,\n    LinkableDictionary,\n    NodePath,\n    pipe,\n    Visitor,\n} from '@codama/visitors-core';\n\n/**\n * Fills in default values for variable PDA seeds that are not explicitly provided.\n * Namely, public key seeds are filled with an accountValueNode using the seed name\n * and other types of seeds are filled with an argumentValueNode using the seed name.\n *\n * An instruction and linkable dictionary are required to determine which seeds are\n * valids and to find the pdaLinkNode for the seed respectively. Any invalid default\n * seed won't be filled in.\n *\n * Strict mode goes one step further and will throw an error if the final array of\n * pdaSeedValueNodes contains invalid seeds or if there aren't enough variable seeds.\n */\nexport function fillDefaultPdaSeedValuesVisitor(\n    instructionPath: NodePath<InstructionNode>,\n    linkables: LinkableDictionary,\n    strictMode: boolean = false,\n) {\n    const instruction = getLastNodeFromPath(instructionPath);\n    return pipe(identityVisitor({ keys: INSTRUCTION_INPUT_VALUE_NODES }), v =>\n        extendVisitor(v, {\n            visitPdaValue(node, { next }) {\n                const visitedNode = next(node);\n                assertIsNode(visitedNode, 'pdaValueNode');\n                const foundPda = isNode(visitedNode.pda, 'pdaNode')\n                    ? visitedNode.pda\n                    : linkables.get([...instructionPath, visitedNode.pda]);\n                if (!foundPda) return visitedNode;\n                const seeds = addDefaultSeedValuesFromPdaWhenMissing(instruction, foundPda, visitedNode.seeds);\n                if (strictMode && !allSeedsAreValid(instruction, foundPda, seeds)) {\n                    throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES, {\n                        instruction,\n                        instructionName: instruction.name,\n                        pda: foundPda,\n                        pdaName: foundPda.name,\n                    });\n                }\n                return pdaValueNode(visitedNode.pda, seeds);\n            },\n        }),\n    ) as Visitor<InstructionInputValueNode, InstructionInputValueNode['kind']>;\n}\n\nfunction addDefaultSeedValuesFromPdaWhenMissing(\n    instruction: InstructionNode,\n    pda: PdaNode,\n    existingSeeds: PdaSeedValueNode[],\n): PdaSeedValueNode[] {\n    const existingSeedNames = new Set(existingSeeds.map(seed => seed.name));\n    const defaultSeeds = getDefaultSeedValuesFromPda(instruction, pda).filter(\n        seed => !existingSeedNames.has(seed.name),\n    );\n    return [...existingSeeds, ...defaultSeeds];\n}\n\nfunction getDefaultSeedValuesFromPda(instruction: InstructionNode, pda: PdaNode): PdaSeedValueNode[] {\n    return pda.seeds.flatMap((seed): PdaSeedValueNode[] => {\n        if (!isNode(seed, 'variablePdaSeedNode')) return [];\n\n        const hasMatchingAccount = instruction.accounts.some(a => a.name === seed.name);\n        if (isNode(seed.type, 'publicKeyTypeNode') && hasMatchingAccount) {\n            return [pdaSeedValueNode(seed.name, accountValueNode(seed.name))];\n        }\n\n        const hasMatchingArgument = getAllInstructionArguments(instruction).some(a => a.name === seed.name);\n        if (hasMatchingArgument) {\n            return [pdaSeedValueNode(seed.name, argumentValueNode(seed.name))];\n        }\n\n        return [];\n    });\n}\n\nfunction allSeedsAreValid(instruction: InstructionNode, foundPda: PdaNode, seeds: PdaSeedValueNode[]) {\n    const hasAllVariableSeeds = foundPda.seeds.filter(isNodeFilter('variablePdaSeedNode')).length === seeds.length;\n    const allAccountsName = instruction.accounts.map(a => a.name);\n    const allArgumentsName = getAllInstructionArguments(instruction).map(a => a.name);\n    const validSeeds = seeds.every(seed => {\n        if (isNode(seed.value, 'accountValueNode')) {\n            return allAccountsName.includes(seed.value.name);\n        }\n        if (isNode(seed.value, 'argumentValueNode')) {\n            return allArgumentsName.includes(seed.value.name);\n        }\n        return true;\n    });\n\n    return hasAllVariableSeeds && validSeeds;\n}\n","import { CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, CodamaError } from '@codama/errors';\nimport {\n    assertIsNode,\n    camelCase,\n    isNode,\n    Node,\n    StructFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type FlattenStructOptions = string[] | '*';\n\nexport function flattenStructVisitor(map: Record<string, FlattenStructOptions>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([stack, options]): BottomUpNodeTransformerWithSelector => ({\n                select: `${stack}.[structTypeNode]`,\n                transform: node => flattenStruct(node, options),\n            }),\n        ),\n    );\n}\n\nexport const flattenStruct = (node: Node, options: FlattenStructOptions = '*'): StructTypeNode => {\n    assertIsNode(node, 'structTypeNode');\n    const camelCaseOptions = options === '*' ? options : options.map(camelCase);\n    const shouldInline = (field: StructFieldTypeNode): boolean =>\n        options === '*' || camelCaseOptions.includes(camelCase(field.name));\n    const inlinedFields = node.fields.flatMap(field => {\n        if (isNode(field.type, 'structTypeNode') && shouldInline(field)) {\n            return field.type.fields;\n        }\n        return [field];\n    });\n\n    const inlinedFieldsNames = inlinedFields.map(arg => arg.name);\n    const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);\n    const uniqueDuplicates = [...new Set(duplicates)];\n    const hasConflictingNames = uniqueDuplicates.length > 0;\n\n    if (hasConflictingNames) {\n        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {\n            conflictingAttributes: uniqueDuplicates,\n        });\n    }\n\n    return hasConflictingNames ? node : structTypeNode(inlinedFields);\n};\n","import { CamelCaseString } from '@codama/nodes';\nimport {\n    extendVisitor,\n    findProgramNodeFromPath,\n    interceptVisitor,\n    mergeVisitor,\n    NodeStack,\n    pipe,\n    recordNodeStackVisitor,\n    visit,\n    Visitor,\n} from '@codama/visitors-core';\n\ntype DefinedTypeHistogramKey = CamelCaseString | `${CamelCaseString}.${CamelCaseString}`;\n\nexport type DefinedTypeHistogram = {\n    [key: DefinedTypeHistogramKey]: {\n        directlyAsInstructionArgs: number;\n        inAccounts: number;\n        inDefinedTypes: number;\n        inInstructionArgs: number;\n        total: number;\n    };\n};\n\nfunction mergeHistograms(histograms: DefinedTypeHistogram[]): DefinedTypeHistogram {\n    const result: DefinedTypeHistogram = {};\n\n    histograms.forEach(histogram => {\n        Object.keys(histogram).forEach(key => {\n            const mainCaseKey = key as CamelCaseString;\n            if (result[mainCaseKey] === undefined) {\n                result[mainCaseKey] = histogram[mainCaseKey];\n            } else {\n                result[mainCaseKey].total += histogram[mainCaseKey].total;\n                result[mainCaseKey].inAccounts += histogram[mainCaseKey].inAccounts;\n                result[mainCaseKey].inDefinedTypes += histogram[mainCaseKey].inDefinedTypes;\n                result[mainCaseKey].inInstructionArgs += histogram[mainCaseKey].inInstructionArgs;\n                result[mainCaseKey].directlyAsInstructionArgs += histogram[mainCaseKey].directlyAsInstructionArgs;\n            }\n        });\n    });\n\n    return result;\n}\n\nexport function getDefinedTypeHistogramVisitor(): Visitor<DefinedTypeHistogram> {\n    const stack = new NodeStack();\n    let mode: 'account' | 'definedType' | 'instruction' | null = null;\n    let stackLevel = 0;\n\n    return pipe(\n        mergeVisitor(\n            () => ({}) as DefinedTypeHistogram,\n            (_, histograms) => mergeHistograms(histograms),\n        ),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                stackLevel += 1;\n                const newNode = next(node);\n                stackLevel -= 1;\n                return newNode;\n            }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node, { self }) {\n                    mode = 'account';\n                    stackLevel = 0;\n                    const histogram = visit(node.data, self);\n                    mode = null;\n                    return histogram;\n                },\n\n                visitDefinedType(node, { self }) {\n                    mode = 'definedType';\n                    stackLevel = 0;\n                    const histogram = visit(node.type, self);\n                    mode = null;\n                    return histogram;\n                },\n\n                visitDefinedTypeLink(node) {\n                    const program = findProgramNodeFromPath(stack.getPath());\n                    const key = program ? `${program.name}.${node.name}` : node.name;\n                    return {\n                        [key]: {\n                            directlyAsInstructionArgs: Number(mode === 'instruction' && stackLevel <= 1),\n                            inAccounts: Number(mode === 'account'),\n                            inDefinedTypes: Number(mode === 'definedType'),\n                            inInstructionArgs: Number(mode === 'instruction'),\n                            total: 1,\n                        },\n                    };\n                },\n\n                visitInstruction(node, { self }) {\n                    mode = 'instruction';\n                    stackLevel = 0;\n                    const dataHistograms = node.arguments.map(arg => visit(arg, self));\n                    const extraHistograms = (node.extraArguments ?? []).map(arg => visit(arg, self));\n                    mode = null;\n                    const subHistograms = (node.subInstructions ?? []).map(ix => visit(ix, self));\n                    return mergeHistograms([...dataHistograms, ...extraHistograms, ...subHistograms]);\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND, CodamaError } from '@codama/errors';\nimport {\n    accountNode,\n    assertIsNode,\n    fieldDiscriminatorNode,\n    resolveNestedTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    transformNestedTypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport function setAccountDiscriminatorFromFieldVisitor(\n    map: Record<string, { field: string; offset?: number; value: ValueNode }>,\n) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, { field, value, offset }]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[accountNode]', selector],\n                transform: node => {\n                    assertIsNode(node, 'accountNode');\n\n                    const accountData = resolveNestedTypeNode(node.data);\n                    const fieldIndex = accountData.fields.findIndex(f => f.name === field);\n                    if (fieldIndex < 0) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND, {\n                            account: node,\n                            missingField: field,\n                            name: node.name,\n                        });\n                    }\n\n                    const fieldNode = accountData.fields[fieldIndex];\n                    return accountNode({\n                        ...node,\n                        data: transformNestedTypeNode(node.data, () =>\n                            structTypeNode([\n                                ...accountData.fields.slice(0, fieldIndex),\n                                structFieldTypeNode({\n                                    ...fieldNode,\n                                    defaultValue: value,\n                                    defaultValueStrategy: 'omitted',\n                                }),\n                                ...accountData.fields.slice(fieldIndex + 1),\n                            ]),\n                        ),\n                        discriminators: [fieldDiscriminatorNode(field, offset), ...(node.discriminators ?? [])],\n                    });\n                },\n            }),\n        ),\n    );\n}\n","import { accountNode, assertIsNode } from '@codama/nodes';\nimport {\n    getByteSizeVisitor,\n    getLastNodeFromPath,\n    isNodePath,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    topDownTransformerVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nexport function setFixedAccountSizesVisitor() {\n    const linkables = new LinkableDictionary();\n\n    const visitor = topDownTransformerVisitor(\n        [\n            {\n                select: path => isNodePath(path, 'accountNode') && getLastNodeFromPath(path).size === undefined,\n                transform: (node, stack) => {\n                    assertIsNode(node, 'accountNode');\n                    const size = visit(node.data, getByteSizeVisitor(linkables, { stack }));\n                    if (size === null) return node;\n                    return accountNode({ ...node, size }) as typeof node;\n                },\n            },\n        ],\n        { keys: ['rootNode', 'programNode', 'accountNode'] },\n    );\n\n    return pipe(visitor, v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import {\n    camelCase,\n    identityValueNode,\n    InstructionAccountNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    instructionNode,\n    payerValueNode,\n    programIdValueNode,\n    publicKeyValueNode,\n} from '@codama/nodes';\nimport {\n    extendVisitor,\n    LinkableDictionary,\n    NodeStack,\n    nonNullableIdentityVisitor,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { fillDefaultPdaSeedValuesVisitor } from './fillDefaultPdaSeedValuesVisitor';\n\nexport type InstructionAccountDefaultRule = {\n    /** The name of the instruction account or a pattern to match on it. */\n    account: RegExp | string;\n    /** The default value to assign to it. */\n    defaultValue: InstructionInputValueNode;\n    /** @defaultValue `false`. */\n    ignoreIfOptional?: boolean;\n    /** @defaultValue Defaults to searching accounts on all instructions. */\n    instruction?: string;\n};\n\nexport const getCommonInstructionAccountDefaultRules = (): InstructionAccountDefaultRule[] => [\n    {\n        account: /^(payer|feePayer)$/,\n        defaultValue: payerValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(authority)$/,\n        defaultValue: identityValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(programId)$/,\n        defaultValue: programIdValueNode(),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(systemProgram|splSystemProgram)$/,\n        defaultValue: publicKeyValueNode('11111111111111111111111111111111', 'splSystem'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenProgram|splTokenProgram)$/,\n        defaultValue: publicKeyValueNode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA', 'splToken'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(ataProgram|splAtaProgram)$/,\n        defaultValue: publicKeyValueNode('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL', 'splAssociatedToken'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenMetadataProgram|mplTokenMetadataProgram)$/,\n        defaultValue: publicKeyValueNode('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s', 'mplTokenMetadata'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(tokenAuth|mplTokenAuth|authorization|mplAuthorization|auth|mplAuth)RulesProgram$/,\n        defaultValue: publicKeyValueNode('auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg', 'mplTokenAuthRules'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(candyMachineProgram|mplCandyMachineProgram)$/,\n        defaultValue: publicKeyValueNode('CndyV3LdqHUfDLmE5naZjVN8rBZz4tqhdefbAnjHG3JR', 'mplCandyMachine'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(candyGuardProgram|mplCandyGuardProgram)$/,\n        defaultValue: publicKeyValueNode('Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g', 'mplCandyGuard'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(clockSysvar|sysvarClock)$/,\n        defaultValue: publicKeyValueNode('SysvarC1ock11111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(epochScheduleSysvar|sysvarEpochSchedule)$/,\n        defaultValue: publicKeyValueNode('SysvarEpochSchedu1e111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(instructions?Sysvar|sysvarInstructions?)(Account)?$/,\n        defaultValue: publicKeyValueNode('Sysvar1nstructions1111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(recentBlockhashesSysvar|sysvarRecentBlockhashes)$/,\n        defaultValue: publicKeyValueNode('SysvarRecentB1ockHashes11111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(rent|rentSysvar|sysvarRent)$/,\n        defaultValue: publicKeyValueNode('SysvarRent111111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(rewardsSysvar|sysvarRewards)$/,\n        defaultValue: publicKeyValueNode('SysvarRewards111111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(slotHashesSysvar|sysvarSlotHashes)$/,\n        defaultValue: publicKeyValueNode('SysvarS1otHashes111111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(slotHistorySysvar|sysvarSlotHistory)$/,\n        defaultValue: publicKeyValueNode('SysvarS1otHistory11111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(stakeHistorySysvar|sysvarStakeHistory)$/,\n        defaultValue: publicKeyValueNode('SysvarStakeHistory1111111111111111111111111'),\n        ignoreIfOptional: true,\n    },\n    {\n        account: /^(mplCoreProgram)$/,\n        defaultValue: publicKeyValueNode('CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d', 'mplCore'),\n        ignoreIfOptional: true,\n    },\n];\n\nexport function setInstructionAccountDefaultValuesVisitor(rules: InstructionAccountDefaultRule[]) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    // Place the rules with instructions first.\n    const sortedRules = rules.sort((a, b) => {\n        const ia = 'instruction' in a;\n        const ib = 'instruction' in b;\n        if ((ia && ib) || (!a && !ib)) return 0;\n        return ia ? -1 : 1;\n    });\n\n    function matchRule(\n        instruction: InstructionNode,\n        account: InstructionAccountNode,\n    ): InstructionAccountDefaultRule | undefined {\n        return sortedRules.find(rule => {\n            if ('instruction' in rule && rule.instruction && camelCase(rule.instruction) !== instruction.name) {\n                return false;\n            }\n            return typeof rule.account === 'string'\n                ? camelCase(rule.account) === account.name\n                : rule.account.test(account.name);\n        });\n    }\n\n    return pipe(\n        nonNullableIdentityVisitor({ keys: ['rootNode', 'programNode', 'instructionNode'] }),\n        v =>\n            extendVisitor(v, {\n                visitInstruction(node) {\n                    const instructionPath = stack.getPath('instructionNode');\n                    const instructionAccounts = node.accounts.map((account): InstructionAccountNode => {\n                        const rule = matchRule(node, account);\n                        if (!rule) return account;\n\n                        if ((rule.ignoreIfOptional ?? false) && (account.isOptional || !!account.defaultValue)) {\n                            return account;\n                        }\n\n                        try {\n                            return {\n                                ...account,\n                                defaultValue: visit(\n                                    rule.defaultValue,\n                                    fillDefaultPdaSeedValuesVisitor(instructionPath, linkables, true),\n                                ),\n                            };\n                        } catch {\n                            return account;\n                        }\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        accounts: instructionAccounts,\n                    });\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import {\n    assertIsNode,\n    fieldDiscriminatorNode,\n    instructionArgumentNode,\n    instructionNode,\n    numberTypeNode,\n    TypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\ntype Discriminator = {\n    /** @defaultValue `[]` */\n    docs?: string[];\n    /** @defaultValue `\"discriminator\"` */\n    name?: string;\n    /** @defaultValue `\"omitted\"` */\n    strategy?: 'omitted' | 'optional';\n    /** @defaultValue `numberTypeNode('u8')` */\n    type?: TypeNode;\n    value: ValueNode;\n};\n\nexport function setInstructionDiscriminatorsVisitor(map: Record<string, Discriminator>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selector, discriminator]): BottomUpNodeTransformerWithSelector => ({\n                select: ['[instructionNode]', selector],\n                transform: node => {\n                    assertIsNode(node, 'instructionNode');\n                    const discriminatorArgument = instructionArgumentNode({\n                        defaultValue: discriminator.value,\n                        defaultValueStrategy: discriminator.strategy ?? 'omitted',\n                        docs: discriminator.docs ?? [],\n                        name: discriminator.name ?? 'discriminator',\n                        type: discriminator.type ?? numberTypeNode('u8'),\n                    });\n\n                    return instructionNode({\n                        ...node,\n                        arguments: [discriminatorArgument, ...node.arguments],\n                        discriminators: [\n                            fieldDiscriminatorNode(discriminator.name ?? 'discriminator'),\n                            ...(node.discriminators ?? []),\n                        ],\n                    });\n                },\n            }),\n        ),\n    );\n}\n","import { CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER, CodamaError } from '@codama/errors';\nimport { amountTypeNode, assertIsNestedTypeNode, dateTimeTypeNode, solAmountTypeNode } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type NumberWrapper =\n    | { decimals: number; kind: 'Amount'; unit?: string }\n    | { kind: 'DateTime' }\n    | { kind: 'SolAmount' };\n\ntype NumberWrapperMap = Record<string, NumberWrapper>;\n\nexport function setNumberWrappersVisitor(map: NumberWrapperMap) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([selectorStack, wrapper]): BottomUpNodeTransformerWithSelector => ({\n                select: `${selectorStack}.[numberTypeNode]`,\n                transform: node => {\n                    assertIsNestedTypeNode(node, 'numberTypeNode');\n                    switch (wrapper.kind) {\n                        case 'DateTime':\n                            return dateTimeTypeNode(node);\n                        case 'SolAmount':\n                            return solAmountTypeNode(node);\n                        case 'Amount':\n                            return amountTypeNode(node, wrapper.decimals, wrapper.unit);\n                        default:\n                            throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER, { wrapper });\n                    }\n                },\n            }),\n        ),\n    );\n}\n","import {\n    assertIsNode,\n    camelCase,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    instructionNode,\n    StructFieldTypeNode,\n    structFieldTypeNode,\n    structTypeNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\ntype StructDefaultValueMap = Record<string, Record<string, StructDefaultValue>>;\ntype StructDefaultValue = ValueNode | { strategy?: 'omitted' | 'optional'; value: ValueNode } | null;\n\nexport function setStructDefaultValuesVisitor(map: StructDefaultValueMap) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([stack, defaultValues]): BottomUpNodeTransformerWithSelector[] => {\n            const camelCasedDefaultValues = Object.fromEntries(\n                Object.entries(defaultValues).map(([key, value]) => [camelCase(key), value]),\n            );\n\n            return [\n                {\n                    select: `${stack}.[structTypeNode]`,\n                    transform: node => {\n                        assertIsNode(node, 'structTypeNode');\n                        const fields = node.fields.map((field): StructFieldTypeNode => {\n                            const defaultValue = camelCasedDefaultValues[field.name];\n                            if (defaultValue === undefined) return field;\n                            if (defaultValue === null) {\n                                return structFieldTypeNode({\n                                    ...field,\n                                    defaultValue: undefined,\n                                    defaultValueStrategy: undefined,\n                                });\n                            }\n                            return structFieldTypeNode({\n                                ...field,\n                                defaultValue: 'kind' in defaultValue ? defaultValue : defaultValue.value,\n                                defaultValueStrategy: 'kind' in defaultValue ? undefined : defaultValue.strategy,\n                            });\n                        });\n                        return structTypeNode(fields);\n                    },\n                },\n                {\n                    select: ['[instructionNode]', stack],\n                    transform: node => {\n                        assertIsNode(node, 'instructionNode');\n                        const transformArguments = (arg: InstructionArgumentNode): InstructionArgumentNode => {\n                            const defaultValue = camelCasedDefaultValues[arg.name];\n                            if (defaultValue === undefined) return arg;\n                            if (defaultValue === null) {\n                                return instructionArgumentNode({\n                                    ...arg,\n                                    defaultValue: undefined,\n                                    defaultValueStrategy: undefined,\n                                });\n                            }\n                            return instructionArgumentNode({\n                                ...arg,\n                                defaultValue: 'kind' in defaultValue ? defaultValue : defaultValue.value,\n                                defaultValueStrategy: 'kind' in defaultValue ? undefined : defaultValue.strategy,\n                            });\n                        };\n                        return instructionNode({\n                            ...node,\n                            arguments: node.arguments.map(transformArguments),\n                            extraArguments: node.extraArguments\n                                ? node.extraArguments.map(transformArguments)\n                                : undefined,\n                        });\n                    },\n                },\n            ];\n        }),\n    );\n}\n","import { accountNode, assertIsNode, programNode } from '@codama/nodes';\nimport { extendVisitor, nonNullableIdentityVisitor, pipe } from '@codama/visitors-core';\n\nexport function transformDefinedTypesIntoAccountsVisitor(definedTypes: string[]) {\n    return pipe(nonNullableIdentityVisitor({ keys: ['rootNode', 'programNode'] }), v =>\n        extendVisitor(v, {\n            visitProgram(program) {\n                const typesToExtract = program.definedTypes.filter(node => definedTypes.includes(node.name));\n\n                const newDefinedTypes = program.definedTypes.filter(node => !definedTypes.includes(node.name));\n\n                const newAccounts = typesToExtract.map(node => {\n                    assertIsNode(node.type, 'structTypeNode');\n                    return accountNode({\n                        ...node,\n                        data: node.type,\n                        discriminators: [],\n                        size: undefined,\n                    });\n                });\n\n                return programNode({\n                    ...program,\n                    accounts: [...program.accounts, ...newAccounts],\n                    definedTypes: newDefinedTypes,\n                });\n            },\n        }),\n    );\n}\n","import {\n    ArrayTypeNode,\n    arrayTypeNode,\n    assertIsNode,\n    bytesTypeNode,\n    fixedSizeTypeNode,\n    isNode,\n    TYPE_NODES,\n} from '@codama/nodes';\nimport { extendVisitor, nonNullableIdentityVisitor, pipe, visit } from '@codama/visitors-core';\n\nexport function transformU8ArraysToBytesVisitor(sizes: number[] | '*' = '*') {\n    const hasRequiredSize = (count: ArrayTypeNode['count']): boolean => {\n        if (!isNode(count, 'fixedCountNode')) return false;\n        return sizes === '*' || sizes.includes(count.value);\n    };\n\n    return pipe(nonNullableIdentityVisitor(), v =>\n        extendVisitor(v, {\n            visitArrayType(node, { self }) {\n                const child = visit(node.item, self);\n                assertIsNode(child, TYPE_NODES);\n\n                if (\n                    isNode(child, 'numberTypeNode') &&\n                    child.format === 'u8' &&\n                    isNode(node.count, 'fixedCountNode') &&\n                    hasRequiredSize(node.count)\n                ) {\n                    return fixedSizeTypeNode(bytesTypeNode(), node.count.value);\n                }\n\n                return arrayTypeNode(child, node.count);\n            },\n        }),\n    );\n}\n","import { assertIsNodeFilter, camelCase, CamelCaseString, programNode } from '@codama/nodes';\nimport {\n    extendVisitor,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    LinkableDictionary,\n    NodeStack,\n    nonNullableIdentityVisitor,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nexport function unwrapDefinedTypesVisitor(typesToInline: string[] | '*' = '*') {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n    const typesToInlineCamelCased = (typesToInline === '*' ? [] : typesToInline).map(fullPath => {\n        if (!fullPath.includes('.')) return camelCase(fullPath);\n        const [programName, typeName] = fullPath.split('.');\n        return `${camelCase(programName)}.${camelCase(typeName)}`;\n    });\n    const shouldInline = (typeName: CamelCaseString, programName: CamelCaseString | undefined): boolean => {\n        if (typesToInline === '*') return true;\n        const fullPath = `${programName}.${typeName}`;\n        if (!!programName && typesToInlineCamelCased.includes(fullPath)) return true;\n        return typesToInlineCamelCased.includes(typeName);\n    };\n\n    return pipe(\n        nonNullableIdentityVisitor(),\n        v =>\n            extendVisitor(v, {\n                visitDefinedTypeLink(linkType, { self }) {\n                    const programName = linkType.program?.name ?? findProgramNodeFromPath(stack.getPath())?.name;\n                    if (!shouldInline(linkType.name, programName)) {\n                        return linkType;\n                    }\n                    const definedTypePath = linkables.getPathOrThrow(stack.getPath('definedTypeLinkNode'));\n                    const definedType = getLastNodeFromPath(definedTypePath);\n\n                    stack.pushPath(definedTypePath);\n                    const result = visit(definedType.type, self);\n                    stack.popPath();\n                    return result;\n                },\n\n                visitProgram(program, { self }) {\n                    return programNode({\n                        ...program,\n                        accounts: program.accounts\n                            .map(account => visit(account, self))\n                            .filter(assertIsNodeFilter('accountNode')),\n                        definedTypes: program.definedTypes\n                            .filter(definedType => !shouldInline(definedType.name, program.name))\n                            .map(type => visit(type, self))\n                            .filter(assertIsNodeFilter('definedTypeNode')),\n                        instructions: program.instructions\n                            .map(instruction => visit(instruction, self))\n                            .filter(assertIsNodeFilter('instructionNode')),\n                    });\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n","import { assertIsNode, CamelCaseString, definedTypeLinkNode, isNode } from '@codama/nodes';\nimport { getRecordLinkablesVisitor, LinkableDictionary, rootNodeVisitor, visit } from '@codama/visitors-core';\n\nimport { getDefinedTypeHistogramVisitor } from './getDefinedTypeHistogramVisitor';\nimport { unwrapDefinedTypesVisitor } from './unwrapDefinedTypesVisitor';\n\nexport function unwrapInstructionArgsDefinedTypesVisitor() {\n    return rootNodeVisitor(root => {\n        const histogram = visit(root, getDefinedTypeHistogramVisitor());\n        const linkables = new LinkableDictionary();\n        visit(root, getRecordLinkablesVisitor(linkables));\n\n        const definedTypesToInline = (Object.keys(histogram) as CamelCaseString[])\n            // Get all defined types used exactly once as an instruction argument.\n            .filter(key => (histogram[key].total ?? 0) === 1 && (histogram[key].directlyAsInstructionArgs ?? 0) === 1)\n            // Filter out enums which are better defined as external types.\n            .filter(key => {\n                const names = key.split('.');\n                const link = names.length == 2 ? definedTypeLinkNode(names[1], names[0]) : definedTypeLinkNode(key);\n                const found = linkables.get([link]);\n                return found && !isNode(found.type, 'enumTypeNode');\n            });\n\n        // Inline the identified defined types if any.\n        if (definedTypesToInline.length > 0) {\n            const inlineVisitor = unwrapDefinedTypesVisitor(definedTypesToInline);\n            const newRoot = visit(root, inlineVisitor);\n            assertIsNode(newRoot, 'rootNode');\n            return newRoot;\n        }\n\n        return root;\n    });\n}\n","import {\n    assertIsNode,\n    CamelCaseString,\n    DefinedTypeNode,\n    enumStructVariantTypeNode,\n    getAllDefinedTypes,\n    isNode,\n    resolveNestedTypeNode,\n    StructTypeNode,\n    transformNestedTypeNode,\n} from '@codama/nodes';\nimport {\n    bottomUpTransformerVisitor,\n    getNodeSelectorFunction,\n    NodeSelectorFunction,\n    NodeStack,\n    rootNodeVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { getDefinedTypeHistogramVisitor } from './getDefinedTypeHistogramVisitor';\nimport { unwrapDefinedTypesVisitor } from './unwrapDefinedTypesVisitor';\n\nexport function unwrapTupleEnumWithSingleStructVisitor(enumsOrVariantsToUnwrap: string[] | '*' = '*') {\n    const selectorFunctions: NodeSelectorFunction[] =\n        enumsOrVariantsToUnwrap === '*'\n            ? [() => true]\n            : enumsOrVariantsToUnwrap.map(selector => getNodeSelectorFunction(selector));\n\n    const shouldUnwrap = (stack: NodeStack): boolean => selectorFunctions.some(selector => selector(stack.getPath()));\n\n    return rootNodeVisitor(root => {\n        const typesToPotentiallyUnwrap: string[] = [];\n        const definedTypes: Map<string, DefinedTypeNode> = new Map(\n            getAllDefinedTypes(root).map(definedType => [definedType.name, definedType]),\n        );\n\n        let newRoot = visit(\n            root,\n            bottomUpTransformerVisitor([\n                {\n                    select: '[enumTupleVariantTypeNode]',\n                    transform: (node, stack) => {\n                        assertIsNode(node, 'enumTupleVariantTypeNode');\n                        if (!shouldUnwrap(stack)) return node;\n                        const tupleNode = resolveNestedTypeNode(node.tuple);\n                        if (tupleNode.items.length !== 1) return node;\n                        let item = tupleNode.items[0];\n                        if (isNode(item, 'definedTypeLinkNode')) {\n                            const definedType = definedTypes.get(item.name);\n                            if (!definedType) return node;\n                            if (!isNode(definedType.type, 'structTypeNode')) return node;\n                            typesToPotentiallyUnwrap.push(item.name);\n                            item = definedType.type;\n                        }\n                        if (!isNode(item, 'structTypeNode')) return node;\n                        const nestedStruct = transformNestedTypeNode(node.tuple, () => item as StructTypeNode);\n                        return enumStructVariantTypeNode(node.name, nestedStruct);\n                    },\n                },\n            ]),\n        );\n        assertIsNode(newRoot, 'rootNode');\n\n        const histogram = visit(newRoot, getDefinedTypeHistogramVisitor());\n        const typesToUnwrap = typesToPotentiallyUnwrap.filter(\n            type => !histogram[type as CamelCaseString] || histogram[type as CamelCaseString].total === 0,\n        );\n\n        newRoot = visit(newRoot, unwrapDefinedTypesVisitor(typesToUnwrap));\n        assertIsNode(newRoot, 'rootNode');\n\n        return newRoot;\n    });\n}\n","import {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n} from '@codama/visitors-core';\n\nexport function unwrapTypeDefinedLinksVisitor(definedLinksType: string[]) {\n    const linkables = new LinkableDictionary();\n\n    const transformers: BottomUpNodeTransformerWithSelector[] = definedLinksType.map(selector => ({\n        select: ['[definedTypeLinkNode]', selector],\n        transform: (_, stack) => {\n            const definedType = linkables.getOrThrow(stack.getPath('definedTypeLinkNode'));\n            return definedType.type;\n        },\n    }));\n\n    return pipe(bottomUpTransformerVisitor(transformers), v => recordLinkablesOnFirstVisitVisitor(v, linkables));\n}\n","import {\n    accountLinkNode,\n    accountNode,\n    AccountNodeInput,\n    assertIsNode,\n    camelCase,\n    CamelCaseString,\n    pdaLinkNode,\n    PdaNode,\n    pdaNode,\n    PdaSeedNode,\n    programNode,\n    transformNestedTypeNode,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    findProgramNodeFromPath,\n} from '@codama/visitors-core';\n\nimport { renameStructNode } from './renameHelpers';\n\nexport type AccountUpdates =\n    | { delete: true }\n    | (Partial<Omit<AccountNodeInput, 'data'>> & {\n          data?: Record<string, string>;\n          seeds?: PdaSeedNode[];\n      });\n\nexport function updateAccountsVisitor(map: Record<string, AccountUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([selector, updates]) => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n            const pdasToUpsert = [] as { pda: PdaNode; program: CamelCaseString }[];\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: ['[accountNode]', selector],\n                    transform: (node, stack) => {\n                        assertIsNode(node, 'accountNode');\n                        if ('delete' in updates) return null;\n\n                        const programNode = findProgramNodeFromPath(stack.getPath())!;\n                        const { seeds, pda, ...assignableUpdates } = updates;\n                        let newPda = node.pda;\n                        if (pda && seeds !== undefined) {\n                            newPda = pda;\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: pda.name, seeds }),\n                                program: programNode.name,\n                            });\n                        } else if (pda) {\n                            newPda = pda;\n                        } else if (seeds !== undefined && node.pda) {\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: node.pda.name, seeds }),\n                                program: programNode.name,\n                            });\n                        } else if (seeds !== undefined) {\n                            newPda = pdaLinkNode(newName ?? node.name);\n                            pdasToUpsert.push({\n                                pda: pdaNode({ name: newName ?? node.name, seeds }),\n                                program: programNode.name,\n                            });\n                        }\n\n                        return accountNode({\n                            ...node,\n                            ...assignableUpdates,\n                            data: transformNestedTypeNode(node.data, struct =>\n                                renameStructNode(struct, updates.data ?? {}),\n                            ),\n                            pda: newPda,\n                        });\n                    },\n                },\n                {\n                    select: `[programNode]`,\n                    transform: node => {\n                        assertIsNode(node, 'programNode');\n                        const pdasToUpsertForProgram = pdasToUpsert\n                            .filter(p => p.program === node.name)\n                            .map(p => p.pda);\n                        if (pdasToUpsertForProgram.length === 0) return node;\n                        const existingPdaNames = new Set(node.pdas.map(pda => pda.name));\n                        const pdasToCreate = pdasToUpsertForProgram.filter(p => !existingPdaNames.has(p.name));\n                        const pdasToUpdate = new Map(\n                            pdasToUpsertForProgram.filter(p => existingPdaNames.has(p.name)).map(p => [p.name, p]),\n                        );\n                        const newPdas = [...node.pdas.map(p => pdasToUpdate.get(p.name) ?? p), ...pdasToCreate];\n                        return programNode({ ...node, pdas: newPdas });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push(\n                    {\n                        select: ['[accountLinkNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'accountLinkNode');\n                            return accountLinkNode(newName);\n                        },\n                    },\n                    {\n                        select: ['[pdaNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'pdaNode');\n                            return pdaNode({ name: newName, seeds: node.seeds });\n                        },\n                    },\n                    {\n                        select: ['[pdaLinkNode]', selector],\n                        transform: node => {\n                            assertIsNode(node, 'pdaLinkNode');\n                            return pdaLinkNode(newName);\n                        },\n                    },\n                );\n            }\n\n            return transformers;\n        }),\n    );\n}\n","import {\n    enumEmptyVariantTypeNode,\n    enumStructVariantTypeNode,\n    enumTupleVariantTypeNode,\n    EnumTypeNode,\n    enumTypeNode,\n    EnumVariantTypeNode,\n    isNode,\n    structFieldTypeNode,\n    StructTypeNode,\n    structTypeNode,\n} from '@codama/nodes';\n\nexport function renameStructNode(node: StructTypeNode, map: Record<string, string>): StructTypeNode {\n    return structTypeNode(\n        node.fields.map(field => (map[field.name] ? structFieldTypeNode({ ...field, name: map[field.name] }) : field)),\n    );\n}\n\nexport function renameEnumNode(node: EnumTypeNode, map: Record<string, string>): EnumTypeNode {\n    return enumTypeNode(\n        node.variants.map(variant => (map[variant.name] ? renameEnumVariant(variant, map[variant.name]) : variant)),\n        { ...node },\n    );\n}\n\nfunction renameEnumVariant(variant: EnumVariantTypeNode, newName: string) {\n    if (isNode(variant, 'enumStructVariantTypeNode')) {\n        return enumStructVariantTypeNode(newName, variant.struct);\n    }\n    if (isNode(variant, 'enumTupleVariantTypeNode')) {\n        return enumTupleVariantTypeNode(newName, variant.tuple);\n    }\n    return enumEmptyVariantTypeNode(newName);\n}\n","import {\n    assertIsNode,\n    camelCase,\n    definedTypeLinkNode,\n    definedTypeNode,\n    DefinedTypeNodeInput,\n    isNode,\n} from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nimport { renameEnumNode, renameStructNode } from './renameHelpers';\n\nexport type DefinedTypeUpdates =\n    | { delete: true }\n    | (Partial<Omit<DefinedTypeNodeInput, 'data'>> & {\n          data?: Record<string, string>;\n      });\n\nexport function updateDefinedTypesVisitor(map: Record<string, DefinedTypeUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([selector, updates]): BottomUpNodeTransformerWithSelector[] => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: ['[definedTypeNode]', selector],\n                    transform: node => {\n                        assertIsNode(node, 'definedTypeNode');\n                        if ('delete' in updates) {\n                            return null;\n                        }\n                        const { data: dataUpdates, ...otherUpdates } = updates;\n                        let newType = node.type;\n                        if (isNode(node.type, 'structTypeNode')) {\n                            newType = renameStructNode(node.type, dataUpdates ?? {});\n                        } else if (isNode(node.type, 'enumTypeNode')) {\n                            newType = renameEnumNode(node.type, dataUpdates ?? {});\n                        }\n                        return definedTypeNode({\n                            ...node,\n                            ...otherUpdates,\n                            name: newName ?? node.name,\n                            type: newType,\n                        });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push({\n                    select: ['[definedTypeLinkNode]', selector],\n                    transform: node => {\n                        assertIsNode(node, 'definedTypeLinkNode');\n                        return definedTypeLinkNode(newName);\n                    },\n                });\n            }\n\n            return transformers;\n        }),\n    );\n}\n","import { assertIsNode, errorNode, ErrorNodeInput } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type ErrorUpdates = Partial<ErrorNodeInput> | { delete: true };\n\nexport function updateErrorsVisitor(map: Record<string, ErrorUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).map(\n            ([name, updates]): BottomUpNodeTransformerWithSelector => ({\n                select: `[errorNode]${name}`,\n                transform: node => {\n                    assertIsNode(node, 'errorNode');\n                    if ('delete' in updates) return null;\n                    return errorNode({ ...node, ...updates });\n                },\n            }),\n        ),\n    );\n}\n","import {\n    assertIsNode,\n    InstructionAccountNode,\n    instructionAccountNode,\n    InstructionAccountNodeInput,\n    InstructionArgumentNode,\n    instructionArgumentNode,\n    InstructionArgumentNodeInput,\n    InstructionInputValueNode,\n    InstructionNode,\n    instructionNode,\n    InstructionNodeInput,\n    TYPE_NODES,\n} from '@codama/nodes';\nimport {\n    BottomUpNodeTransformerWithSelector,\n    bottomUpTransformerVisitor,\n    LinkableDictionary,\n    NodePath,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { fillDefaultPdaSeedValuesVisitor } from './fillDefaultPdaSeedValuesVisitor';\n\nexport type InstructionUpdates =\n    | { delete: true }\n    | (InstructionMetadataUpdates & {\n          accounts?: InstructionAccountUpdates;\n          arguments?: InstructionArgumentUpdates;\n      });\n\nexport type InstructionMetadataUpdates = Partial<\n    Omit<\n        InstructionNodeInput,\n        | 'accounts'\n        | 'arguments'\n        | 'byteDeltas'\n        | 'discriminators'\n        | 'extraArguments'\n        | 'remainingAccounts'\n        | 'subInstructions'\n    >\n>;\n\nexport type InstructionAccountUpdates = Record<\n    string,\n    Partial<Omit<InstructionAccountNodeInput, 'defaultValue'>> & {\n        defaultValue?: InstructionInputValueNode | null;\n    }\n>;\n\nexport type InstructionArgumentUpdates = Record<\n    string,\n    Partial<Omit<InstructionArgumentNodeInput, 'defaultValue'>> & {\n        defaultValue?: InstructionInputValueNode | null;\n    }\n>;\n\nexport function updateInstructionsVisitor(map: Record<string, InstructionUpdates>) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n\n    const transformers = Object.entries(map).map(\n        ([selector, updates]): BottomUpNodeTransformerWithSelector => ({\n            select: ['[instructionNode]', selector],\n            transform: node => {\n                assertIsNode(node, 'instructionNode');\n                if ('delete' in updates) {\n                    return null;\n                }\n\n                const instructionPath = stack.getPath('instructionNode');\n                const { accounts: accountUpdates, arguments: argumentUpdates, ...metadataUpdates } = updates;\n                const { newArguments, newExtraArguments } = handleInstructionArguments(node, argumentUpdates ?? {});\n                const newAccounts = node.accounts.map(account =>\n                    handleInstructionAccount(instructionPath, account, accountUpdates ?? {}, linkables),\n                );\n                return instructionNode({\n                    ...node,\n                    ...metadataUpdates,\n                    accounts: newAccounts,\n                    arguments: newArguments,\n                    extraArguments: newExtraArguments.length > 0 ? newExtraArguments : undefined,\n                });\n            },\n        }),\n    );\n\n    return pipe(\n        bottomUpTransformerVisitor(transformers),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n\nfunction handleInstructionAccount(\n    instructionPath: NodePath<InstructionNode>,\n    account: InstructionAccountNode,\n    accountUpdates: InstructionAccountUpdates,\n    linkables: LinkableDictionary,\n): InstructionAccountNode {\n    const accountUpdate = accountUpdates?.[account.name];\n    if (!accountUpdate) return account;\n    const { defaultValue, ...acountWithoutDefault } = {\n        ...account,\n        ...accountUpdate,\n    };\n\n    if (!defaultValue) {\n        return instructionAccountNode(acountWithoutDefault);\n    }\n\n    return instructionAccountNode({\n        ...acountWithoutDefault,\n        defaultValue: visit(defaultValue, fillDefaultPdaSeedValuesVisitor(instructionPath, linkables)),\n    });\n}\n\nfunction handleInstructionArguments(\n    instruction: InstructionNode,\n    argUpdates: InstructionArgumentUpdates,\n): {\n    newArguments: InstructionArgumentNode[];\n    newExtraArguments: InstructionArgumentNode[];\n} {\n    const usedArguments = new Set<string>();\n\n    const newArguments = instruction.arguments.map(node => {\n        const argUpdate = argUpdates[node.name];\n        if (!argUpdate) return node;\n        usedArguments.add(node.name);\n        return instructionArgumentNode({\n            ...node,\n            defaultValue: argUpdate.defaultValue ?? node.defaultValue,\n            defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,\n            docs: argUpdate.docs ?? node.docs,\n            name: argUpdate.name ?? node.name,\n            type: argUpdate.type ?? node.type,\n        });\n    });\n\n    const updatedExtraArguments = (instruction.extraArguments ?? []).map(node => {\n        if (usedArguments.has(node.name)) return node;\n        const argUpdate = argUpdates[node.name];\n        if (!argUpdate) return node;\n        usedArguments.add(node.name);\n        return instructionArgumentNode({\n            ...node,\n            defaultValue: argUpdate.defaultValue ?? node.defaultValue,\n            defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,\n            docs: argUpdate.docs ?? node.docs,\n            name: argUpdate.name ?? node.name,\n            type: argUpdate.type ?? node.type,\n        });\n    });\n\n    const newExtraArguments = [\n        ...updatedExtraArguments,\n        ...Object.entries(argUpdates)\n            .filter(([argName]) => !usedArguments.has(argName))\n            .map(([argName, argUpdate]) => {\n                const { type } = argUpdate;\n                assertIsNode(type, TYPE_NODES);\n                return instructionArgumentNode({\n                    defaultValue: argUpdate.defaultValue ?? undefined,\n                    defaultValueStrategy: argUpdate.defaultValueStrategy ?? undefined,\n                    docs: argUpdate.docs ?? [],\n                    name: argUpdate.name ?? argName,\n                    type,\n                });\n            }),\n    ];\n\n    return { newArguments, newExtraArguments };\n}\n","import { assertIsNode, camelCase, programLinkNode, programNode, ProgramNodeInput } from '@codama/nodes';\nimport { BottomUpNodeTransformerWithSelector, bottomUpTransformerVisitor } from '@codama/visitors-core';\n\nexport type ProgramUpdates =\n    | Partial<Omit<ProgramNodeInput, 'accounts' | 'definedTypes' | 'errors' | 'instructions'>>\n    | { delete: true };\n\nexport function updateProgramsVisitor(map: Record<string, ProgramUpdates>) {\n    return bottomUpTransformerVisitor(\n        Object.entries(map).flatMap(([name, updates]): BottomUpNodeTransformerWithSelector[] => {\n            const newName =\n                typeof updates === 'object' && 'name' in updates && updates.name ? camelCase(updates.name) : undefined;\n\n            const transformers: BottomUpNodeTransformerWithSelector[] = [\n                {\n                    select: `[programNode]${name}`,\n                    transform: node => {\n                        assertIsNode(node, 'programNode');\n                        if ('delete' in updates) return null;\n                        return programNode({ ...node, ...updates });\n                    },\n                },\n            ];\n\n            if (newName) {\n                transformers.push({\n                    select: `[programLinkNode]${name}`,\n                    transform: node => {\n                        assertIsNode(node, 'programLinkNode');\n                        return programLinkNode(newName);\n                    },\n                });\n            }\n\n            return transformers;\n        }),\n    );\n}\n"],"mappings":"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","names":["import_errors","import_nodes","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_errors","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_visitors_core","import_nodes","import_visitors_core","import_nodes","programNode","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core","import_nodes","import_visitors_core"]}