"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  addPdasVisitor: () => addPdasVisitor,
  createSubInstructionsFromEnumArgsVisitor: () => createSubInstructionsFromEnumArgsVisitor,
  deduplicateIdenticalDefinedTypesVisitor: () => deduplicateIdenticalDefinedTypesVisitor,
  fillDefaultPdaSeedValuesVisitor: () => fillDefaultPdaSeedValuesVisitor,
  flattenInstructionArguments: () => flattenInstructionArguments,
  flattenInstructionDataArgumentsVisitor: () => flattenInstructionDataArgumentsVisitor,
  flattenStruct: () => flattenStruct,
  flattenStructVisitor: () => flattenStructVisitor,
  getCommonInstructionAccountDefaultRules: () => getCommonInstructionAccountDefaultRules,
  getDefinedTypeHistogramVisitor: () => getDefinedTypeHistogramVisitor,
  setAccountDiscriminatorFromFieldVisitor: () => setAccountDiscriminatorFromFieldVisitor,
  setFixedAccountSizesVisitor: () => setFixedAccountSizesVisitor,
  setInstructionAccountDefaultValuesVisitor: () => setInstructionAccountDefaultValuesVisitor,
  setInstructionDiscriminatorsVisitor: () => setInstructionDiscriminatorsVisitor,
  setNumberWrappersVisitor: () => setNumberWrappersVisitor,
  setStructDefaultValuesVisitor: () => setStructDefaultValuesVisitor,
  transformDefinedTypesIntoAccountsVisitor: () => transformDefinedTypesIntoAccountsVisitor,
  transformU8ArraysToBytesVisitor: () => transformU8ArraysToBytesVisitor,
  unwrapDefinedTypesVisitor: () => unwrapDefinedTypesVisitor,
  unwrapInstructionArgsDefinedTypesVisitor: () => unwrapInstructionArgsDefinedTypesVisitor,
  unwrapTupleEnumWithSingleStructVisitor: () => unwrapTupleEnumWithSingleStructVisitor,
  unwrapTypeDefinedLinksVisitor: () => unwrapTypeDefinedLinksVisitor,
  updateAccountsVisitor: () => updateAccountsVisitor,
  updateDefinedTypesVisitor: () => updateDefinedTypesVisitor,
  updateErrorsVisitor: () => updateErrorsVisitor,
  updateInstructionsVisitor: () => updateInstructionsVisitor,
  updateProgramsVisitor: () => updateProgramsVisitor
});
module.exports = __toCommonJS(index_exports);
__reExport(index_exports, require("@codama/visitors-core"), module.exports);

// src/addPdasVisitor.ts
var import_errors = require("@codama/errors");
var import_nodes = require("@codama/nodes");
var import_visitors_core = require("@codama/visitors-core");
function addPdasVisitor(pdas) {
  return (0, import_visitors_core.bottomUpTransformerVisitor)(
    Object.entries(pdas).map(([uncasedProgramName, newPdas]) => {
      const programName = (0, import_nodes.camelCase)(uncasedProgramName);
      return {
        select: `[programNode]${programName}`,
        transform: (node) => {
          (0, import_nodes.assertIsNode)(node, "programNode");
          const existingPdaNames = new Set(node.pdas.map((pda) => pda.name));
          const newPdaNames = new Set(newPdas.map((pda) => pda.name));
          const overlappingPdaNames = new Set([...existingPdaNames].filter((name) => newPdaNames.has(name)));
          if (overlappingPdaNames.size > 0) {
            throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__VISITORS__CANNOT_ADD_DUPLICATED_PDA_NAMES, {
              duplicatedPdaNames: [...overlappingPdaNames],
              program: node,
              programName: node.name
            });
          }
          return (0, import_nodes.programNode)({
            ...node,
            pdas: [...node.pdas, ...newPdas.map((pda) => (0, import_nodes.pdaNode)({ name: pda.name, seeds: pda.seeds }))]
          });
        }
      };
    })
  );
}

// src/createSubInstructionsFromEnumArgsVisitor.ts
var import_errors3 = require("@codama/errors");
var import_nodes3 = require("@codama/nodes");
var import_visitors_core3 = require("@codama/visitors-core");

// src/flattenInstructionDataArgumentsVisitor.ts
var import_errors2 = require("@codama/errors");
var import_nodes2 = require("@codama/nodes");
var import_visitors_core2 = require("@codama/visitors-core");
function flattenInstructionDataArgumentsVisitor() {
  return (0, import_visitors_core2.bottomUpTransformerVisitor)([
    {
      select: "[instructionNode]",
      transform: (instruction) => {
        (0, import_nodes2.assertIsNode)(instruction, "instructionNode");
        return (0, import_nodes2.instructionNode)({
          ...instruction,
          arguments: flattenInstructionArguments(instruction.arguments)
        });
      }
    }
  ]);
}
var flattenInstructionArguments = (nodes, options = "*") => {
  const camelCaseOptions = options === "*" ? options : options.map(import_nodes2.camelCase);
  const shouldInline = (node) => options === "*" || camelCaseOptions.includes((0, import_nodes2.camelCase)(node.name));
  const inlinedArguments = nodes.flatMap((node) => {
    if ((0, import_nodes2.isNode)(node.type, "structTypeNode") && shouldInline(node)) {
      return node.type.fields.map((field) => (0, import_nodes2.instructionArgumentNode)({ ...field }));
    }
    return node;
  });
  const inlinedFieldsNames = inlinedArguments.map((arg) => arg.name);
  const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);
  const uniqueDuplicates = [...new Set(duplicates)];
  const hasConflictingNames = uniqueDuplicates.length > 0;
  if (hasConflictingNames) {
    throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {
      conflictingAttributes: uniqueDuplicates
    });
  }
  return hasConflictingNames ? nodes : inlinedArguments;
};

// src/createSubInstructionsFromEnumArgsVisitor.ts
function createSubInstructionsFromEnumArgsVisitor(map) {
  const linkables = new import_visitors_core3.LinkableDictionary();
  const visitor = (0, import_visitors_core3.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([selector, argNameInput]) => ({
        select: ["[instructionNode]", selector],
        transform: (node, stack) => {
          (0, import_nodes3.assertIsNode)(node, "instructionNode");
          const argFields = node.arguments;
          const argName = (0, import_nodes3.camelCase)(argNameInput);
          const argFieldIndex = argFields.findIndex((field) => field.name === argName);
          const argField = argFieldIndex >= 0 ? argFields[argFieldIndex] : null;
          if (!argField) {
            throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {
              argumentName: argName,
              instruction: node,
              instructionName: node.name
            });
          }
          let argType;
          if ((0, import_nodes3.isNode)(argField.type, "enumTypeNode")) {
            argType = argField.type;
          } else if ((0, import_nodes3.isNode)(argField.type, "definedTypeLinkNode") && linkables.has([...stack.getPath(), argField.type])) {
            const linkedType = linkables.get([...stack.getPath(), argField.type])?.type;
            (0, import_nodes3.assertIsNode)(linkedType, "enumTypeNode");
            argType = linkedType;
          } else {
            throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__VISITORS__INSTRUCTION_ENUM_ARGUMENT_NOT_FOUND, {
              argumentName: argName,
              instruction: node,
              instructionName: node.name
            });
          }
          const subInstructions = argType.variants.map((variant, index) => {
            const subName = (0, import_nodes3.camelCase)(`${node.name} ${variant.name}`);
            const subFields = argFields.slice(0, argFieldIndex);
            subFields.push(
              (0, import_nodes3.instructionArgumentNode)({
                defaultValue: (0, import_nodes3.numberValueNode)(index),
                defaultValueStrategy: "omitted",
                name: `${subName}Discriminator`,
                type: (0, import_nodes3.numberTypeNode)("u8")
              })
            );
            if ((0, import_nodes3.isNode)(variant, "enumStructVariantTypeNode")) {
              subFields.push(
                (0, import_nodes3.instructionArgumentNode)({
                  ...argField,
                  type: variant.struct
                })
              );
            } else if ((0, import_nodes3.isNode)(variant, "enumTupleVariantTypeNode")) {
              subFields.push(
                (0, import_nodes3.instructionArgumentNode)({
                  ...argField,
                  type: variant.tuple
                })
              );
            }
            subFields.push(...argFields.slice(argFieldIndex + 1));
            return (0, import_nodes3.instructionNode)({
              ...node,
              arguments: flattenInstructionArguments(subFields),
              name: subName
            });
          });
          return (0, import_nodes3.instructionNode)({
            ...node,
            subInstructions: [...node.subInstructions ?? [], ...subInstructions]
          });
        }
      })
    )
  );
  return (0, import_visitors_core3.pipe)(visitor, (v) => (0, import_visitors_core3.recordLinkablesOnFirstVisitVisitor)(v, linkables));
}

// src/deduplicateIdenticalDefinedTypesVisitor.ts
var import_nodes4 = require("@codama/nodes");
var import_visitors_core4 = require("@codama/visitors-core");
function deduplicateIdenticalDefinedTypesVisitor() {
  return (0, import_visitors_core4.rootNodeVisitor)((root) => {
    const typeMap = /* @__PURE__ */ new Map();
    const allPrograms = (0, import_nodes4.getAllPrograms)(root);
    allPrograms.forEach((program) => {
      program.definedTypes.forEach((type) => {
        const typeWithProgram = { program, type };
        const list = typeMap.get(type.name) ?? [];
        typeMap.set(type.name, [...list, typeWithProgram]);
      });
    });
    typeMap.forEach((list, name) => {
      if (list.length <= 1) {
        typeMap.delete(name);
      }
    });
    const hashVisitor = (0, import_visitors_core4.getUniqueHashStringVisitor)({ removeDocs: true });
    typeMap.forEach((list, name) => {
      const types = list.map((item) => (0, import_visitors_core4.visit)(item.type, hashVisitor));
      const typesAreEqual = types.every((type, _, arr) => type === arr[0]);
      if (!typesAreEqual) {
        typeMap.delete(name);
      }
    });
    const deleteSelectors = Array.from(typeMap.values()).flatMap((list) => {
      const sortedList = list.sort((a, b) => allPrograms.indexOf(a.program) - allPrograms.indexOf(b.program));
      const [, ...sortedListTail] = sortedList;
      return sortedListTail;
    }).map(({ program, type }) => `[programNode]${program.name}.[definedTypeNode]${type.name}`);
    if (deleteSelectors.length > 0) {
      const newRoot = (0, import_visitors_core4.visit)(root, (0, import_visitors_core4.deleteNodesVisitor)(deleteSelectors));
      (0, import_nodes4.assertIsNode)(newRoot, "rootNode");
      return newRoot;
    }
    return root;
  });
}

// src/fillDefaultPdaSeedValuesVisitor.ts
var import_errors4 = require("@codama/errors");
var import_nodes5 = require("@codama/nodes");
var import_visitors_core5 = require("@codama/visitors-core");
function fillDefaultPdaSeedValuesVisitor(instructionPath, linkables, strictMode = false) {
  const instruction = (0, import_visitors_core5.getLastNodeFromPath)(instructionPath);
  return (0, import_visitors_core5.pipe)(
    (0, import_visitors_core5.identityVisitor)({ keys: import_nodes5.INSTRUCTION_INPUT_VALUE_NODES }),
    (v) => (0, import_visitors_core5.extendVisitor)(v, {
      visitPdaValue(node, { next }) {
        const visitedNode = next(node);
        (0, import_nodes5.assertIsNode)(visitedNode, "pdaValueNode");
        const foundPda = (0, import_nodes5.isNode)(visitedNode.pda, "pdaNode") ? visitedNode.pda : linkables.get([...instructionPath, visitedNode.pda]);
        if (!foundPda) return visitedNode;
        const seeds = addDefaultSeedValuesFromPdaWhenMissing(instruction, foundPda, visitedNode.seeds);
        if (strictMode && !allSeedsAreValid(instruction, foundPda, seeds)) {
          throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__VISITORS__INVALID_PDA_SEED_VALUES, {
            instruction,
            instructionName: instruction.name,
            pda: foundPda,
            pdaName: foundPda.name
          });
        }
        return (0, import_nodes5.pdaValueNode)(visitedNode.pda, seeds);
      }
    })
  );
}
function addDefaultSeedValuesFromPdaWhenMissing(instruction, pda, existingSeeds) {
  const existingSeedNames = new Set(existingSeeds.map((seed) => seed.name));
  const defaultSeeds = getDefaultSeedValuesFromPda(instruction, pda).filter(
    (seed) => !existingSeedNames.has(seed.name)
  );
  return [...existingSeeds, ...defaultSeeds];
}
function getDefaultSeedValuesFromPda(instruction, pda) {
  return pda.seeds.flatMap((seed) => {
    if (!(0, import_nodes5.isNode)(seed, "variablePdaSeedNode")) return [];
    const hasMatchingAccount = instruction.accounts.some((a) => a.name === seed.name);
    if ((0, import_nodes5.isNode)(seed.type, "publicKeyTypeNode") && hasMatchingAccount) {
      return [(0, import_nodes5.pdaSeedValueNode)(seed.name, (0, import_nodes5.accountValueNode)(seed.name))];
    }
    const hasMatchingArgument = (0, import_nodes5.getAllInstructionArguments)(instruction).some((a) => a.name === seed.name);
    if (hasMatchingArgument) {
      return [(0, import_nodes5.pdaSeedValueNode)(seed.name, (0, import_nodes5.argumentValueNode)(seed.name))];
    }
    return [];
  });
}
function allSeedsAreValid(instruction, foundPda, seeds) {
  const hasAllVariableSeeds = foundPda.seeds.filter((0, import_nodes5.isNodeFilter)("variablePdaSeedNode")).length === seeds.length;
  const allAccountsName = instruction.accounts.map((a) => a.name);
  const allArgumentsName = (0, import_nodes5.getAllInstructionArguments)(instruction).map((a) => a.name);
  const validSeeds = seeds.every((seed) => {
    if ((0, import_nodes5.isNode)(seed.value, "accountValueNode")) {
      return allAccountsName.includes(seed.value.name);
    }
    if ((0, import_nodes5.isNode)(seed.value, "argumentValueNode")) {
      return allArgumentsName.includes(seed.value.name);
    }
    return true;
  });
  return hasAllVariableSeeds && validSeeds;
}

// src/flattenStructVisitor.ts
var import_errors5 = require("@codama/errors");
var import_nodes6 = require("@codama/nodes");
var import_visitors_core6 = require("@codama/visitors-core");
function flattenStructVisitor(map) {
  return (0, import_visitors_core6.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([stack, options]) => ({
        select: `${stack}.[structTypeNode]`,
        transform: (node) => flattenStruct(node, options)
      })
    )
  );
}
var flattenStruct = (node, options = "*") => {
  (0, import_nodes6.assertIsNode)(node, "structTypeNode");
  const camelCaseOptions = options === "*" ? options : options.map(import_nodes6.camelCase);
  const shouldInline = (field) => options === "*" || camelCaseOptions.includes((0, import_nodes6.camelCase)(field.name));
  const inlinedFields = node.fields.flatMap((field) => {
    if ((0, import_nodes6.isNode)(field.type, "structTypeNode") && shouldInline(field)) {
      return field.type.fields;
    }
    return [field];
  });
  const inlinedFieldsNames = inlinedFields.map((arg) => arg.name);
  const duplicates = inlinedFieldsNames.filter((e, i, a) => a.indexOf(e) !== i);
  const uniqueDuplicates = [...new Set(duplicates)];
  const hasConflictingNames = uniqueDuplicates.length > 0;
  if (hasConflictingNames) {
    throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__VISITORS__CANNOT_FLATTEN_STRUCT_WITH_CONFLICTING_ATTRIBUTES, {
      conflictingAttributes: uniqueDuplicates
    });
  }
  return hasConflictingNames ? node : (0, import_nodes6.structTypeNode)(inlinedFields);
};

// src/getDefinedTypeHistogramVisitor.ts
var import_visitors_core7 = require("@codama/visitors-core");
function mergeHistograms(histograms) {
  const result = {};
  histograms.forEach((histogram) => {
    Object.keys(histogram).forEach((key) => {
      const mainCaseKey = key;
      if (result[mainCaseKey] === void 0) {
        result[mainCaseKey] = histogram[mainCaseKey];
      } else {
        result[mainCaseKey].total += histogram[mainCaseKey].total;
        result[mainCaseKey].inAccounts += histogram[mainCaseKey].inAccounts;
        result[mainCaseKey].inDefinedTypes += histogram[mainCaseKey].inDefinedTypes;
        result[mainCaseKey].inInstructionArgs += histogram[mainCaseKey].inInstructionArgs;
        result[mainCaseKey].directlyAsInstructionArgs += histogram[mainCaseKey].directlyAsInstructionArgs;
      }
    });
  });
  return result;
}
function getDefinedTypeHistogramVisitor() {
  const stack = new import_visitors_core7.NodeStack();
  let mode = null;
  let stackLevel = 0;
  return (0, import_visitors_core7.pipe)(
    (0, import_visitors_core7.mergeVisitor)(
      () => ({}),
      (_, histograms) => mergeHistograms(histograms)
    ),
    (v) => (0, import_visitors_core7.interceptVisitor)(v, (node, next) => {
      stackLevel += 1;
      const newNode = next(node);
      stackLevel -= 1;
      return newNode;
    }),
    (v) => (0, import_visitors_core7.extendVisitor)(v, {
      visitAccount(node, { self }) {
        mode = "account";
        stackLevel = 0;
        const histogram = (0, import_visitors_core7.visit)(node.data, self);
        mode = null;
        return histogram;
      },
      visitDefinedType(node, { self }) {
        mode = "definedType";
        stackLevel = 0;
        const histogram = (0, import_visitors_core7.visit)(node.type, self);
        mode = null;
        return histogram;
      },
      visitDefinedTypeLink(node) {
        const program = (0, import_visitors_core7.findProgramNodeFromPath)(stack.getPath());
        const key = program ? `${program.name}.${node.name}` : node.name;
        return {
          [key]: {
            directlyAsInstructionArgs: Number(mode === "instruction" && stackLevel <= 1),
            inAccounts: Number(mode === "account"),
            inDefinedTypes: Number(mode === "definedType"),
            inInstructionArgs: Number(mode === "instruction"),
            total: 1
          }
        };
      },
      visitInstruction(node, { self }) {
        mode = "instruction";
        stackLevel = 0;
        const dataHistograms = node.arguments.map((arg) => (0, import_visitors_core7.visit)(arg, self));
        const extraHistograms = (node.extraArguments ?? []).map((arg) => (0, import_visitors_core7.visit)(arg, self));
        mode = null;
        const subHistograms = (node.subInstructions ?? []).map((ix) => (0, import_visitors_core7.visit)(ix, self));
        return mergeHistograms([...dataHistograms, ...extraHistograms, ...subHistograms]);
      }
    }),
    (v) => (0, import_visitors_core7.recordNodeStackVisitor)(v, stack)
  );
}

// src/setAccountDiscriminatorFromFieldVisitor.ts
var import_errors6 = require("@codama/errors");
var import_nodes7 = require("@codama/nodes");
var import_visitors_core8 = require("@codama/visitors-core");
function setAccountDiscriminatorFromFieldVisitor(map) {
  return (0, import_visitors_core8.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([selector, { field, value, offset }]) => ({
        select: ["[accountNode]", selector],
        transform: (node) => {
          (0, import_nodes7.assertIsNode)(node, "accountNode");
          const accountData = (0, import_nodes7.resolveNestedTypeNode)(node.data);
          const fieldIndex = accountData.fields.findIndex((f) => f.name === field);
          if (fieldIndex < 0) {
            throw new import_errors6.CodamaError(import_errors6.CODAMA_ERROR__VISITORS__ACCOUNT_FIELD_NOT_FOUND, {
              account: node,
              missingField: field,
              name: node.name
            });
          }
          const fieldNode = accountData.fields[fieldIndex];
          return (0, import_nodes7.accountNode)({
            ...node,
            data: (0, import_nodes7.transformNestedTypeNode)(
              node.data,
              () => (0, import_nodes7.structTypeNode)([
                ...accountData.fields.slice(0, fieldIndex),
                (0, import_nodes7.structFieldTypeNode)({
                  ...fieldNode,
                  defaultValue: value,
                  defaultValueStrategy: "omitted"
                }),
                ...accountData.fields.slice(fieldIndex + 1)
              ])
            ),
            discriminators: [(0, import_nodes7.fieldDiscriminatorNode)(field, offset), ...node.discriminators ?? []]
          });
        }
      })
    )
  );
}

// src/setFixedAccountSizesVisitor.ts
var import_nodes8 = require("@codama/nodes");
var import_visitors_core9 = require("@codama/visitors-core");
function setFixedAccountSizesVisitor() {
  const linkables = new import_visitors_core9.LinkableDictionary();
  const visitor = (0, import_visitors_core9.topDownTransformerVisitor)(
    [
      {
        select: (path) => (0, import_visitors_core9.isNodePath)(path, "accountNode") && (0, import_visitors_core9.getLastNodeFromPath)(path).size === void 0,
        transform: (node, stack) => {
          (0, import_nodes8.assertIsNode)(node, "accountNode");
          const size = (0, import_visitors_core9.visit)(node.data, (0, import_visitors_core9.getByteSizeVisitor)(linkables, { stack }));
          if (size === null) return node;
          return (0, import_nodes8.accountNode)({ ...node, size });
        }
      }
    ],
    { keys: ["rootNode", "programNode", "accountNode"] }
  );
  return (0, import_visitors_core9.pipe)(visitor, (v) => (0, import_visitors_core9.recordLinkablesOnFirstVisitVisitor)(v, linkables));
}

// src/setInstructionAccountDefaultValuesVisitor.ts
var import_nodes9 = require("@codama/nodes");
var import_visitors_core10 = require("@codama/visitors-core");
var getCommonInstructionAccountDefaultRules = () => [
  {
    account: /^(payer|feePayer)$/,
    defaultValue: (0, import_nodes9.payerValueNode)(),
    ignoreIfOptional: true
  },
  {
    account: /^(authority)$/,
    defaultValue: (0, import_nodes9.identityValueNode)(),
    ignoreIfOptional: true
  },
  {
    account: /^(programId)$/,
    defaultValue: (0, import_nodes9.programIdValueNode)(),
    ignoreIfOptional: true
  },
  {
    account: /^(systemProgram|splSystemProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("11111111111111111111111111111111", "splSystem"),
    ignoreIfOptional: true
  },
  {
    account: /^(tokenProgram|splTokenProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", "splToken"),
    ignoreIfOptional: true
  },
  {
    account: /^(ataProgram|splAtaProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL", "splAssociatedToken"),
    ignoreIfOptional: true
  },
  {
    account: /^(tokenMetadataProgram|mplTokenMetadataProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s", "mplTokenMetadata"),
    ignoreIfOptional: true
  },
  {
    account: /^(tokenAuth|mplTokenAuth|authorization|mplAuthorization|auth|mplAuth)RulesProgram$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg", "mplTokenAuthRules"),
    ignoreIfOptional: true
  },
  {
    account: /^(candyMachineProgram|mplCandyMachineProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("CndyV3LdqHUfDLmE5naZjVN8rBZz4tqhdefbAnjHG3JR", "mplCandyMachine"),
    ignoreIfOptional: true
  },
  {
    account: /^(candyGuardProgram|mplCandyGuardProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("Guard1JwRhJkVH6XZhzoYxeBVQe872VH6QggF4BWmS9g", "mplCandyGuard"),
    ignoreIfOptional: true
  },
  {
    account: /^(clockSysvar|sysvarClock)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarC1ock11111111111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(epochScheduleSysvar|sysvarEpochSchedule)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarEpochSchedu1e111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(instructions?Sysvar|sysvarInstructions?)(Account)?$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("Sysvar1nstructions1111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(recentBlockhashesSysvar|sysvarRecentBlockhashes)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarRecentB1ockHashes11111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(rent|rentSysvar|sysvarRent)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarRent111111111111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(rewardsSysvar|sysvarRewards)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarRewards111111111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(slotHashesSysvar|sysvarSlotHashes)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarS1otHashes111111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(slotHistorySysvar|sysvarSlotHistory)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarS1otHistory11111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(stakeHistorySysvar|sysvarStakeHistory)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("SysvarStakeHistory1111111111111111111111111"),
    ignoreIfOptional: true
  },
  {
    account: /^(mplCoreProgram)$/,
    defaultValue: (0, import_nodes9.publicKeyValueNode)("CoREENxT6tW1HoK8ypY1SxRMZTcVPm7R94rH4PZNhX7d", "mplCore"),
    ignoreIfOptional: true
  }
];
function setInstructionAccountDefaultValuesVisitor(rules) {
  const linkables = new import_visitors_core10.LinkableDictionary();
  const stack = new import_visitors_core10.NodeStack();
  const sortedRules = rules.sort((a, b) => {
    const ia = "instruction" in a;
    const ib = "instruction" in b;
    if (ia && ib || !a && !ib) return 0;
    return ia ? -1 : 1;
  });
  function matchRule(instruction, account) {
    return sortedRules.find((rule) => {
      if ("instruction" in rule && rule.instruction && (0, import_nodes9.camelCase)(rule.instruction) !== instruction.name) {
        return false;
      }
      return typeof rule.account === "string" ? (0, import_nodes9.camelCase)(rule.account) === account.name : rule.account.test(account.name);
    });
  }
  return (0, import_visitors_core10.pipe)(
    (0, import_visitors_core10.nonNullableIdentityVisitor)({ keys: ["rootNode", "programNode", "instructionNode"] }),
    (v) => (0, import_visitors_core10.extendVisitor)(v, {
      visitInstruction(node) {
        const instructionPath = stack.getPath("instructionNode");
        const instructionAccounts = node.accounts.map((account) => {
          const rule = matchRule(node, account);
          if (!rule) return account;
          if ((rule.ignoreIfOptional ?? false) && (account.isOptional || !!account.defaultValue)) {
            return account;
          }
          try {
            return {
              ...account,
              defaultValue: (0, import_visitors_core10.visit)(
                rule.defaultValue,
                fillDefaultPdaSeedValuesVisitor(instructionPath, linkables, true)
              )
            };
          } catch {
            return account;
          }
        });
        return (0, import_nodes9.instructionNode)({
          ...node,
          accounts: instructionAccounts
        });
      }
    }),
    (v) => (0, import_visitors_core10.recordNodeStackVisitor)(v, stack),
    (v) => (0, import_visitors_core10.recordLinkablesOnFirstVisitVisitor)(v, linkables)
  );
}

// src/setInstructionDiscriminatorsVisitor.ts
var import_nodes10 = require("@codama/nodes");
var import_visitors_core11 = require("@codama/visitors-core");
function setInstructionDiscriminatorsVisitor(map) {
  return (0, import_visitors_core11.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([selector, discriminator]) => ({
        select: ["[instructionNode]", selector],
        transform: (node) => {
          (0, import_nodes10.assertIsNode)(node, "instructionNode");
          const discriminatorArgument = (0, import_nodes10.instructionArgumentNode)({
            defaultValue: discriminator.value,
            defaultValueStrategy: discriminator.strategy ?? "omitted",
            docs: discriminator.docs ?? [],
            name: discriminator.name ?? "discriminator",
            type: discriminator.type ?? (0, import_nodes10.numberTypeNode)("u8")
          });
          return (0, import_nodes10.instructionNode)({
            ...node,
            arguments: [discriminatorArgument, ...node.arguments],
            discriminators: [
              (0, import_nodes10.fieldDiscriminatorNode)(discriminator.name ?? "discriminator"),
              ...node.discriminators ?? []
            ]
          });
        }
      })
    )
  );
}

// src/setNumberWrappersVisitor.ts
var import_errors7 = require("@codama/errors");
var import_nodes11 = require("@codama/nodes");
var import_visitors_core12 = require("@codama/visitors-core");
function setNumberWrappersVisitor(map) {
  return (0, import_visitors_core12.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([selectorStack, wrapper]) => ({
        select: `${selectorStack}.[numberTypeNode]`,
        transform: (node) => {
          (0, import_nodes11.assertIsNestedTypeNode)(node, "numberTypeNode");
          switch (wrapper.kind) {
            case "DateTime":
              return (0, import_nodes11.dateTimeTypeNode)(node);
            case "SolAmount":
              return (0, import_nodes11.solAmountTypeNode)(node);
            case "Amount":
              return (0, import_nodes11.amountTypeNode)(node, wrapper.decimals, wrapper.unit);
            default:
              throw new import_errors7.CodamaError(import_errors7.CODAMA_ERROR__VISITORS__INVALID_NUMBER_WRAPPER, { wrapper });
          }
        }
      })
    )
  );
}

// src/setStructDefaultValuesVisitor.ts
var import_nodes12 = require("@codama/nodes");
var import_visitors_core13 = require("@codama/visitors-core");
function setStructDefaultValuesVisitor(map) {
  return (0, import_visitors_core13.bottomUpTransformerVisitor)(
    Object.entries(map).flatMap(([stack, defaultValues]) => {
      const camelCasedDefaultValues = Object.fromEntries(
        Object.entries(defaultValues).map(([key, value]) => [(0, import_nodes12.camelCase)(key), value])
      );
      return [
        {
          select: `${stack}.[structTypeNode]`,
          transform: (node) => {
            (0, import_nodes12.assertIsNode)(node, "structTypeNode");
            const fields = node.fields.map((field) => {
              const defaultValue = camelCasedDefaultValues[field.name];
              if (defaultValue === void 0) return field;
              if (defaultValue === null) {
                return (0, import_nodes12.structFieldTypeNode)({
                  ...field,
                  defaultValue: void 0,
                  defaultValueStrategy: void 0
                });
              }
              return (0, import_nodes12.structFieldTypeNode)({
                ...field,
                defaultValue: "kind" in defaultValue ? defaultValue : defaultValue.value,
                defaultValueStrategy: "kind" in defaultValue ? void 0 : defaultValue.strategy
              });
            });
            return (0, import_nodes12.structTypeNode)(fields);
          }
        },
        {
          select: ["[instructionNode]", stack],
          transform: (node) => {
            (0, import_nodes12.assertIsNode)(node, "instructionNode");
            const transformArguments = (arg) => {
              const defaultValue = camelCasedDefaultValues[arg.name];
              if (defaultValue === void 0) return arg;
              if (defaultValue === null) {
                return (0, import_nodes12.instructionArgumentNode)({
                  ...arg,
                  defaultValue: void 0,
                  defaultValueStrategy: void 0
                });
              }
              return (0, import_nodes12.instructionArgumentNode)({
                ...arg,
                defaultValue: "kind" in defaultValue ? defaultValue : defaultValue.value,
                defaultValueStrategy: "kind" in defaultValue ? void 0 : defaultValue.strategy
              });
            };
            return (0, import_nodes12.instructionNode)({
              ...node,
              arguments: node.arguments.map(transformArguments),
              extraArguments: node.extraArguments ? node.extraArguments.map(transformArguments) : void 0
            });
          }
        }
      ];
    })
  );
}

// src/transformDefinedTypesIntoAccountsVisitor.ts
var import_nodes13 = require("@codama/nodes");
var import_visitors_core14 = require("@codama/visitors-core");
function transformDefinedTypesIntoAccountsVisitor(definedTypes) {
  return (0, import_visitors_core14.pipe)(
    (0, import_visitors_core14.nonNullableIdentityVisitor)({ keys: ["rootNode", "programNode"] }),
    (v) => (0, import_visitors_core14.extendVisitor)(v, {
      visitProgram(program) {
        const typesToExtract = program.definedTypes.filter((node) => definedTypes.includes(node.name));
        const newDefinedTypes = program.definedTypes.filter((node) => !definedTypes.includes(node.name));
        const newAccounts = typesToExtract.map((node) => {
          (0, import_nodes13.assertIsNode)(node.type, "structTypeNode");
          return (0, import_nodes13.accountNode)({
            ...node,
            data: node.type,
            discriminators: [],
            size: void 0
          });
        });
        return (0, import_nodes13.programNode)({
          ...program,
          accounts: [...program.accounts, ...newAccounts],
          definedTypes: newDefinedTypes
        });
      }
    })
  );
}

// src/transformU8ArraysToBytesVisitor.ts
var import_nodes14 = require("@codama/nodes");
var import_visitors_core15 = require("@codama/visitors-core");
function transformU8ArraysToBytesVisitor(sizes = "*") {
  const hasRequiredSize = (count) => {
    if (!(0, import_nodes14.isNode)(count, "fixedCountNode")) return false;
    return sizes === "*" || sizes.includes(count.value);
  };
  return (0, import_visitors_core15.pipe)(
    (0, import_visitors_core15.nonNullableIdentityVisitor)(),
    (v) => (0, import_visitors_core15.extendVisitor)(v, {
      visitArrayType(node, { self }) {
        const child = (0, import_visitors_core15.visit)(node.item, self);
        (0, import_nodes14.assertIsNode)(child, import_nodes14.TYPE_NODES);
        if ((0, import_nodes14.isNode)(child, "numberTypeNode") && child.format === "u8" && (0, import_nodes14.isNode)(node.count, "fixedCountNode") && hasRequiredSize(node.count)) {
          return (0, import_nodes14.fixedSizeTypeNode)((0, import_nodes14.bytesTypeNode)(), node.count.value);
        }
        return (0, import_nodes14.arrayTypeNode)(child, node.count);
      }
    })
  );
}

// src/unwrapDefinedTypesVisitor.ts
var import_nodes15 = require("@codama/nodes");
var import_visitors_core16 = require("@codama/visitors-core");
function unwrapDefinedTypesVisitor(typesToInline = "*") {
  const linkables = new import_visitors_core16.LinkableDictionary();
  const stack = new import_visitors_core16.NodeStack();
  const typesToInlineCamelCased = (typesToInline === "*" ? [] : typesToInline).map((fullPath) => {
    if (!fullPath.includes(".")) return (0, import_nodes15.camelCase)(fullPath);
    const [programName, typeName] = fullPath.split(".");
    return `${(0, import_nodes15.camelCase)(programName)}.${(0, import_nodes15.camelCase)(typeName)}`;
  });
  const shouldInline = (typeName, programName) => {
    if (typesToInline === "*") return true;
    const fullPath = `${programName}.${typeName}`;
    if (!!programName && typesToInlineCamelCased.includes(fullPath)) return true;
    return typesToInlineCamelCased.includes(typeName);
  };
  return (0, import_visitors_core16.pipe)(
    (0, import_visitors_core16.nonNullableIdentityVisitor)(),
    (v) => (0, import_visitors_core16.extendVisitor)(v, {
      visitDefinedTypeLink(linkType, { self }) {
        const programName = linkType.program?.name ?? (0, import_visitors_core16.findProgramNodeFromPath)(stack.getPath())?.name;
        if (!shouldInline(linkType.name, programName)) {
          return linkType;
        }
        const definedTypePath = linkables.getPathOrThrow(stack.getPath("definedTypeLinkNode"));
        const definedType = (0, import_visitors_core16.getLastNodeFromPath)(definedTypePath);
        stack.pushPath(definedTypePath);
        const result = (0, import_visitors_core16.visit)(definedType.type, self);
        stack.popPath();
        return result;
      },
      visitProgram(program, { self }) {
        return (0, import_nodes15.programNode)({
          ...program,
          accounts: program.accounts.map((account) => (0, import_visitors_core16.visit)(account, self)).filter((0, import_nodes15.assertIsNodeFilter)("accountNode")),
          definedTypes: program.definedTypes.filter((definedType) => !shouldInline(definedType.name, program.name)).map((type) => (0, import_visitors_core16.visit)(type, self)).filter((0, import_nodes15.assertIsNodeFilter)("definedTypeNode")),
          instructions: program.instructions.map((instruction) => (0, import_visitors_core16.visit)(instruction, self)).filter((0, import_nodes15.assertIsNodeFilter)("instructionNode"))
        });
      }
    }),
    (v) => (0, import_visitors_core16.recordNodeStackVisitor)(v, stack),
    (v) => (0, import_visitors_core16.recordLinkablesOnFirstVisitVisitor)(v, linkables)
  );
}

// src/unwrapInstructionArgsDefinedTypesVisitor.ts
var import_nodes16 = require("@codama/nodes");
var import_visitors_core17 = require("@codama/visitors-core");
function unwrapInstructionArgsDefinedTypesVisitor() {
  return (0, import_visitors_core17.rootNodeVisitor)((root) => {
    const histogram = (0, import_visitors_core17.visit)(root, getDefinedTypeHistogramVisitor());
    const linkables = new import_visitors_core17.LinkableDictionary();
    (0, import_visitors_core17.visit)(root, (0, import_visitors_core17.getRecordLinkablesVisitor)(linkables));
    const definedTypesToInline = Object.keys(histogram).filter((key) => (histogram[key].total ?? 0) === 1 && (histogram[key].directlyAsInstructionArgs ?? 0) === 1).filter((key) => {
      const names = key.split(".");
      const link = names.length == 2 ? (0, import_nodes16.definedTypeLinkNode)(names[1], names[0]) : (0, import_nodes16.definedTypeLinkNode)(key);
      const found = linkables.get([link]);
      return found && !(0, import_nodes16.isNode)(found.type, "enumTypeNode");
    });
    if (definedTypesToInline.length > 0) {
      const inlineVisitor = unwrapDefinedTypesVisitor(definedTypesToInline);
      const newRoot = (0, import_visitors_core17.visit)(root, inlineVisitor);
      (0, import_nodes16.assertIsNode)(newRoot, "rootNode");
      return newRoot;
    }
    return root;
  });
}

// src/unwrapTupleEnumWithSingleStructVisitor.ts
var import_nodes17 = require("@codama/nodes");
var import_visitors_core18 = require("@codama/visitors-core");
function unwrapTupleEnumWithSingleStructVisitor(enumsOrVariantsToUnwrap = "*") {
  const selectorFunctions = enumsOrVariantsToUnwrap === "*" ? [() => true] : enumsOrVariantsToUnwrap.map((selector) => (0, import_visitors_core18.getNodeSelectorFunction)(selector));
  const shouldUnwrap = (stack) => selectorFunctions.some((selector) => selector(stack.getPath()));
  return (0, import_visitors_core18.rootNodeVisitor)((root) => {
    const typesToPotentiallyUnwrap = [];
    const definedTypes = new Map(
      (0, import_nodes17.getAllDefinedTypes)(root).map((definedType) => [definedType.name, definedType])
    );
    let newRoot = (0, import_visitors_core18.visit)(
      root,
      (0, import_visitors_core18.bottomUpTransformerVisitor)([
        {
          select: "[enumTupleVariantTypeNode]",
          transform: (node, stack) => {
            (0, import_nodes17.assertIsNode)(node, "enumTupleVariantTypeNode");
            if (!shouldUnwrap(stack)) return node;
            const tupleNode = (0, import_nodes17.resolveNestedTypeNode)(node.tuple);
            if (tupleNode.items.length !== 1) return node;
            let item = tupleNode.items[0];
            if ((0, import_nodes17.isNode)(item, "definedTypeLinkNode")) {
              const definedType = definedTypes.get(item.name);
              if (!definedType) return node;
              if (!(0, import_nodes17.isNode)(definedType.type, "structTypeNode")) return node;
              typesToPotentiallyUnwrap.push(item.name);
              item = definedType.type;
            }
            if (!(0, import_nodes17.isNode)(item, "structTypeNode")) return node;
            const nestedStruct = (0, import_nodes17.transformNestedTypeNode)(node.tuple, () => item);
            return (0, import_nodes17.enumStructVariantTypeNode)(node.name, nestedStruct);
          }
        }
      ])
    );
    (0, import_nodes17.assertIsNode)(newRoot, "rootNode");
    const histogram = (0, import_visitors_core18.visit)(newRoot, getDefinedTypeHistogramVisitor());
    const typesToUnwrap = typesToPotentiallyUnwrap.filter(
      (type) => !histogram[type] || histogram[type].total === 0
    );
    newRoot = (0, import_visitors_core18.visit)(newRoot, unwrapDefinedTypesVisitor(typesToUnwrap));
    (0, import_nodes17.assertIsNode)(newRoot, "rootNode");
    return newRoot;
  });
}

// src/unwrapTypeDefinedLinksVisitor.ts
var import_visitors_core19 = require("@codama/visitors-core");
function unwrapTypeDefinedLinksVisitor(definedLinksType) {
  const linkables = new import_visitors_core19.LinkableDictionary();
  const transformers = definedLinksType.map((selector) => ({
    select: ["[definedTypeLinkNode]", selector],
    transform: (_, stack) => {
      const definedType = linkables.getOrThrow(stack.getPath("definedTypeLinkNode"));
      return definedType.type;
    }
  }));
  return (0, import_visitors_core19.pipe)((0, import_visitors_core19.bottomUpTransformerVisitor)(transformers), (v) => (0, import_visitors_core19.recordLinkablesOnFirstVisitVisitor)(v, linkables));
}

// src/updateAccountsVisitor.ts
var import_nodes19 = require("@codama/nodes");
var import_visitors_core20 = require("@codama/visitors-core");

// src/renameHelpers.ts
var import_nodes18 = require("@codama/nodes");
function renameStructNode(node, map) {
  return (0, import_nodes18.structTypeNode)(
    node.fields.map((field) => map[field.name] ? (0, import_nodes18.structFieldTypeNode)({ ...field, name: map[field.name] }) : field)
  );
}
function renameEnumNode(node, map) {
  return (0, import_nodes18.enumTypeNode)(
    node.variants.map((variant) => map[variant.name] ? renameEnumVariant(variant, map[variant.name]) : variant),
    { ...node }
  );
}
function renameEnumVariant(variant, newName) {
  if ((0, import_nodes18.isNode)(variant, "enumStructVariantTypeNode")) {
    return (0, import_nodes18.enumStructVariantTypeNode)(newName, variant.struct);
  }
  if ((0, import_nodes18.isNode)(variant, "enumTupleVariantTypeNode")) {
    return (0, import_nodes18.enumTupleVariantTypeNode)(newName, variant.tuple);
  }
  return (0, import_nodes18.enumEmptyVariantTypeNode)(newName);
}

// src/updateAccountsVisitor.ts
function updateAccountsVisitor(map) {
  return (0, import_visitors_core20.bottomUpTransformerVisitor)(
    Object.entries(map).flatMap(([selector, updates]) => {
      const newName = typeof updates === "object" && "name" in updates && updates.name ? (0, import_nodes19.camelCase)(updates.name) : void 0;
      const pdasToUpsert = [];
      const transformers = [
        {
          select: ["[accountNode]", selector],
          transform: (node, stack) => {
            (0, import_nodes19.assertIsNode)(node, "accountNode");
            if ("delete" in updates) return null;
            const programNode6 = (0, import_visitors_core20.findProgramNodeFromPath)(stack.getPath());
            const { seeds, pda, ...assignableUpdates } = updates;
            let newPda = node.pda;
            if (pda && seeds !== void 0) {
              newPda = pda;
              pdasToUpsert.push({
                pda: (0, import_nodes19.pdaNode)({ name: pda.name, seeds }),
                program: programNode6.name
              });
            } else if (pda) {
              newPda = pda;
            } else if (seeds !== void 0 && node.pda) {
              pdasToUpsert.push({
                pda: (0, import_nodes19.pdaNode)({ name: node.pda.name, seeds }),
                program: programNode6.name
              });
            } else if (seeds !== void 0) {
              newPda = (0, import_nodes19.pdaLinkNode)(newName ?? node.name);
              pdasToUpsert.push({
                pda: (0, import_nodes19.pdaNode)({ name: newName ?? node.name, seeds }),
                program: programNode6.name
              });
            }
            return (0, import_nodes19.accountNode)({
              ...node,
              ...assignableUpdates,
              data: (0, import_nodes19.transformNestedTypeNode)(
                node.data,
                (struct) => renameStructNode(struct, updates.data ?? {})
              ),
              pda: newPda
            });
          }
        },
        {
          select: `[programNode]`,
          transform: (node) => {
            (0, import_nodes19.assertIsNode)(node, "programNode");
            const pdasToUpsertForProgram = pdasToUpsert.filter((p) => p.program === node.name).map((p) => p.pda);
            if (pdasToUpsertForProgram.length === 0) return node;
            const existingPdaNames = new Set(node.pdas.map((pda) => pda.name));
            const pdasToCreate = pdasToUpsertForProgram.filter((p) => !existingPdaNames.has(p.name));
            const pdasToUpdate = new Map(
              pdasToUpsertForProgram.filter((p) => existingPdaNames.has(p.name)).map((p) => [p.name, p])
            );
            const newPdas = [...node.pdas.map((p) => pdasToUpdate.get(p.name) ?? p), ...pdasToCreate];
            return (0, import_nodes19.programNode)({ ...node, pdas: newPdas });
          }
        }
      ];
      if (newName) {
        transformers.push(
          {
            select: ["[accountLinkNode]", selector],
            transform: (node) => {
              (0, import_nodes19.assertIsNode)(node, "accountLinkNode");
              return (0, import_nodes19.accountLinkNode)(newName);
            }
          },
          {
            select: ["[pdaNode]", selector],
            transform: (node) => {
              (0, import_nodes19.assertIsNode)(node, "pdaNode");
              return (0, import_nodes19.pdaNode)({ name: newName, seeds: node.seeds });
            }
          },
          {
            select: ["[pdaLinkNode]", selector],
            transform: (node) => {
              (0, import_nodes19.assertIsNode)(node, "pdaLinkNode");
              return (0, import_nodes19.pdaLinkNode)(newName);
            }
          }
        );
      }
      return transformers;
    })
  );
}

// src/updateDefinedTypesVisitor.ts
var import_nodes20 = require("@codama/nodes");
var import_visitors_core21 = require("@codama/visitors-core");
function updateDefinedTypesVisitor(map) {
  return (0, import_visitors_core21.bottomUpTransformerVisitor)(
    Object.entries(map).flatMap(([selector, updates]) => {
      const newName = typeof updates === "object" && "name" in updates && updates.name ? (0, import_nodes20.camelCase)(updates.name) : void 0;
      const transformers = [
        {
          select: ["[definedTypeNode]", selector],
          transform: (node) => {
            (0, import_nodes20.assertIsNode)(node, "definedTypeNode");
            if ("delete" in updates) {
              return null;
            }
            const { data: dataUpdates, ...otherUpdates } = updates;
            let newType = node.type;
            if ((0, import_nodes20.isNode)(node.type, "structTypeNode")) {
              newType = renameStructNode(node.type, dataUpdates ?? {});
            } else if ((0, import_nodes20.isNode)(node.type, "enumTypeNode")) {
              newType = renameEnumNode(node.type, dataUpdates ?? {});
            }
            return (0, import_nodes20.definedTypeNode)({
              ...node,
              ...otherUpdates,
              name: newName ?? node.name,
              type: newType
            });
          }
        }
      ];
      if (newName) {
        transformers.push({
          select: ["[definedTypeLinkNode]", selector],
          transform: (node) => {
            (0, import_nodes20.assertIsNode)(node, "definedTypeLinkNode");
            return (0, import_nodes20.definedTypeLinkNode)(newName);
          }
        });
      }
      return transformers;
    })
  );
}

// src/updateErrorsVisitor.ts
var import_nodes21 = require("@codama/nodes");
var import_visitors_core22 = require("@codama/visitors-core");
function updateErrorsVisitor(map) {
  return (0, import_visitors_core22.bottomUpTransformerVisitor)(
    Object.entries(map).map(
      ([name, updates]) => ({
        select: `[errorNode]${name}`,
        transform: (node) => {
          (0, import_nodes21.assertIsNode)(node, "errorNode");
          if ("delete" in updates) return null;
          return (0, import_nodes21.errorNode)({ ...node, ...updates });
        }
      })
    )
  );
}

// src/updateInstructionsVisitor.ts
var import_nodes22 = require("@codama/nodes");
var import_visitors_core23 = require("@codama/visitors-core");
function updateInstructionsVisitor(map) {
  const linkables = new import_visitors_core23.LinkableDictionary();
  const stack = new import_visitors_core23.NodeStack();
  const transformers = Object.entries(map).map(
    ([selector, updates]) => ({
      select: ["[instructionNode]", selector],
      transform: (node) => {
        (0, import_nodes22.assertIsNode)(node, "instructionNode");
        if ("delete" in updates) {
          return null;
        }
        const instructionPath = stack.getPath("instructionNode");
        const { accounts: accountUpdates, arguments: argumentUpdates, ...metadataUpdates } = updates;
        const { newArguments, newExtraArguments } = handleInstructionArguments(node, argumentUpdates ?? {});
        const newAccounts = node.accounts.map(
          (account) => handleInstructionAccount(instructionPath, account, accountUpdates ?? {}, linkables)
        );
        return (0, import_nodes22.instructionNode)({
          ...node,
          ...metadataUpdates,
          accounts: newAccounts,
          arguments: newArguments,
          extraArguments: newExtraArguments.length > 0 ? newExtraArguments : void 0
        });
      }
    })
  );
  return (0, import_visitors_core23.pipe)(
    (0, import_visitors_core23.bottomUpTransformerVisitor)(transformers),
    (v) => (0, import_visitors_core23.recordNodeStackVisitor)(v, stack),
    (v) => (0, import_visitors_core23.recordLinkablesOnFirstVisitVisitor)(v, linkables)
  );
}
function handleInstructionAccount(instructionPath, account, accountUpdates, linkables) {
  const accountUpdate = accountUpdates?.[account.name];
  if (!accountUpdate) return account;
  const { defaultValue, ...acountWithoutDefault } = {
    ...account,
    ...accountUpdate
  };
  if (!defaultValue) {
    return (0, import_nodes22.instructionAccountNode)(acountWithoutDefault);
  }
  return (0, import_nodes22.instructionAccountNode)({
    ...acountWithoutDefault,
    defaultValue: (0, import_visitors_core23.visit)(defaultValue, fillDefaultPdaSeedValuesVisitor(instructionPath, linkables))
  });
}
function handleInstructionArguments(instruction, argUpdates) {
  const usedArguments = /* @__PURE__ */ new Set();
  const newArguments = instruction.arguments.map((node) => {
    const argUpdate = argUpdates[node.name];
    if (!argUpdate) return node;
    usedArguments.add(node.name);
    return (0, import_nodes22.instructionArgumentNode)({
      ...node,
      defaultValue: argUpdate.defaultValue ?? node.defaultValue,
      defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,
      docs: argUpdate.docs ?? node.docs,
      name: argUpdate.name ?? node.name,
      type: argUpdate.type ?? node.type
    });
  });
  const updatedExtraArguments = (instruction.extraArguments ?? []).map((node) => {
    if (usedArguments.has(node.name)) return node;
    const argUpdate = argUpdates[node.name];
    if (!argUpdate) return node;
    usedArguments.add(node.name);
    return (0, import_nodes22.instructionArgumentNode)({
      ...node,
      defaultValue: argUpdate.defaultValue ?? node.defaultValue,
      defaultValueStrategy: argUpdate.defaultValueStrategy ?? node.defaultValueStrategy,
      docs: argUpdate.docs ?? node.docs,
      name: argUpdate.name ?? node.name,
      type: argUpdate.type ?? node.type
    });
  });
  const newExtraArguments = [
    ...updatedExtraArguments,
    ...Object.entries(argUpdates).filter(([argName]) => !usedArguments.has(argName)).map(([argName, argUpdate]) => {
      const { type } = argUpdate;
      (0, import_nodes22.assertIsNode)(type, import_nodes22.TYPE_NODES);
      return (0, import_nodes22.instructionArgumentNode)({
        defaultValue: argUpdate.defaultValue ?? void 0,
        defaultValueStrategy: argUpdate.defaultValueStrategy ?? void 0,
        docs: argUpdate.docs ?? [],
        name: argUpdate.name ?? argName,
        type
      });
    })
  ];
  return { newArguments, newExtraArguments };
}

// src/updateProgramsVisitor.ts
var import_nodes23 = require("@codama/nodes");
var import_visitors_core24 = require("@codama/visitors-core");
function updateProgramsVisitor(map) {
  return (0, import_visitors_core24.bottomUpTransformerVisitor)(
    Object.entries(map).flatMap(([name, updates]) => {
      const newName = typeof updates === "object" && "name" in updates && updates.name ? (0, import_nodes23.camelCase)(updates.name) : void 0;
      const transformers = [
        {
          select: `[programNode]${name}`,
          transform: (node) => {
            (0, import_nodes23.assertIsNode)(node, "programNode");
            if ("delete" in updates) return null;
            return (0, import_nodes23.programNode)({ ...node, ...updates });
          }
        }
      ];
      if (newName) {
        transformers.push({
          select: `[programLinkNode]${name}`,
          transform: (node) => {
            (0, import_nodes23.assertIsNode)(node, "programLinkNode");
            return (0, import_nodes23.programLinkNode)(newName);
          }
        });
      }
      return transformers;
    })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addPdasVisitor,
  createSubInstructionsFromEnumArgsVisitor,
  deduplicateIdenticalDefinedTypesVisitor,
  fillDefaultPdaSeedValuesVisitor,
  flattenInstructionArguments,
  flattenInstructionDataArgumentsVisitor,
  flattenStruct,
  flattenStructVisitor,
  getCommonInstructionAccountDefaultRules,
  getDefinedTypeHistogramVisitor,
  setAccountDiscriminatorFromFieldVisitor,
  setFixedAccountSizesVisitor,
  setInstructionAccountDefaultValuesVisitor,
  setInstructionDiscriminatorsVisitor,
  setNumberWrappersVisitor,
  setStructDefaultValuesVisitor,
  transformDefinedTypesIntoAccountsVisitor,
  transformU8ArraysToBytesVisitor,
  unwrapDefinedTypesVisitor,
  unwrapInstructionArgsDefinedTypesVisitor,
  unwrapTupleEnumWithSingleStructVisitor,
  unwrapTypeDefinedLinksVisitor,
  updateAccountsVisitor,
  updateDefinedTypesVisitor,
  updateErrorsVisitor,
  updateInstructionsVisitor,
  updateProgramsVisitor,
  ...require("@codama/visitors-core")
});
//# sourceMappingURL=index.node.cjs.map