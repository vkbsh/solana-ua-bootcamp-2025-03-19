{"version":3,"sources":["../src/identityVisitor.ts","../src/staticVisitor.ts","../src/visitor.ts","../src/interceptVisitor.ts","../src/NodeSelector.ts","../src/NodeStack.ts","../src/NodePath.ts","../src/pipe.ts","../src/recordNodeStackVisitor.ts","../src/bottomUpTransformerVisitor.ts","../src/mapVisitor.ts","../src/consoleLogVisitor.ts","../src/topDownTransformerVisitor.ts","../src/deleteNodesVisitor.ts","../src/extendVisitor.ts","../src/getByteSizeVisitor.ts","../src/mergeVisitor.ts","../src/getDebugStringVisitor.ts","../src/getResolvedInstructionInputsVisitor.ts","../src/singleNodeVisitor.ts","../src/getUniqueHashStringVisitor.ts","../src/nonNullableIdentityVisitor.ts","../src/removeDocsVisitor.ts","../src/interceptFirstVisitVisitor.ts","../src/LinkableDictionary.ts","../src/recordLinkablesVisitor.ts","../src/voidVisitor.ts","../src/tapVisitor.ts"],"sourcesContent":["import {\n    accountLinkNode,\n    accountNode,\n    amountTypeNode,\n    arrayTypeNode,\n    arrayValueNode,\n    assertIsNestedTypeNode,\n    assertIsNode,\n    booleanTypeNode,\n    conditionalValueNode,\n    constantDiscriminatorNode,\n    constantPdaSeedNode,\n    constantValueNode,\n    COUNT_NODES,\n    dateTimeTypeNode,\n    definedTypeLinkNode,\n    definedTypeNode,\n    DISCRIMINATOR_NODES,\n    ENUM_VARIANT_TYPE_NODES,\n    enumEmptyVariantTypeNode,\n    enumStructVariantTypeNode,\n    enumTupleVariantTypeNode,\n    enumTypeNode,\n    enumValueNode,\n    fixedSizeTypeNode,\n    hiddenPrefixTypeNode,\n    hiddenSuffixTypeNode,\n    INSTRUCTION_INPUT_VALUE_NODES,\n    instructionAccountLinkNode,\n    instructionAccountNode,\n    instructionArgumentLinkNode,\n    instructionArgumentNode,\n    instructionByteDeltaNode,\n    instructionLinkNode,\n    instructionNode,\n    instructionRemainingAccountsNode,\n    mapEntryValueNode,\n    mapTypeNode,\n    mapValueNode,\n    Node,\n    NodeKind,\n    optionTypeNode,\n    PDA_SEED_NODES,\n    pdaLinkNode,\n    pdaNode,\n    pdaSeedValueNode,\n    pdaValueNode,\n    postOffsetTypeNode,\n    prefixedCountNode,\n    preOffsetTypeNode,\n    programNode,\n    REGISTERED_NODE_KINDS,\n    remainderOptionTypeNode,\n    removeNullAndAssertIsNodeFilter,\n    resolverValueNode,\n    rootNode,\n    sentinelTypeNode,\n    setTypeNode,\n    setValueNode,\n    sizePrefixTypeNode,\n    solAmountTypeNode,\n    someValueNode,\n    structFieldTypeNode,\n    structFieldValueNode,\n    structTypeNode,\n    structValueNode,\n    tupleTypeNode,\n    tupleValueNode,\n    TYPE_NODES,\n    VALUE_NODES,\n    variablePdaSeedNode,\n    zeroableOptionTypeNode,\n} from '@codama/nodes';\n\nimport { staticVisitor } from './staticVisitor';\nimport { visit as baseVisit, Visitor } from './visitor';\n\nexport function identityVisitor<TNodeKind extends NodeKind = NodeKind>(\n    options: { keys?: TNodeKind[] } = {},\n): Visitor<Node | null, TNodeKind> {\n    const keys: NodeKind[] = options.keys ?? (REGISTERED_NODE_KINDS as TNodeKind[]);\n    const visitor = staticVisitor(node => Object.freeze({ ...node }), { keys }) as Visitor<Node | null>;\n    const visit =\n        (v: Visitor<Node | null>) =>\n        (node: Node): Node | null =>\n            keys.includes(node.kind) ? baseVisit(node, v) : Object.freeze({ ...node });\n\n    if (keys.includes('rootNode')) {\n        visitor.visitRoot = function visitRoot(node) {\n            const program = visit(this)(node.program);\n            if (program === null) return null;\n            assertIsNode(program, 'programNode');\n            return rootNode(\n                program,\n                node.additionalPrograms.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('programNode')),\n            );\n        };\n    }\n\n    if (keys.includes('programNode')) {\n        visitor.visitProgram = function visitProgram(node) {\n            return programNode({\n                ...node,\n                accounts: node.accounts.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('accountNode')),\n                definedTypes: node.definedTypes\n                    .map(visit(this))\n                    .filter(removeNullAndAssertIsNodeFilter('definedTypeNode')),\n                errors: node.errors.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('errorNode')),\n                instructions: node.instructions\n                    .map(visit(this))\n                    .filter(removeNullAndAssertIsNodeFilter('instructionNode')),\n                pdas: node.pdas.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('pdaNode')),\n            });\n        };\n    }\n\n    if (keys.includes('pdaNode')) {\n        visitor.visitPda = function visitPda(node) {\n            return pdaNode({\n                ...node,\n                seeds: node.seeds.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(PDA_SEED_NODES)),\n            });\n        };\n    }\n\n    if (keys.includes('accountNode')) {\n        visitor.visitAccount = function visitAccount(node) {\n            const data = visit(this)(node.data);\n            if (data === null) return null;\n            assertIsNode(data, 'structTypeNode');\n            const pda = node.pda ? (visit(this)(node.pda) ?? undefined) : undefined;\n            if (pda) assertIsNode(pda, 'pdaLinkNode');\n            return accountNode({ ...node, data, pda });\n        };\n    }\n\n    if (keys.includes('instructionNode')) {\n        visitor.visitInstruction = function visitInstruction(node) {\n            return instructionNode({\n                ...node,\n                accounts: node.accounts\n                    .map(visit(this))\n                    .filter(removeNullAndAssertIsNodeFilter('instructionAccountNode')),\n                arguments: node.arguments\n                    .map(visit(this))\n                    .filter(removeNullAndAssertIsNodeFilter('instructionArgumentNode')),\n                byteDeltas: node.byteDeltas\n                    ? node.byteDeltas\n                          .map(visit(this))\n                          .filter(removeNullAndAssertIsNodeFilter('instructionByteDeltaNode'))\n                    : undefined,\n                discriminators: node.discriminators\n                    ? node.discriminators.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(DISCRIMINATOR_NODES))\n                    : undefined,\n                extraArguments: node.extraArguments\n                    ? node.extraArguments\n                          .map(visit(this))\n                          .filter(removeNullAndAssertIsNodeFilter('instructionArgumentNode'))\n                    : undefined,\n                remainingAccounts: node.remainingAccounts\n                    ? node.remainingAccounts\n                          .map(visit(this))\n                          .filter(removeNullAndAssertIsNodeFilter('instructionRemainingAccountsNode'))\n                    : undefined,\n                subInstructions: node.subInstructions\n                    ? node.subInstructions.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('instructionNode'))\n                    : undefined,\n            });\n        };\n    }\n\n    if (keys.includes('instructionAccountNode')) {\n        visitor.visitInstructionAccount = function visitInstructionAccount(node) {\n            const defaultValue = node.defaultValue ? (visit(this)(node.defaultValue) ?? undefined) : undefined;\n            if (defaultValue) assertIsNode(defaultValue, INSTRUCTION_INPUT_VALUE_NODES);\n            return instructionAccountNode({ ...node, defaultValue });\n        };\n    }\n\n    if (keys.includes('instructionArgumentNode')) {\n        visitor.visitInstructionArgument = function visitInstructionArgument(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const defaultValue = node.defaultValue ? (visit(this)(node.defaultValue) ?? undefined) : undefined;\n            if (defaultValue) assertIsNode(defaultValue, INSTRUCTION_INPUT_VALUE_NODES);\n            return instructionArgumentNode({ ...node, defaultValue, type });\n        };\n    }\n\n    if (keys.includes('instructionRemainingAccountsNode')) {\n        visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, ['argumentValueNode', 'resolverValueNode']);\n            return instructionRemainingAccountsNode(value, { ...node });\n        };\n    }\n\n    if (keys.includes('instructionByteDeltaNode')) {\n        visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, ['numberValueNode', 'accountLinkNode', 'argumentValueNode', 'resolverValueNode']);\n            return instructionByteDeltaNode(value, { ...node });\n        };\n    }\n\n    if (keys.includes('definedTypeNode')) {\n        visitor.visitDefinedType = function visitDefinedType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return definedTypeNode({ ...node, type });\n        };\n    }\n\n    if (keys.includes('arrayTypeNode')) {\n        visitor.visitArrayType = function visitArrayType(node) {\n            const size = visit(this)(node.count);\n            if (size === null) return null;\n            assertIsNode(size, COUNT_NODES);\n            const item = visit(this)(node.item);\n            if (item === null) return null;\n            assertIsNode(item, TYPE_NODES);\n            return arrayTypeNode(item, size);\n        };\n    }\n\n    if (keys.includes('enumTypeNode')) {\n        visitor.visitEnumType = function visitEnumType(node) {\n            return enumTypeNode(\n                node.variants.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(ENUM_VARIANT_TYPE_NODES)),\n                { size: node.size },\n            );\n        };\n    }\n\n    if (keys.includes('enumStructVariantTypeNode')) {\n        visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {\n            const newStruct = visit(this)(node.struct);\n            if (!newStruct) {\n                return enumEmptyVariantTypeNode(node.name);\n            }\n            assertIsNode(newStruct, 'structTypeNode');\n            if (newStruct.fields.length === 0) {\n                return enumEmptyVariantTypeNode(node.name);\n            }\n            return enumStructVariantTypeNode(node.name, newStruct);\n        };\n    }\n\n    if (keys.includes('enumTupleVariantTypeNode')) {\n        visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {\n            const newTuple = visit(this)(node.tuple);\n            if (!newTuple) {\n                return enumEmptyVariantTypeNode(node.name);\n            }\n            assertIsNode(newTuple, 'tupleTypeNode');\n            if (newTuple.items.length === 0) {\n                return enumEmptyVariantTypeNode(node.name);\n            }\n            return enumTupleVariantTypeNode(node.name, newTuple);\n        };\n    }\n\n    if (keys.includes('mapTypeNode')) {\n        visitor.visitMapType = function visitMapType(node) {\n            const size = visit(this)(node.count);\n            if (size === null) return null;\n            assertIsNode(size, COUNT_NODES);\n            const key = visit(this)(node.key);\n            if (key === null) return null;\n            assertIsNode(key, TYPE_NODES);\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, TYPE_NODES);\n            return mapTypeNode(key, value, size);\n        };\n    }\n\n    if (keys.includes('optionTypeNode')) {\n        visitor.visitOptionType = function visitOptionType(node) {\n            const prefix = visit(this)(node.prefix);\n            if (prefix === null) return null;\n            assertIsNestedTypeNode(prefix, 'numberTypeNode');\n            const item = visit(this)(node.item);\n            if (item === null) return null;\n            assertIsNode(item, TYPE_NODES);\n            return optionTypeNode(item, { ...node, prefix });\n        };\n    }\n\n    if (keys.includes('zeroableOptionTypeNode')) {\n        visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {\n            const item = visit(this)(node.item);\n            if (item === null) return null;\n            assertIsNode(item, TYPE_NODES);\n            const zeroValue = node.zeroValue ? (visit(this)(node.zeroValue) ?? undefined) : undefined;\n            if (zeroValue) assertIsNode(zeroValue, 'constantValueNode');\n            return zeroableOptionTypeNode(item, zeroValue);\n        };\n    }\n\n    if (keys.includes('remainderOptionTypeNode')) {\n        visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {\n            const item = visit(this)(node.item);\n            if (item === null) return null;\n            assertIsNode(item, TYPE_NODES);\n            return remainderOptionTypeNode(item);\n        };\n    }\n\n    if (keys.includes('booleanTypeNode')) {\n        visitor.visitBooleanType = function visitBooleanType(node) {\n            const size = visit(this)(node.size);\n            if (size === null) return null;\n            assertIsNestedTypeNode(size, 'numberTypeNode');\n            return booleanTypeNode(size);\n        };\n    }\n\n    if (keys.includes('setTypeNode')) {\n        visitor.visitSetType = function visitSetType(node) {\n            const size = visit(this)(node.count);\n            if (size === null) return null;\n            assertIsNode(size, COUNT_NODES);\n            const item = visit(this)(node.item);\n            if (item === null) return null;\n            assertIsNode(item, TYPE_NODES);\n            return setTypeNode(item, size);\n        };\n    }\n\n    if (keys.includes('structTypeNode')) {\n        visitor.visitStructType = function visitStructType(node) {\n            const fields = node.fields.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('structFieldTypeNode'));\n            return structTypeNode(fields);\n        };\n    }\n\n    if (keys.includes('structFieldTypeNode')) {\n        visitor.visitStructFieldType = function visitStructFieldType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const defaultValue = node.defaultValue ? (visit(this)(node.defaultValue) ?? undefined) : undefined;\n            if (defaultValue) assertIsNode(defaultValue, VALUE_NODES);\n            return structFieldTypeNode({ ...node, defaultValue, type });\n        };\n    }\n\n    if (keys.includes('tupleTypeNode')) {\n        visitor.visitTupleType = function visitTupleType(node) {\n            const items = node.items.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(TYPE_NODES));\n            return tupleTypeNode(items);\n        };\n    }\n\n    if (keys.includes('amountTypeNode')) {\n        visitor.visitAmountType = function visitAmountType(node) {\n            const number = visit(this)(node.number);\n            if (number === null) return null;\n            assertIsNestedTypeNode(number, 'numberTypeNode');\n            return amountTypeNode(number, node.decimals, node.unit);\n        };\n    }\n\n    if (keys.includes('dateTimeTypeNode')) {\n        visitor.visitDateTimeType = function visitDateTimeType(node) {\n            const number = visit(this)(node.number);\n            if (number === null) return null;\n            assertIsNestedTypeNode(number, 'numberTypeNode');\n            return dateTimeTypeNode(number);\n        };\n    }\n\n    if (keys.includes('solAmountTypeNode')) {\n        visitor.visitSolAmountType = function visitSolAmountType(node) {\n            const number = visit(this)(node.number);\n            if (number === null) return null;\n            assertIsNestedTypeNode(number, 'numberTypeNode');\n            return solAmountTypeNode(number);\n        };\n    }\n\n    if (keys.includes('prefixedCountNode')) {\n        visitor.visitPrefixedCount = function visitPrefixedCount(node) {\n            const prefix = visit(this)(node.prefix);\n            if (prefix === null) return null;\n            assertIsNestedTypeNode(prefix, 'numberTypeNode');\n            return prefixedCountNode(prefix);\n        };\n    }\n\n    if (keys.includes('arrayValueNode')) {\n        visitor.visitArrayValue = function visitArrayValue(node) {\n            return arrayValueNode(node.items.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(VALUE_NODES)));\n        };\n    }\n\n    if (keys.includes('constantValueNode')) {\n        visitor.visitConstantValue = function visitConstantValue(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, VALUE_NODES);\n            return constantValueNode(type, value);\n        };\n    }\n\n    if (keys.includes('enumValueNode')) {\n        visitor.visitEnumValue = function visitEnumValue(node) {\n            const enumLink = visit(this)(node.enum);\n            if (enumLink === null) return null;\n            assertIsNode(enumLink, ['definedTypeLinkNode']);\n            const value = node.value ? (visit(this)(node.value) ?? undefined) : undefined;\n            if (value) assertIsNode(value, ['structValueNode', 'tupleValueNode']);\n            return enumValueNode(enumLink, node.variant, value);\n        };\n    }\n\n    if (keys.includes('mapValueNode')) {\n        visitor.visitMapValue = function visitMapValue(node) {\n            return mapValueNode(\n                node.entries.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('mapEntryValueNode')),\n            );\n        };\n    }\n\n    if (keys.includes('mapEntryValueNode')) {\n        visitor.visitMapEntryValue = function visitMapEntryValue(node) {\n            const key = visit(this)(node.key);\n            if (key === null) return null;\n            assertIsNode(key, VALUE_NODES);\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, VALUE_NODES);\n            return mapEntryValueNode(key, value);\n        };\n    }\n\n    if (keys.includes('setValueNode')) {\n        visitor.visitSetValue = function visitSetValue(node) {\n            return setValueNode(node.items.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(VALUE_NODES)));\n        };\n    }\n\n    if (keys.includes('someValueNode')) {\n        visitor.visitSomeValue = function visitSomeValue(node) {\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, VALUE_NODES);\n            return someValueNode(value);\n        };\n    }\n\n    if (keys.includes('structValueNode')) {\n        visitor.visitStructValue = function visitStructValue(node) {\n            return structValueNode(\n                node.fields.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('structFieldValueNode')),\n            );\n        };\n    }\n\n    if (keys.includes('structFieldValueNode')) {\n        visitor.visitStructFieldValue = function visitStructFieldValue(node) {\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, VALUE_NODES);\n            return structFieldValueNode(node.name, value);\n        };\n    }\n\n    if (keys.includes('tupleValueNode')) {\n        visitor.visitTupleValue = function visitTupleValue(node) {\n            return tupleValueNode(node.items.map(visit(this)).filter(removeNullAndAssertIsNodeFilter(VALUE_NODES)));\n        };\n    }\n\n    if (keys.includes('constantPdaSeedNode')) {\n        visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, [...VALUE_NODES, 'programIdValueNode']);\n            return constantPdaSeedNode(type, value);\n        };\n    }\n\n    if (keys.includes('variablePdaSeedNode')) {\n        visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return variablePdaSeedNode(node.name, type, node.docs);\n        };\n    }\n\n    if (keys.includes('resolverValueNode')) {\n        visitor.visitResolverValue = function visitResolverValue(node) {\n            const dependsOn = (node.dependsOn ?? [])\n                .map(visit(this))\n                .filter(removeNullAndAssertIsNodeFilter(['accountValueNode', 'argumentValueNode']));\n            return resolverValueNode(node.name, {\n                ...node,\n                dependsOn: dependsOn.length === 0 ? undefined : dependsOn,\n            });\n        };\n    }\n\n    if (keys.includes('conditionalValueNode')) {\n        visitor.visitConditionalValue = function visitConditionalValue(node) {\n            const condition = visit(this)(node.condition);\n            if (condition === null) return null;\n            assertIsNode(condition, ['resolverValueNode', 'accountValueNode', 'argumentValueNode']);\n            const value = node.value ? (visit(this)(node.value) ?? undefined) : undefined;\n            if (value) assertIsNode(value, VALUE_NODES);\n            const ifTrue = node.ifTrue ? (visit(this)(node.ifTrue) ?? undefined) : undefined;\n            if (ifTrue) assertIsNode(ifTrue, INSTRUCTION_INPUT_VALUE_NODES);\n            const ifFalse = node.ifFalse ? (visit(this)(node.ifFalse) ?? undefined) : undefined;\n            if (ifFalse) assertIsNode(ifFalse, INSTRUCTION_INPUT_VALUE_NODES);\n            if (!ifTrue && !ifFalse) return null;\n            return conditionalValueNode({ condition, ifFalse, ifTrue, value });\n        };\n    }\n\n    if (keys.includes('pdaValueNode')) {\n        visitor.visitPdaValue = function visitPdaValue(node) {\n            const pda = visit(this)(node.pda);\n            if (pda === null) return null;\n            assertIsNode(pda, ['pdaLinkNode', 'pdaNode']);\n            const seeds = node.seeds.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('pdaSeedValueNode'));\n            return pdaValueNode(pda, seeds);\n        };\n    }\n\n    if (keys.includes('pdaSeedValueNode')) {\n        visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {\n            const value = visit(this)(node.value);\n            if (value === null) return null;\n            assertIsNode(value, [...VALUE_NODES, 'accountValueNode', 'argumentValueNode']);\n            return pdaSeedValueNode(node.name, value);\n        };\n    }\n\n    if (keys.includes('fixedSizeTypeNode')) {\n        visitor.visitFixedSizeType = function visitFixedSizeType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return fixedSizeTypeNode(type, node.size);\n        };\n    }\n\n    if (keys.includes('sizePrefixTypeNode')) {\n        visitor.visitSizePrefixType = function visitSizePrefixType(node) {\n            const prefix = visit(this)(node.prefix);\n            if (prefix === null) return null;\n            assertIsNestedTypeNode(prefix, 'numberTypeNode');\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return sizePrefixTypeNode(type, prefix);\n        };\n    }\n\n    if (keys.includes('preOffsetTypeNode')) {\n        visitor.visitPreOffsetType = function visitPreOffsetType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return preOffsetTypeNode(type, node.offset, node.strategy);\n        };\n    }\n\n    if (keys.includes('postOffsetTypeNode')) {\n        visitor.visitPostOffsetType = function visitPostOffsetType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return postOffsetTypeNode(type, node.offset, node.strategy);\n        };\n    }\n\n    if (keys.includes('sentinelTypeNode')) {\n        visitor.visitSentinelType = function visitSentinelType(node) {\n            const sentinel = visit(this)(node.sentinel);\n            if (sentinel === null) return null;\n            assertIsNode(sentinel, 'constantValueNode');\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            return sentinelTypeNode(type, sentinel);\n        };\n    }\n\n    if (keys.includes('hiddenPrefixTypeNode')) {\n        visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const prefix = node.prefix.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('constantValueNode'));\n            if (prefix.length === 0) return type;\n            return hiddenPrefixTypeNode(type, prefix);\n        };\n    }\n\n    if (keys.includes('hiddenSuffixTypeNode')) {\n        visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {\n            const type = visit(this)(node.type);\n            if (type === null) return null;\n            assertIsNode(type, TYPE_NODES);\n            const suffix = node.suffix.map(visit(this)).filter(removeNullAndAssertIsNodeFilter('constantValueNode'));\n            if (suffix.length === 0) return type;\n            return hiddenSuffixTypeNode(type, suffix);\n        };\n    }\n\n    if (keys.includes('constantDiscriminatorNode')) {\n        visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {\n            const constant = visit(this)(node.constant);\n            if (constant === null) return null;\n            assertIsNode(constant, 'constantValueNode');\n            return constantDiscriminatorNode(constant, node.offset);\n        };\n    }\n\n    if (keys.includes('accountLinkNode')) {\n        visitor.visitAccountLink = function visitAccountLink(node) {\n            const program = node.program ? (visit(this)(node.program) ?? undefined) : undefined;\n            if (program) assertIsNode(program, 'programLinkNode');\n            return accountLinkNode(node.name, program);\n        };\n    }\n\n    if (keys.includes('definedTypeLinkNode')) {\n        visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {\n            const program = node.program ? (visit(this)(node.program) ?? undefined) : undefined;\n            if (program) assertIsNode(program, 'programLinkNode');\n            return definedTypeLinkNode(node.name, program);\n        };\n    }\n\n    if (keys.includes('instructionLinkNode')) {\n        visitor.visitInstructionLink = function visitInstructionLink(node) {\n            const program = node.program ? (visit(this)(node.program) ?? undefined) : undefined;\n            if (program) assertIsNode(program, 'programLinkNode');\n            return instructionLinkNode(node.name, program);\n        };\n    }\n\n    if (keys.includes('instructionAccountLinkNode')) {\n        visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {\n            const instruction = node.instruction ? (visit(this)(node.instruction) ?? undefined) : undefined;\n            if (instruction) assertIsNode(instruction, 'instructionLinkNode');\n            return instructionAccountLinkNode(node.name, instruction);\n        };\n    }\n\n    if (keys.includes('instructionArgumentLinkNode')) {\n        visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {\n            const instruction = node.instruction ? (visit(this)(node.instruction) ?? undefined) : undefined;\n            if (instruction) assertIsNode(instruction, 'instructionLinkNode');\n            return instructionArgumentLinkNode(node.name, instruction);\n        };\n    }\n\n    if (keys.includes('pdaLinkNode')) {\n        visitor.visitPdaLink = function visitPdaLink(node) {\n            const program = node.program ? (visit(this)(node.program) ?? undefined) : undefined;\n            if (program) assertIsNode(program, 'programLinkNode');\n            return pdaLinkNode(node.name, program);\n        };\n    }\n\n    return visitor as Visitor<Node, TNodeKind>;\n}\n","import { Node, NodeKind, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nimport { getVisitFunctionName, Visitor } from './visitor';\n\nexport function staticVisitor<TReturn, TNodeKind extends NodeKind = NodeKind>(\n    fn: (node: Node) => TReturn,\n    options: { keys?: TNodeKind[] } = {},\n): Visitor<TReturn, TNodeKind> {\n    const keys = options.keys ?? (REGISTERED_NODE_KINDS as TNodeKind[]);\n    const visitor = {} as Visitor<TReturn>;\n    keys.forEach(key => {\n        visitor[getVisitFunctionName(key)] = fn.bind(visitor);\n    });\n    return visitor;\n}\n","import { CODAMA_ERROR__UNRECOGNIZED_NODE_KIND, CodamaError } from '@codama/errors';\nimport { type GetNodeFromKind, type Node, type NodeKind, pascalCase, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nexport type Visitor<TReturn, TNodeKind extends NodeKind = NodeKind> = {\n    [K in TNodeKind as GetVisitorFunctionName<K>]: (node: GetNodeFromKind<K>) => TReturn;\n};\n\nexport type GetVisitorFunctionName<T extends Node['kind']> = T extends `${infer TWithoutNode}Node`\n    ? `visit${Capitalize<TWithoutNode>}`\n    : never;\n\nexport function visit<TReturn, TNode extends Node>(node: TNode, visitor: Visitor<TReturn, TNode['kind']>): TReturn {\n    const key = getVisitFunctionName(node.kind) as GetVisitorFunctionName<TNode['kind']>;\n    return (visitor[key] as (typeof visitor)[typeof key] & ((node: TNode) => TReturn))(node);\n}\n\nexport function visitOrElse<TReturn, TNode extends Node, TNodeKind extends NodeKind>(\n    node: TNode,\n    visitor: Visitor<TReturn, TNodeKind>,\n    fallback: (node: TNode) => TReturn,\n): TReturn {\n    const key = getVisitFunctionName<TNode['kind']>(node.kind);\n    return (key in visitor ? (visitor[key] as (node: TNode) => TReturn) : fallback)(node);\n}\n\nexport function getVisitFunctionName<TNodeKind extends NodeKind>(nodeKind: TNodeKind) {\n    if (!REGISTERED_NODE_KINDS.includes(nodeKind)) {\n        throw new CodamaError(CODAMA_ERROR__UNRECOGNIZED_NODE_KIND, { kind: nodeKind });\n    }\n\n    return `visit${pascalCase(nodeKind.slice(0, -4))}` as GetVisitorFunctionName<TNodeKind>;\n}\n","import { Node, NodeKind, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nimport { getVisitFunctionName, GetVisitorFunctionName, Visitor } from './visitor';\n\nexport type VisitorInterceptor<TReturn> = <TNode extends Node>(node: TNode, next: (node: TNode) => TReturn) => TReturn;\n\nexport function interceptVisitor<TReturn, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturn, TNodeKind>,\n    interceptor: VisitorInterceptor<TReturn>,\n): Visitor<TReturn, TNodeKind> {\n    const registeredVisitFunctions = REGISTERED_NODE_KINDS.map(getVisitFunctionName);\n\n    return Object.fromEntries(\n        Object.keys(visitor).flatMap(key => {\n            const castedKey = key as GetVisitorFunctionName<TNodeKind>;\n            if (!registeredVisitFunctions.includes(castedKey)) {\n                return [];\n            }\n\n            return [\n                [\n                    castedKey,\n                    function interceptedVisitNode<TNode extends Node>(this: Visitor<TReturn, TNodeKind>, node: TNode) {\n                        const baseFunction = visitor[castedKey] as (node: TNode) => TReturn;\n                        return interceptor<TNode>(node, baseFunction.bind(this));\n                    },\n                ],\n            ];\n        }),\n    ) as Visitor<TReturn, TNodeKind>;\n}\n","import { camelCase, CamelCaseString, Node } from '@codama/nodes';\n\nimport { NodePath } from './NodePath';\n\nexport type NodeSelector = NodeSelectorFunction | NodeSelectorPath;\n\n/**\n * A string that can be used to select a node in a Codama tree.\n * - `*` matches any node.\n * - `someText` matches the name of a node, if any.\n * - `[someNode]` matches a node of the given kind.\n * - `[someNode|someOtherNode]` matches a node with any of the given kind.\n * - `[someNode]someText` matches both the kind and the name of a node.\n * - `a.b.c` matches a node `c` such that its ancestors contains `a` and `b` in order (but not necessarily subsequent).\n */\nexport type NodeSelectorPath = string;\n\nexport type NodeSelectorFunction = (path: NodePath) => boolean;\n\nexport const getNodeSelectorFunction = (selector: NodeSelector): NodeSelectorFunction => {\n    if (typeof selector === 'function') return selector;\n\n    const checkNode = (node: Node, nodeSelector: string): boolean => {\n        if (nodeSelector === '*') return true;\n        const matches = nodeSelector.match(/^(?:\\[([^\\]]+)\\])?(.*)?$/);\n        if (!matches) return false;\n        const [, kinds, name] = matches;\n\n        // Check kinds.\n        const kindArray = kinds ? kinds.split('|').map(camelCase) : [];\n        if (kindArray.length > 0 && !kindArray.includes(node.kind as CamelCaseString)) {\n            return false;\n        }\n\n        // Check names.\n        if (name && (!('name' in node) || camelCase(name) !== node.name)) {\n            return false;\n        }\n\n        return true;\n    };\n\n    const checkPath = (path: Node[], nodeSelectors: string[]): boolean => {\n        if (nodeSelectors.length === 0) return true;\n        if (path.length === 0) return false;\n        const lastNode = path.pop() as Node;\n        const lastNodeSelector = nodeSelectors.pop() as string;\n        return checkNode(lastNode, lastNodeSelector)\n            ? checkPath(path, nodeSelectors)\n            : checkPath(path, [...nodeSelectors, lastNodeSelector]);\n    };\n\n    const checkInitialPath = (path: Node[], nodeSelectors: string[]): boolean => {\n        if (nodeSelectors.length === 0 || path.length === 0) return false;\n        const lastNode = path.pop() as Node;\n        const lastNodeSelector = nodeSelectors.pop() as string;\n        return checkNode(lastNode, lastNodeSelector) && checkPath(path, nodeSelectors);\n    };\n\n    const nodeSelectors = selector.split('.');\n    return path => checkInitialPath([...path], [...nodeSelectors]);\n};\n\nexport const getConjunctiveNodeSelectorFunction = (selector: NodeSelector | NodeSelector[]): NodeSelectorFunction => {\n    const selectors = Array.isArray(selector) ? selector : [selector];\n    const selectorFunctions = selectors.map(getNodeSelectorFunction);\n    return path => selectorFunctions.every(fn => fn(path));\n};\n","import { CODAMA_ERROR__VISITORS__CANNOT_REMOVE_LAST_PATH_IN_NODE_STACK, CodamaError } from '@codama/errors';\nimport { GetNodeFromKind, Node, NodeKind } from '@codama/nodes';\n\nimport { assertIsNodePath, NodePath, nodePathToString } from './NodePath';\n\ntype MutableNodePath = Node[];\n\nexport class NodeStack {\n    /**\n     * Contains all the node paths saved during the traversal.\n     *\n     * - The very last path is the current path which is being\n     *   used during the traversal.\n     * - The other paths can be used to save and restore the\n     *   current path when jumping to different parts of the tree.\n     *\n     * There must at least be one path in the stack at all times.\n     */\n    private readonly stack: [...MutableNodePath[], MutableNodePath];\n\n    constructor(...stack: readonly [...(readonly NodePath[]), NodePath] | readonly []) {\n        this.stack =\n            stack.length === 0\n                ? [[]]\n                : ([...stack.map(nodes => [...nodes])] as [...MutableNodePath[], MutableNodePath]);\n    }\n\n    private get currentPath(): MutableNodePath {\n        return this.stack[this.stack.length - 1];\n    }\n\n    public push(node: Node): void {\n        this.currentPath.push(node);\n    }\n\n    public pop(): Node | undefined {\n        return this.currentPath.pop();\n    }\n\n    public peek(): Node | undefined {\n        return this.isEmpty() ? undefined : this.currentPath[this.currentPath.length - 1];\n    }\n\n    public pushPath(newPath: NodePath = []): void {\n        this.stack.push([...newPath]);\n    }\n\n    public popPath(): NodePath {\n        if (this.stack.length <= 1) {\n            throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_REMOVE_LAST_PATH_IN_NODE_STACK, {\n                path: [...this.stack[this.stack.length - 1]],\n            });\n        }\n        return [...this.stack.pop()!];\n    }\n\n    public getPath(): NodePath;\n    public getPath<TKind extends NodeKind>(kind: TKind | TKind[]): NodePath<GetNodeFromKind<TKind>>;\n    public getPath<TKind extends NodeKind>(kind?: TKind | TKind[]): NodePath {\n        const path = [...this.currentPath];\n        if (kind) {\n            assertIsNodePath(path, kind);\n        }\n        return path;\n    }\n\n    public isEmpty(): boolean {\n        return this.currentPath.length === 0;\n    }\n\n    public clone(): NodeStack {\n        return new NodeStack(...this.stack);\n    }\n\n    public toString(): string {\n        return nodePathToString(this.getPath());\n    }\n}\n","import { assertIsNode, GetNodeFromKind, InstructionNode, isNode, Node, NodeKind, ProgramNode } from '@codama/nodes';\n\nexport type NodePath<TNode extends Node | undefined = undefined> = TNode extends undefined\n    ? readonly Node[]\n    : readonly [...(readonly Node[]), TNode];\n\nexport function getLastNodeFromPath<TNode extends Node>(path: NodePath<TNode>): TNode {\n    return path[path.length - 1] as TNode;\n}\n\nexport function findFirstNodeFromPath<TKind extends NodeKind>(\n    path: NodePath,\n    kind: TKind | TKind[],\n): GetNodeFromKind<TKind> | undefined {\n    return path.find(node => isNode(node, kind));\n}\n\nexport function findLastNodeFromPath<TKind extends NodeKind>(\n    path: NodePath,\n    kind: TKind | TKind[],\n): GetNodeFromKind<TKind> | undefined {\n    for (let index = path.length - 1; index >= 0; index--) {\n        const node = path[index];\n        if (isNode(node, kind)) return node;\n    }\n    return undefined;\n}\n\nexport function findProgramNodeFromPath(path: NodePath): ProgramNode | undefined {\n    return findLastNodeFromPath(path, 'programNode');\n}\n\nexport function findInstructionNodeFromPath(path: NodePath): InstructionNode | undefined {\n    return findLastNodeFromPath(path, 'instructionNode');\n}\n\nexport function getNodePathUntilLastNode<TKind extends NodeKind>(\n    path: NodePath,\n    kind: TKind | TKind[],\n): NodePath<GetNodeFromKind<TKind>> | undefined {\n    const lastIndex = (() => {\n        for (let index = path.length - 1; index >= 0; index--) {\n            const node = path[index];\n            if (isNode(node, kind)) return index;\n        }\n        return -1;\n    })();\n    if (lastIndex === -1) return undefined;\n    return path.slice(0, lastIndex + 1) as unknown as NodePath<GetNodeFromKind<TKind>>;\n}\n\nexport function isFilledNodePath(path: NodePath | null | undefined): path is NodePath<Node> {\n    return !!path && path.length > 0;\n}\n\nexport function isNodePath<TKind extends NodeKind>(\n    path: NodePath | null | undefined,\n    kind: TKind | TKind[],\n): path is NodePath<GetNodeFromKind<TKind>> {\n    return isNode(isFilledNodePath(path) ? getLastNodeFromPath<Node>(path) : null, kind);\n}\n\nexport function assertIsNodePath<TKind extends NodeKind>(\n    path: NodePath | null | undefined,\n    kind: TKind | TKind[],\n): asserts path is NodePath<GetNodeFromKind<TKind>> {\n    assertIsNode(isFilledNodePath(path) ? getLastNodeFromPath<Node>(path) : null, kind);\n}\n\nexport function nodePathToStringArray(path: NodePath): string[] {\n    return path.map((node): string => {\n        return 'name' in node ? `[${node.kind}]${node.name}` : `[${node.kind}]`;\n    });\n}\n\nexport function nodePathToString(path: NodePath): string {\n    return nodePathToStringArray(path).join(' > ');\n}\n","/**\n * Copied from @solana/functional.\n * @see https://github.com/anza-xyz/kit/blob/main/packages/functional/src/pipe.ts\n *\n * ---\n *\n * General pipe function.\n * Provide an initial value and a list of functions to pipe it through.\n *\n * Following common implementations of pipe functions that use TypeScript,\n * this function supports a maximum arity of 10 for type safety.\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```typescript\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n * @param init  The initial value\n * @param fns   Any number of functions to pipe the value through\n * @returns     The final value with all functions applied\n */\nexport function pipe<TInitial>(init: TInitial): TInitial;\nexport function pipe<TInitial, R1>(init: TInitial, init_r1: (init: TInitial) => R1): R1;\nexport function pipe<TInitial, R1, R2>(init: TInitial, init_r1: (init: TInitial) => R1, r1_r2: (r1: R1) => R2): R2;\nexport function pipe<TInitial, R1, R2, R3>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n): R3;\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n): R4;\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n): R5;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n): R6;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n): R7;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n): R8;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n): R9;\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    init: TInitial,\n    init_r1: (init: TInitial) => R1,\n    r1_r2: (r1: R1) => R2,\n    r2_r3: (r2: R2) => R3,\n    r3_r4: (r3: R3) => R4,\n    r4_r5: (r4: R4) => R5,\n    r5_r6: (r5: R5) => R6,\n    r6_r7: (r6: R6) => R7,\n    r7_r8: (r7: R7) => R8,\n    r8_r9: (r8: R8) => R9,\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { NodeKind } from '@codama/nodes';\n\nimport { interceptVisitor } from './interceptVisitor';\nimport { NodeStack } from './NodeStack';\nimport { Visitor } from './visitor';\n\nexport function recordNodeStackVisitor<TReturn, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturn, TNodeKind>,\n    stack: NodeStack,\n): Visitor<TReturn, TNodeKind> {\n    return interceptVisitor(visitor, (node, next) => {\n        stack.push(node);\n        const newNode = next(node);\n        stack.pop();\n        return newNode;\n    });\n}\n","import { Node, NodeKind } from '@codama/nodes';\n\nimport { identityVisitor } from './identityVisitor';\nimport { interceptVisitor } from './interceptVisitor';\nimport { getConjunctiveNodeSelectorFunction, NodeSelector } from './NodeSelector';\nimport { NodeStack } from './NodeStack';\nimport { pipe } from './pipe';\nimport { recordNodeStackVisitor } from './recordNodeStackVisitor';\nimport { Visitor } from './visitor';\n\nexport type BottomUpNodeTransformer = (node: Node, stack: NodeStack) => Node | null;\n\nexport type BottomUpNodeTransformerWithSelector = {\n    select: NodeSelector | NodeSelector[];\n    transform: BottomUpNodeTransformer;\n};\n\nexport function bottomUpTransformerVisitor<TNodeKind extends NodeKind = NodeKind>(\n    transformers: (BottomUpNodeTransformer | BottomUpNodeTransformerWithSelector)[],\n    options: { keys?: TNodeKind[]; stack?: NodeStack } = {},\n): Visitor<Node | null, TNodeKind> {\n    const transformerFunctions = transformers.map((transformer): BottomUpNodeTransformer => {\n        if (typeof transformer === 'function') return transformer;\n        return (node, stack) =>\n            getConjunctiveNodeSelectorFunction(transformer.select)(stack.getPath())\n                ? transformer.transform(node, stack)\n                : node;\n    });\n\n    const stack = options.stack ?? new NodeStack();\n    return pipe(\n        identityVisitor(options),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                return transformerFunctions.reduce(\n                    (acc, transformer) => (acc === null ? null : transformer(acc, stack)),\n                    next(node),\n                );\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n","import { GetNodeFromKind, NodeKind, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nimport { getVisitFunctionName, GetVisitorFunctionName, Visitor } from './visitor';\n\nexport function mapVisitor<TReturnFrom, TReturnTo, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturnFrom, TNodeKind>,\n    map: (from: TReturnFrom) => TReturnTo,\n): Visitor<TReturnTo, TNodeKind> {\n    const registeredVisitFunctions = REGISTERED_NODE_KINDS.map(getVisitFunctionName);\n    return Object.fromEntries(\n        Object.keys(visitor).flatMap(key => {\n            const castedKey = key as GetVisitorFunctionName<TNodeKind>;\n            if (!registeredVisitFunctions.includes(castedKey)) {\n                return [];\n            }\n\n            return [\n                [\n                    castedKey,\n                    (node: GetNodeFromKind<TNodeKind>) =>\n                        map((visitor[castedKey] as (node: GetNodeFromKind<TNodeKind>) => TReturnFrom)(node)),\n                ],\n            ];\n        }),\n    ) as unknown as Visitor<TReturnTo, TNodeKind>;\n}\n","import { NodeKind } from '@codama/nodes';\n\nimport { mapVisitor } from './mapVisitor';\nimport { Visitor } from './visitor';\n\nexport function consoleLogVisitor<TNodeKind extends NodeKind = NodeKind>(\n    visitor: Visitor<string, TNodeKind>,\n): Visitor<void, TNodeKind> {\n    return mapVisitor(visitor, value => console.log(value));\n}\n","import { Node, NodeKind } from '@codama/nodes';\n\nimport { identityVisitor } from './identityVisitor';\nimport { interceptVisitor } from './interceptVisitor';\nimport { getConjunctiveNodeSelectorFunction, NodeSelector } from './NodeSelector';\nimport { NodeStack } from './NodeStack';\nimport { pipe } from './pipe';\nimport { recordNodeStackVisitor } from './recordNodeStackVisitor';\nimport { Visitor } from './visitor';\n\nexport type TopDownNodeTransformer = <TNode extends Node>(node: TNode, stack: NodeStack) => TNode | null;\n\nexport type TopDownNodeTransformerWithSelector = {\n    select: NodeSelector | NodeSelector[];\n    transform: TopDownNodeTransformer;\n};\n\nexport function topDownTransformerVisitor<TNodeKind extends NodeKind = NodeKind>(\n    transformers: (TopDownNodeTransformer | TopDownNodeTransformerWithSelector)[],\n    options: { keys?: TNodeKind[]; stack?: NodeStack } = {},\n): Visitor<Node | null, TNodeKind> {\n    const transformerFunctions = transformers.map((transformer): TopDownNodeTransformer => {\n        if (typeof transformer === 'function') return transformer;\n        return (node, stack) =>\n            getConjunctiveNodeSelectorFunction(transformer.select)(stack.getPath())\n                ? transformer.transform(node, stack)\n                : node;\n    });\n\n    const stack = options.stack ?? new NodeStack();\n    return pipe(\n        identityVisitor(options),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                const appliedNode = transformerFunctions.reduce(\n                    (acc, transformer) => (acc === null ? null : transformer(acc, stack)),\n                    node as Parameters<typeof next>[0] | null,\n                );\n                if (appliedNode === null) return null;\n                return next(appliedNode);\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n","import { NodeKind } from '@codama/nodes';\n\nimport { NodeSelector } from './NodeSelector';\nimport { TopDownNodeTransformerWithSelector, topDownTransformerVisitor } from './topDownTransformerVisitor';\n\nexport function deleteNodesVisitor<TNodeKind extends NodeKind = NodeKind>(\n    selectors: NodeSelector[],\n    options?: Parameters<typeof topDownTransformerVisitor<TNodeKind>>[1],\n) {\n    return topDownTransformerVisitor<TNodeKind>(\n        selectors.map(\n            (selector): TopDownNodeTransformerWithSelector => ({\n                select: selector,\n                transform: () => null,\n            }),\n        ),\n        options,\n    );\n}\n","import { CODAMA_ERROR__VISITORS__CANNOT_EXTEND_MISSING_VISIT_FUNCTION, CodamaError } from '@codama/errors';\nimport { GetNodeFromKind, Node, NodeKind, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nimport { getVisitFunctionName, GetVisitorFunctionName, Visitor } from './visitor';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype DontInfer<T> = T extends any ? T : never;\n\nexport type VisitorOverrideFunction<TReturn, TNodeKind extends NodeKind, TNode extends Node> = (\n    node: TNode,\n    scope: {\n        next: (node: TNode) => TReturn;\n        self: Visitor<TReturn, TNodeKind>;\n    },\n) => TReturn;\n\nexport type VisitorOverrides<TReturn, TNodeKind extends NodeKind> = {\n    [K in TNodeKind as GetVisitorFunctionName<K>]?: VisitorOverrideFunction<TReturn, TNodeKind, GetNodeFromKind<K>>;\n};\n\nexport function extendVisitor<TReturn, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturn, TNodeKind>,\n    overrides: DontInfer<VisitorOverrides<TReturn, TNodeKind>>,\n): Visitor<TReturn, TNodeKind> {\n    const registeredVisitFunctions = REGISTERED_NODE_KINDS.map(getVisitFunctionName);\n\n    const overriddenFunctions = Object.fromEntries(\n        Object.keys(overrides).flatMap(key => {\n            if (!(registeredVisitFunctions as string[]).includes(key)) {\n                return [];\n            }\n\n            const castedKey = key as GetVisitorFunctionName<TNodeKind>;\n\n            if (!visitor[castedKey]) {\n                throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_EXTEND_MISSING_VISIT_FUNCTION, {\n                    visitFunction: castedKey,\n                });\n            }\n\n            return [\n                [\n                    castedKey,\n                    function extendedVisitNode<TNode extends Node>(this: Visitor<TReturn, TNodeKind>, node: TNode) {\n                        const extendedFunction = overrides[castedKey] as VisitorOverrideFunction<\n                            TReturn,\n                            TNodeKind,\n                            TNode\n                        >;\n                        const nextFunction = visitor[castedKey] as unknown as (node: TNode) => TReturn;\n                        return extendedFunction.bind(this)(node, {\n                            next: nextFunction.bind(this),\n                            self: this,\n                        });\n                    },\n                ],\n            ];\n        }),\n    ) as Partial<Visitor<TReturn, TNodeKind>>;\n\n    return {\n        ...visitor,\n        ...overriddenFunctions,\n    };\n}\n","import { isNode, isScalarEnum, REGISTERED_TYPE_NODE_KINDS, RegisteredTypeNode } from '@codama/nodes';\n\nimport { extendVisitor } from './extendVisitor';\nimport { LinkableDictionary } from './LinkableDictionary';\nimport { mergeVisitor } from './mergeVisitor';\nimport { getLastNodeFromPath } from './NodePath';\nimport { NodeStack } from './NodeStack';\nimport { pipe } from './pipe';\nimport { recordNodeStackVisitor } from './recordNodeStackVisitor';\nimport { visit, Visitor } from './visitor';\n\nexport type ByteSizeVisitorKeys =\n    | RegisteredTypeNode['kind']\n    | 'accountNode'\n    | 'definedTypeLinkNode'\n    | 'definedTypeNode'\n    | 'instructionArgumentNode'\n    | 'instructionNode';\n\nexport function getByteSizeVisitor(\n    linkables: LinkableDictionary,\n    options: { stack?: NodeStack } = {},\n): Visitor<number | null, ByteSizeVisitorKeys> {\n    const stack = options.stack ?? new NodeStack();\n\n    const visitedDefinedTypes = new Map<string, number | null>();\n    const definedTypeStack: string[] = [];\n\n    const sumSizes = (values: (number | null)[]): number | null =>\n        values.reduce((all, one) => (all === null || one === null ? null : all + one), 0 as number | null);\n\n    const baseVisitor = mergeVisitor(\n        () => null as number | null,\n        (_, values) => sumSizes(values),\n        {\n            keys: [\n                ...REGISTERED_TYPE_NODE_KINDS,\n                'definedTypeLinkNode',\n                'definedTypeNode',\n                'accountNode',\n                'instructionNode',\n                'instructionArgumentNode',\n            ],\n        },\n    );\n\n    return pipe(\n        baseVisitor,\n        v =>\n            extendVisitor(v, {\n                visitAccount(node, { self }) {\n                    return visit(node.data, self);\n                },\n\n                visitArrayType(node, { self }) {\n                    if (!isNode(node.count, 'fixedCountNode')) return null;\n                    const fixedSize = node.count.value;\n                    const itemSize = visit(node.item, self);\n                    const arraySize = itemSize !== null ? itemSize * fixedSize : null;\n                    return fixedSize === 0 ? 0 : arraySize;\n                },\n\n                visitDefinedType(node, { self }) {\n                    if (visitedDefinedTypes.has(node.name)) {\n                        return visitedDefinedTypes.get(node.name)!;\n                    }\n                    definedTypeStack.push(node.name);\n                    const child = visit(node.type, self);\n                    definedTypeStack.pop();\n                    visitedDefinedTypes.set(node.name, child);\n                    return child;\n                },\n\n                visitDefinedTypeLink(node, { self }) {\n                    // Fetch the linked type and return null if not found.\n                    // The validator visitor will throw a proper error later on.\n                    const linkedDefinedPath = linkables.getPath(stack.getPath(node.kind));\n                    if (!linkedDefinedPath) return null;\n                    const linkedDefinedType = getLastNodeFromPath(linkedDefinedPath);\n\n                    // This prevents infinite recursion by using assuming\n                    // cyclic types don't have a fixed size.\n                    if (definedTypeStack.includes(linkedDefinedType.name)) {\n                        return null;\n                    }\n\n                    stack.pushPath(linkedDefinedPath);\n                    const result = visit(linkedDefinedType, self);\n                    stack.popPath();\n                    return result;\n                },\n\n                visitEnumEmptyVariantType() {\n                    return 0;\n                },\n\n                visitEnumType(node, { self }) {\n                    const prefix = visit(node.size, self) ?? 1;\n                    if (isScalarEnum(node)) return prefix;\n                    const variantSizes = node.variants.map(v => visit(v, self));\n                    const allVariantHaveTheSameFixedSize = variantSizes.every((one, _, all) => one === all[0]);\n                    return allVariantHaveTheSameFixedSize && variantSizes.length > 0 && variantSizes[0] !== null\n                        ? variantSizes[0] + prefix\n                        : null;\n                },\n\n                visitFixedSizeType(node) {\n                    return node.size;\n                },\n\n                visitInstruction(node, { self }) {\n                    return sumSizes(node.arguments.map(arg => visit(arg, self)));\n                },\n\n                visitInstructionArgument(node, { self }) {\n                    return visit(node.type, self);\n                },\n\n                visitNumberType(node) {\n                    if (node.format === 'shortU16') return null;\n                    return parseInt(node.format.slice(1), 10) / 8;\n                },\n\n                visitOptionType(node, { self }) {\n                    if (!node.fixed) return null;\n                    const prefixSize = visit(node.prefix, self) as number;\n                    const itemSize = visit(node.item, self);\n                    return itemSize !== null ? itemSize + prefixSize : null;\n                },\n\n                visitPublicKeyType() {\n                    return 32;\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n","import { getAllPrograms, Node, NodeKind, REGISTERED_NODE_KINDS } from '@codama/nodes';\n\nimport { staticVisitor } from './staticVisitor';\nimport { visit as baseVisit, Visitor } from './visitor';\n\nexport function mergeVisitor<TReturn, TNodeKind extends NodeKind = NodeKind>(\n    leafValue: (node: Node) => TReturn,\n    merge: (node: Node, values: TReturn[]) => TReturn,\n    options: { keys?: TNodeKind[] } = {},\n): Visitor<TReturn, TNodeKind> {\n    const keys: NodeKind[] = options.keys ?? REGISTERED_NODE_KINDS;\n    const visitor = staticVisitor(leafValue, { keys }) as Visitor<TReturn>;\n    const visit =\n        (v: Visitor<TReturn>) =>\n        (node: Node): TReturn[] =>\n            keys.includes(node.kind) ? [baseVisit(node, v)] : [];\n\n    if (keys.includes('rootNode')) {\n        visitor.visitRoot = function visitRoot(node) {\n            return merge(node, getAllPrograms(node).flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('programNode')) {\n        visitor.visitProgram = function visitProgram(node) {\n            return merge(node, [\n                ...node.pdas.flatMap(visit(this)),\n                ...node.accounts.flatMap(visit(this)),\n                ...node.instructions.flatMap(visit(this)),\n                ...node.definedTypes.flatMap(visit(this)),\n                ...node.errors.flatMap(visit(this)),\n            ]);\n        };\n    }\n\n    if (keys.includes('pdaNode')) {\n        visitor.visitPda = function visitPda(node) {\n            return merge(node, node.seeds.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('accountNode')) {\n        visitor.visitAccount = function visitAccount(node) {\n            return merge(node, [\n                ...visit(this)(node.data),\n                ...(node.pda ? visit(this)(node.pda) : []),\n                ...(node.discriminators ?? []).flatMap(visit(this)),\n            ]);\n        };\n    }\n\n    if (keys.includes('instructionNode')) {\n        visitor.visitInstruction = function visitInstruction(node) {\n            return merge(node, [\n                ...node.accounts.flatMap(visit(this)),\n                ...node.arguments.flatMap(visit(this)),\n                ...(node.extraArguments ?? []).flatMap(visit(this)),\n                ...(node.remainingAccounts ?? []).flatMap(visit(this)),\n                ...(node.byteDeltas ?? []).flatMap(visit(this)),\n                ...(node.discriminators ?? []).flatMap(visit(this)),\n                ...(node.subInstructions ?? []).flatMap(visit(this)),\n            ]);\n        };\n    }\n\n    if (keys.includes('instructionAccountNode')) {\n        visitor.visitInstructionAccount = function visitInstructionAccount(node) {\n            return merge(node, [...(node.defaultValue ? visit(this)(node.defaultValue) : [])]);\n        };\n    }\n\n    if (keys.includes('instructionArgumentNode')) {\n        visitor.visitInstructionArgument = function visitInstructionArgument(node) {\n            return merge(node, [\n                ...visit(this)(node.type),\n                ...(node.defaultValue ? visit(this)(node.defaultValue) : []),\n            ]);\n        };\n    }\n\n    if (keys.includes('instructionRemainingAccountsNode')) {\n        visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {\n            return merge(node, visit(this)(node.value));\n        };\n    }\n\n    if (keys.includes('instructionByteDeltaNode')) {\n        visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {\n            return merge(node, visit(this)(node.value));\n        };\n    }\n\n    if (keys.includes('definedTypeNode')) {\n        visitor.visitDefinedType = function visitDefinedType(node) {\n            return merge(node, visit(this)(node.type));\n        };\n    }\n\n    if (keys.includes('arrayTypeNode')) {\n        visitor.visitArrayType = function visitArrayType(node) {\n            return merge(node, [...visit(this)(node.count), ...visit(this)(node.item)]);\n        };\n    }\n\n    if (keys.includes('enumTypeNode')) {\n        visitor.visitEnumType = function visitEnumType(node) {\n            return merge(node, [...visit(this)(node.size), ...node.variants.flatMap(visit(this))]);\n        };\n    }\n\n    if (keys.includes('enumStructVariantTypeNode')) {\n        visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {\n            return merge(node, visit(this)(node.struct));\n        };\n    }\n\n    if (keys.includes('enumTupleVariantTypeNode')) {\n        visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {\n            return merge(node, visit(this)(node.tuple));\n        };\n    }\n\n    if (keys.includes('mapTypeNode')) {\n        visitor.visitMapType = function visitMapType(node) {\n            return merge(node, [...visit(this)(node.count), ...visit(this)(node.key), ...visit(this)(node.value)]);\n        };\n    }\n\n    if (keys.includes('optionTypeNode')) {\n        visitor.visitOptionType = function visitOptionType(node) {\n            return merge(node, [...visit(this)(node.prefix), ...visit(this)(node.item)]);\n        };\n    }\n\n    if (keys.includes('zeroableOptionTypeNode')) {\n        visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {\n            return merge(node, [...visit(this)(node.item), ...(node.zeroValue ? visit(this)(node.zeroValue) : [])]);\n        };\n    }\n\n    if (keys.includes('remainderOptionTypeNode')) {\n        visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {\n            return merge(node, visit(this)(node.item));\n        };\n    }\n\n    if (keys.includes('booleanTypeNode')) {\n        visitor.visitBooleanType = function visitBooleanType(node) {\n            return merge(node, visit(this)(node.size));\n        };\n    }\n\n    if (keys.includes('setTypeNode')) {\n        visitor.visitSetType = function visitSetType(node) {\n            return merge(node, [...visit(this)(node.count), ...visit(this)(node.item)]);\n        };\n    }\n\n    if (keys.includes('structTypeNode')) {\n        visitor.visitStructType = function visitStructType(node) {\n            return merge(node, node.fields.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('structFieldTypeNode')) {\n        visitor.visitStructFieldType = function visitStructFieldType(node) {\n            return merge(node, [\n                ...visit(this)(node.type),\n                ...(node.defaultValue ? visit(this)(node.defaultValue) : []),\n            ]);\n        };\n    }\n\n    if (keys.includes('tupleTypeNode')) {\n        visitor.visitTupleType = function visitTupleType(node) {\n            return merge(node, node.items.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('amountTypeNode')) {\n        visitor.visitAmountType = function visitAmountType(node) {\n            return merge(node, visit(this)(node.number));\n        };\n    }\n\n    if (keys.includes('dateTimeTypeNode')) {\n        visitor.visitDateTimeType = function visitDateTimeType(node) {\n            return merge(node, visit(this)(node.number));\n        };\n    }\n\n    if (keys.includes('solAmountTypeNode')) {\n        visitor.visitSolAmountType = function visitSolAmountType(node) {\n            return merge(node, visit(this)(node.number));\n        };\n    }\n\n    if (keys.includes('prefixedCountNode')) {\n        visitor.visitPrefixedCount = function visitPrefixedCount(node) {\n            return merge(node, visit(this)(node.prefix));\n        };\n    }\n\n    if (keys.includes('arrayValueNode')) {\n        visitor.visitArrayValue = function visitArrayValue(node) {\n            return merge(node, node.items.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('constantValueNode')) {\n        visitor.visitConstantValue = function visitConstantValue(node) {\n            return merge(node, [...visit(this)(node.type), ...visit(this)(node.value)]);\n        };\n    }\n\n    if (keys.includes('enumValueNode')) {\n        visitor.visitEnumValue = function visitEnumValue(node) {\n            return merge(node, [...visit(this)(node.enum), ...(node.value ? visit(this)(node.value) : [])]);\n        };\n    }\n\n    if (keys.includes('mapValueNode')) {\n        visitor.visitMapValue = function visitMapValue(node) {\n            return merge(node, node.entries.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('mapEntryValueNode')) {\n        visitor.visitMapEntryValue = function visitMapEntryValue(node) {\n            return merge(node, [...visit(this)(node.key), ...visit(this)(node.value)]);\n        };\n    }\n\n    if (keys.includes('setValueNode')) {\n        visitor.visitSetValue = function visitSetValue(node) {\n            return merge(node, node.items.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('someValueNode')) {\n        visitor.visitSomeValue = function visitSomeValue(node) {\n            return merge(node, visit(this)(node.value));\n        };\n    }\n\n    if (keys.includes('structValueNode')) {\n        visitor.visitStructValue = function visitStructValue(node) {\n            return merge(node, node.fields.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('structFieldValueNode')) {\n        visitor.visitStructFieldValue = function visitStructFieldValue(node) {\n            return merge(node, visit(this)(node.value));\n        };\n    }\n\n    if (keys.includes('tupleValueNode')) {\n        visitor.visitTupleValue = function visitTupleValue(node) {\n            return merge(node, node.items.flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('constantPdaSeedNode')) {\n        visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {\n            return merge(node, [...visit(this)(node.type), ...visit(this)(node.value)]);\n        };\n    }\n\n    if (keys.includes('variablePdaSeedNode')) {\n        visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {\n            return merge(node, visit(this)(node.type));\n        };\n    }\n\n    if (keys.includes('resolverValueNode')) {\n        visitor.visitResolverValue = function visitResolverValue(node) {\n            return merge(node, (node.dependsOn ?? []).flatMap(visit(this)));\n        };\n    }\n\n    if (keys.includes('conditionalValueNode')) {\n        visitor.visitConditionalValue = function visitConditionalValue(node) {\n            return merge(node, [\n                ...visit(this)(node.condition),\n                ...(node.value ? visit(this)(node.value) : []),\n                ...(node.ifTrue ? visit(this)(node.ifTrue) : []),\n                ...(node.ifFalse ? visit(this)(node.ifFalse) : []),\n            ]);\n        };\n    }\n\n    if (keys.includes('pdaValueNode')) {\n        visitor.visitPdaValue = function visitPdaValue(node) {\n            return merge(node, [...visit(this)(node.pda), ...node.seeds.flatMap(visit(this))]);\n        };\n    }\n\n    if (keys.includes('pdaSeedValueNode')) {\n        visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {\n            return merge(node, visit(this)(node.value));\n        };\n    }\n\n    if (keys.includes('fixedSizeTypeNode')) {\n        visitor.visitFixedSizeType = function visitFixedSizeType(node) {\n            return merge(node, visit(this)(node.type));\n        };\n    }\n\n    if (keys.includes('sizePrefixTypeNode')) {\n        visitor.visitSizePrefixType = function visitSizePrefixType(node) {\n            return merge(node, [...visit(this)(node.prefix), ...visit(this)(node.type)]);\n        };\n    }\n\n    if (keys.includes('preOffsetTypeNode')) {\n        visitor.visitPreOffsetType = function visitPreOffsetType(node) {\n            return merge(node, visit(this)(node.type));\n        };\n    }\n\n    if (keys.includes('postOffsetTypeNode')) {\n        visitor.visitPostOffsetType = function visitPostOffsetType(node) {\n            return merge(node, visit(this)(node.type));\n        };\n    }\n\n    if (keys.includes('sentinelTypeNode')) {\n        visitor.visitSentinelType = function visitSentinelType(node) {\n            return merge(node, [...visit(this)(node.sentinel), ...visit(this)(node.type)]);\n        };\n    }\n\n    if (keys.includes('hiddenPrefixTypeNode')) {\n        visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {\n            return merge(node, [...node.prefix.flatMap(visit(this)), ...visit(this)(node.type)]);\n        };\n    }\n\n    if (keys.includes('hiddenSuffixTypeNode')) {\n        visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {\n            return merge(node, [...visit(this)(node.type), ...node.suffix.flatMap(visit(this))]);\n        };\n    }\n\n    if (keys.includes('constantDiscriminatorNode')) {\n        visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {\n            return merge(node, visit(this)(node.constant));\n        };\n    }\n\n    if (keys.includes('accountLinkNode')) {\n        visitor.visitAccountLink = function visitAccountLink(node) {\n            return merge(node, node.program ? visit(this)(node.program) : []);\n        };\n    }\n\n    if (keys.includes('definedTypeLinkNode')) {\n        visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {\n            return merge(node, node.program ? visit(this)(node.program) : []);\n        };\n    }\n\n    if (keys.includes('instructionLinkNode')) {\n        visitor.visitInstructionLink = function visitInstructionLink(node) {\n            return merge(node, node.program ? visit(this)(node.program) : []);\n        };\n    }\n\n    if (keys.includes('instructionAccountLinkNode')) {\n        visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {\n            return merge(node, node.instruction ? visit(this)(node.instruction) : []);\n        };\n    }\n\n    if (keys.includes('instructionArgumentLinkNode')) {\n        visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {\n            return merge(node, node.instruction ? visit(this)(node.instruction) : []);\n        };\n    }\n\n    if (keys.includes('pdaLinkNode')) {\n        visitor.visitPdaLink = function visitPdaLink(node) {\n            return merge(node, node.program ? visit(this)(node.program) : []);\n        };\n    }\n\n    return visitor as Visitor<TReturn, TNodeKind>;\n}\n","import { Node } from '@codama/nodes';\n\nimport { interceptVisitor } from './interceptVisitor';\nimport { mergeVisitor } from './mergeVisitor';\nimport { pipe } from './pipe';\nimport { Visitor } from './visitor';\n\nexport function getDebugStringVisitor(options: { indent?: boolean; indentSeparator?: string } = {}): Visitor<string> {\n    const indent = options.indent ?? false;\n    const indentSeparator = options.indentSeparator ?? '|   ';\n    let stackLevel = -1;\n\n    return pipe(\n        mergeVisitor<string>(\n            node => {\n                const details = getNodeDetails(node).join('.');\n                if (indent) {\n                    return `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ''}`;\n                }\n                return `${node.kind}${details ? `[${details}]` : ''}`;\n            },\n            (node, values) => {\n                const details = getNodeDetails(node).join('.');\n                if (indent) {\n                    return [\n                        `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ''}`,\n                        ...values,\n                    ].join('\\n');\n                }\n                return `${node.kind}${details ? `[${details}]` : ''}(${values.join(', ')})`;\n            },\n        ),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                stackLevel += 1;\n                const newNode = next(node);\n                stackLevel -= 1;\n                return newNode;\n            }),\n    );\n}\n\nfunction getNodeDetails(node: Node): string[] {\n    switch (node.kind) {\n        case 'programNode':\n            return [node.name, node.publicKey];\n        case 'instructionAccountNode':\n            return [\n                node.name,\n                ...(node.isWritable ? ['writable'] : []),\n                ...(node.isSigner === true ? ['signer'] : []),\n                ...(node.isSigner === 'either' ? ['optionalSigner'] : []),\n                ...(node.isOptional ? ['optional'] : []),\n            ];\n        case 'instructionRemainingAccountsNode':\n            return [\n                ...(node.isOptional ? ['optional'] : []),\n                ...(node.isWritable ? ['writable'] : []),\n                ...(node.isSigner === true ? ['signer'] : []),\n                ...(node.isSigner === 'either' ? ['optionalSigner'] : []),\n            ];\n        case 'instructionByteDeltaNode':\n            return [...(node.subtract ? ['subtract'] : []), ...(node.withHeader ? ['withHeader'] : [])];\n        case 'errorNode':\n            return [node.code.toString(), node.name];\n        case 'accountLinkNode':\n        case 'definedTypeLinkNode':\n        case 'instructionAccountLinkNode':\n        case 'instructionArgumentLinkNode':\n        case 'instructionLinkNode':\n        case 'pdaLinkNode':\n        case 'programLinkNode':\n            return [node.name];\n        case 'numberTypeNode':\n            return [node.format, ...(node.endian === 'be' ? ['bigEndian'] : [])];\n        case 'amountTypeNode':\n            return [node.decimals.toString(), ...(node.unit ? [node.unit] : [])];\n        case 'stringTypeNode':\n            return [node.encoding];\n        case 'optionTypeNode':\n            return node.fixed ? ['fixed'] : [];\n        case 'fixedCountNode':\n            return [node.value.toString()];\n        case 'numberValueNode':\n            return [node.number.toString()];\n        case 'stringValueNode':\n            return [node.string];\n        case 'booleanValueNode':\n            return [node.boolean ? 'true' : 'false'];\n        case 'bytesValueNode':\n            return [node.encoding, node.data];\n        case 'publicKeyValueNode':\n            return [...(node.identifier ? [`${node.identifier}`] : []), node.publicKey];\n        case 'enumValueNode':\n            return [node.variant];\n        case 'resolverValueNode':\n            return [node.name];\n        case 'constantDiscriminatorNode':\n            return [...(node.offset > 0 ? [`offset:${node.offset}`] : [])];\n        case 'fieldDiscriminatorNode':\n            return [node.name, ...(node.offset > 0 ? [`offset:${node.offset}`] : [])];\n        case 'sizeDiscriminatorNode':\n            return [node.size.toString()];\n        case 'fixedSizeTypeNode':\n            return [node.size.toString()];\n        case 'preOffsetTypeNode':\n            return [node.offset.toString(), node.strategy ?? 'relative'];\n        case 'postOffsetTypeNode':\n            return [node.offset.toString(), node.strategy ?? 'relative'];\n        default:\n            return 'name' in node ? [node.name] : [];\n    }\n}\n","/* eslint-disable no-case-declarations */\nimport {\n    CODAMA_ERROR__VISITORS__CANNOT_USE_OPTIONAL_ACCOUNT_AS_PDA_SEED_VALUE,\n    CODAMA_ERROR__VISITORS__CYCLIC_DEPENDENCY_DETECTED_WHEN_RESOLVING_INSTRUCTION_DEFAULT_VALUES,\n    CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY,\n    CodamaError,\n} from '@codama/errors';\nimport {\n    AccountValueNode,\n    accountValueNode,\n    ArgumentValueNode,\n    argumentValueNode,\n    CamelCaseString,\n    getAllInstructionArguments,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionInputValueNode,\n    InstructionNode,\n    isNode,\n    VALUE_NODES,\n} from '@codama/nodes';\n\nimport { singleNodeVisitor } from './singleNodeVisitor';\nimport { Visitor } from './visitor';\n\nexport type ResolvedInstructionInput = ResolvedInstructionAccount | ResolvedInstructionArgument;\nexport type ResolvedInstructionAccount = InstructionAccountNode & {\n    dependsOn: InstructionDependency[];\n    isPda: boolean;\n    resolvedIsOptional: boolean;\n    resolvedIsSigner: boolean | 'either';\n};\nexport type ResolvedInstructionArgument = InstructionArgumentNode & {\n    dependsOn: InstructionDependency[];\n};\ntype InstructionInput = InstructionAccountNode | InstructionArgumentNode;\ntype InstructionDependency = AccountValueNode | ArgumentValueNode;\n\nexport function getResolvedInstructionInputsVisitor(\n    options: { includeDataArgumentValueNodes?: boolean } = {},\n): Visitor<ResolvedInstructionInput[], 'instructionNode'> {\n    const includeDataArgumentValueNodes = options.includeDataArgumentValueNodes ?? false;\n    let stack: InstructionInput[] = [];\n    let resolved: ResolvedInstructionInput[] = [];\n    let visitedAccounts = new Map<string, ResolvedInstructionAccount>();\n    let visitedArgs = new Map<string, ResolvedInstructionArgument>();\n\n    function resolveInstructionInput(instruction: InstructionNode, input: InstructionInput): void {\n        // Ensure we don't visit the same input twice.\n        if (\n            (isNode(input, 'instructionAccountNode') && visitedAccounts.has(input.name)) ||\n            (isNode(input, 'instructionArgumentNode') && visitedArgs.has(input.name))\n        ) {\n            return;\n        }\n\n        // Ensure we don't have a circular dependency.\n        const isCircular = stack.some(({ kind, name }) => kind === input.kind && name === input.name);\n        if (isCircular) {\n            const cycle = [...stack, input];\n            throw new CodamaError(\n                CODAMA_ERROR__VISITORS__CYCLIC_DEPENDENCY_DETECTED_WHEN_RESOLVING_INSTRUCTION_DEFAULT_VALUES,\n                {\n                    cycle,\n                    formattedCycle: cycle.map(({ name }) => name).join(' -> '),\n                    instruction,\n                    instructionName: instruction.name,\n                },\n            );\n        }\n\n        // Resolve whilst keeping track of the stack.\n        stack.push(input);\n        const localResolved =\n            input.kind === 'instructionAccountNode'\n                ? resolveInstructionAccount(instruction, input)\n                : resolveInstructionArgument(instruction, input);\n        stack.pop();\n\n        // Store the resolved input.\n        resolved.push(localResolved);\n        if (localResolved.kind === 'instructionAccountNode') {\n            visitedAccounts.set(input.name, localResolved);\n        } else {\n            visitedArgs.set(input.name, localResolved);\n        }\n    }\n\n    function resolveInstructionAccount(\n        instruction: InstructionNode,\n        account: InstructionAccountNode,\n    ): ResolvedInstructionAccount {\n        // Find and visit dependencies first.\n        const dependsOn = getInstructionDependencies(account);\n        resolveInstructionDependencies(instruction, account, dependsOn);\n\n        const localResolved: ResolvedInstructionAccount = {\n            ...account,\n            dependsOn,\n            isPda: getAllInstructionArguments(instruction).some(\n                argument =>\n                    isNode(argument.defaultValue, 'accountBumpValueNode') &&\n                    argument.defaultValue.name === account.name,\n            ),\n            resolvedIsOptional: !!account.isOptional,\n            resolvedIsSigner: account.isSigner,\n        };\n\n        switch (localResolved.defaultValue?.kind) {\n            case 'accountValueNode':\n                const defaultAccount = visitedAccounts.get(localResolved.defaultValue.name)!;\n                const resolvedIsPublicKey = account.isSigner === false && defaultAccount.isSigner === false;\n                const resolvedIsSigner = account.isSigner === true && defaultAccount.isSigner === true;\n                const resolvedIsOptionalSigner = !resolvedIsPublicKey && !resolvedIsSigner;\n                localResolved.resolvedIsSigner = resolvedIsOptionalSigner ? 'either' : resolvedIsSigner;\n                localResolved.resolvedIsOptional = !!defaultAccount.isOptional;\n                break;\n            case 'publicKeyValueNode':\n            case 'programLinkNode':\n            case 'programIdValueNode':\n                localResolved.resolvedIsSigner = account.isSigner === false ? false : 'either';\n                localResolved.resolvedIsOptional = false;\n                break;\n            case 'pdaValueNode':\n                localResolved.resolvedIsSigner = account.isSigner === false ? false : 'either';\n                localResolved.resolvedIsOptional = false;\n                const { seeds } = localResolved.defaultValue;\n                seeds.forEach(seed => {\n                    if (!isNode(seed.value, 'accountValueNode')) return;\n                    const dependency = visitedAccounts.get(seed.value.name)!;\n                    if (dependency.resolvedIsOptional) {\n                        throw new CodamaError(CODAMA_ERROR__VISITORS__CANNOT_USE_OPTIONAL_ACCOUNT_AS_PDA_SEED_VALUE, {\n                            instruction: instruction,\n                            instructionAccount: account,\n                            instructionAccountName: account.name,\n                            instructionName: instruction.name,\n                            seed,\n                            seedName: seed.name,\n                            seedValueName: seed.value.name,\n                        });\n                    }\n                });\n                break;\n            case 'identityValueNode':\n            case 'payerValueNode':\n            case 'resolverValueNode':\n                localResolved.resolvedIsOptional = false;\n                break;\n            default:\n                break;\n        }\n\n        return localResolved;\n    }\n\n    function resolveInstructionArgument(\n        instruction: InstructionNode,\n        argument: InstructionArgumentNode,\n    ): ResolvedInstructionArgument {\n        // Find and visit dependencies first.\n        const dependsOn = getInstructionDependencies(argument);\n        resolveInstructionDependencies(instruction, argument, dependsOn);\n\n        return { ...argument, dependsOn };\n    }\n\n    function resolveInstructionDependencies(\n        instruction: InstructionNode,\n        parent: InstructionInput,\n        dependencies: InstructionDependency[],\n    ): void {\n        dependencies.forEach(dependency => {\n            let input: InstructionInput | null = null;\n            if (isNode(dependency, 'accountValueNode')) {\n                const dependencyAccount = instruction.accounts.find(a => a.name === dependency.name);\n                if (!dependencyAccount) {\n                    throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {\n                        dependency,\n                        dependencyKind: dependency.kind,\n                        dependencyName: dependency.name,\n                        instruction,\n                        instructionName: instruction.name,\n                        parent,\n                        parentKind: parent.kind,\n                        parentName: parent.name,\n                    });\n                }\n                input = { ...dependencyAccount };\n            } else if (isNode(dependency, 'argumentValueNode')) {\n                const dependencyArgument = getAllInstructionArguments(instruction).find(\n                    a => a.name === dependency.name,\n                );\n                if (!dependencyArgument) {\n                    throw new CodamaError(CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {\n                        dependency,\n                        dependencyKind: dependency.kind,\n                        dependencyName: dependency.name,\n                        instruction,\n                        instructionName: instruction.name,\n                        parent,\n                        parentKind: parent.kind,\n                        parentName: parent.name,\n                    });\n                }\n                input = { ...dependencyArgument };\n            }\n            if (input) {\n                resolveInstructionInput(instruction, input);\n            }\n        });\n    }\n\n    return singleNodeVisitor('instructionNode', (node): ResolvedInstructionInput[] => {\n        // Ensure we always start with a clean slate.\n        stack = [];\n        resolved = [];\n        visitedAccounts = new Map();\n        visitedArgs = new Map();\n\n        const inputs: InstructionInput[] = [\n            ...node.accounts,\n            ...node.arguments.filter(a => {\n                if (includeDataArgumentValueNodes) return a.defaultValue;\n                return a.defaultValue && !isNode(a.defaultValue, VALUE_NODES);\n            }),\n            ...(node.extraArguments ?? []).filter(a => a.defaultValue),\n        ];\n\n        // Visit all instruction accounts.\n        inputs.forEach(input => {\n            resolveInstructionInput(node, input);\n        });\n\n        return resolved;\n    });\n}\n\nexport function deduplicateInstructionDependencies(dependencies: InstructionDependency[]): InstructionDependency[] {\n    const accounts = new Map<CamelCaseString, InstructionDependency>();\n    const args = new Map<CamelCaseString, InstructionDependency>();\n    dependencies.forEach(dependency => {\n        if (isNode(dependency, 'accountValueNode')) {\n            accounts.set(dependency.name, dependency);\n        } else if (isNode(dependency, 'argumentValueNode')) {\n            args.set(dependency.name, dependency);\n        }\n    });\n    return [...accounts.values(), ...args.values()];\n}\n\nexport function getInstructionDependencies(input: InstructionInput | InstructionNode): InstructionDependency[] {\n    if (isNode(input, 'instructionNode')) {\n        return deduplicateInstructionDependencies([\n            ...input.accounts.flatMap(getInstructionDependencies),\n            ...input.arguments.flatMap(getInstructionDependencies),\n            ...(input.extraArguments ?? []).flatMap(getInstructionDependencies),\n        ]);\n    }\n\n    if (!input.defaultValue) return [];\n\n    const getNestedDependencies = (defaultValue: InstructionInputValueNode | undefined): InstructionDependency[] => {\n        if (!defaultValue) return [];\n        return getInstructionDependencies({ ...input, defaultValue });\n    };\n\n    if (isNode(input.defaultValue, ['accountValueNode', 'accountBumpValueNode'])) {\n        return [accountValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, ['argumentValueNode'])) {\n        return [argumentValueNode(input.defaultValue.name)];\n    }\n\n    if (isNode(input.defaultValue, 'pdaValueNode')) {\n        const dependencies = new Map<CamelCaseString, InstructionDependency>();\n        input.defaultValue.seeds.forEach(seed => {\n            if (isNode(seed.value, ['accountValueNode', 'argumentValueNode'])) {\n                dependencies.set(seed.value.name, { ...seed.value });\n            }\n        });\n        return [...dependencies.values()];\n    }\n\n    if (isNode(input.defaultValue, 'resolverValueNode')) {\n        return input.defaultValue.dependsOn ?? [];\n    }\n\n    if (isNode(input.defaultValue, 'conditionalValueNode')) {\n        return deduplicateInstructionDependencies([\n            ...getNestedDependencies(input.defaultValue.condition),\n            ...getNestedDependencies(input.defaultValue.ifTrue),\n            ...getNestedDependencies(input.defaultValue.ifFalse),\n        ]);\n    }\n\n    return [];\n}\n","import { GetNodeFromKind, NodeKind, RootNode } from '@codama/nodes';\n\nimport { getVisitFunctionName, GetVisitorFunctionName, Visitor } from './visitor';\n\nexport function singleNodeVisitor<TReturn, TNodeKey extends NodeKind = NodeKind>(\n    key: TNodeKey,\n    fn: (node: GetNodeFromKind<TNodeKey>) => TReturn,\n): Visitor<TReturn, TNodeKey> {\n    const visitor = {} as Visitor<TReturn, TNodeKey>;\n    visitor[getVisitFunctionName(key)] = fn as unknown as Visitor<TReturn, TNodeKey>[GetVisitorFunctionName<TNodeKey>];\n\n    return visitor;\n}\n\nexport function rootNodeVisitor<TReturn = RootNode>(fn: (node: RootNode) => TReturn) {\n    return singleNodeVisitor('rootNode', fn);\n}\n","import stringify from 'json-stable-stringify';\n\nimport { mapVisitor } from './mapVisitor';\nimport { removeDocsVisitor } from './removeDocsVisitor';\nimport { staticVisitor } from './staticVisitor';\nimport { Visitor } from './visitor';\n\nexport function getUniqueHashStringVisitor(options: { removeDocs?: boolean } = {}): Visitor<string> {\n    const removeDocs = options.removeDocs ?? false;\n    if (!removeDocs) {\n        return staticVisitor(node => stringify(node) as string);\n    }\n    return mapVisitor(removeDocsVisitor(), node => stringify(node) as string);\n}\n","import { Node, NodeKind } from '@codama/nodes';\n\nimport { identityVisitor } from './identityVisitor';\nimport { Visitor } from './visitor';\n\nexport function nonNullableIdentityVisitor<TNodeKind extends NodeKind = NodeKind>(\n    options: { keys?: TNodeKind[] } = {},\n): Visitor<Node, TNodeKind> {\n    return identityVisitor<TNodeKind>(options) as Visitor<Node, TNodeKind>;\n}\n","import { NodeKind } from '@codama/nodes';\n\nimport { interceptVisitor } from './interceptVisitor';\nimport { nonNullableIdentityVisitor } from './nonNullableIdentityVisitor';\n\nexport function removeDocsVisitor<TNodeKind extends NodeKind = NodeKind>(options: { keys?: TNodeKind[] } = {}) {\n    return interceptVisitor(nonNullableIdentityVisitor(options), (node, next) => {\n        if ('docs' in node) {\n            return next({ ...node, docs: [] });\n        }\n        return next(node);\n    });\n}\n","import type { NodeKind } from '@codama/nodes';\n\nimport { interceptVisitor, VisitorInterceptor } from './interceptVisitor';\nimport { Visitor } from './visitor';\n\nexport function interceptFirstVisitVisitor<TReturn, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturn, TNodeKind>,\n    interceptor: VisitorInterceptor<TReturn>,\n): Visitor<TReturn, TNodeKind> {\n    let isFirstVisit = true;\n\n    return interceptVisitor(visitor, (node, next) => {\n        try {\n            if (isFirstVisit) {\n                isFirstVisit = false;\n                const result = interceptor(node, next);\n                isFirstVisit = true;\n                return result;\n            }\n            return next(node);\n        } catch (error) {\n            isFirstVisit = true;\n            throw error;\n        }\n    });\n}\n","import { CODAMA_ERROR__LINKED_NODE_NOT_FOUND, CodamaError } from '@codama/errors';\nimport {\n    AccountNode,\n    CamelCaseString,\n    DefinedTypeNode,\n    InstructionAccountNode,\n    InstructionArgumentNode,\n    InstructionNode,\n    isNode,\n    LinkNode,\n    PdaNode,\n    ProgramNode,\n} from '@codama/nodes';\n\nimport {\n    findInstructionNodeFromPath,\n    findProgramNodeFromPath,\n    getLastNodeFromPath,\n    getNodePathUntilLastNode,\n    isNodePath,\n    NodePath,\n} from './NodePath';\n\nexport type LinkableNode =\n    | AccountNode\n    | DefinedTypeNode\n    | InstructionAccountNode\n    | InstructionArgumentNode\n    | InstructionNode\n    | PdaNode\n    | ProgramNode;\n\nexport const LINKABLE_NODES: LinkableNode['kind'][] = [\n    'accountNode',\n    'definedTypeNode',\n    'instructionAccountNode',\n    'instructionArgumentNode',\n    'instructionNode',\n    'pdaNode',\n    'programNode',\n];\n\nexport type GetLinkableFromLinkNode<TLinkNode extends LinkNode> = {\n    accountLinkNode: AccountNode;\n    definedTypeLinkNode: DefinedTypeNode;\n    instructionAccountLinkNode: InstructionAccountNode;\n    instructionArgumentLinkNode: InstructionArgumentNode;\n    instructionLinkNode: InstructionNode;\n    pdaLinkNode: PdaNode;\n    programLinkNode: ProgramNode;\n}[TLinkNode['kind']];\n\ntype ProgramDictionary = {\n    accounts: Map<string, NodePath<AccountNode>>;\n    definedTypes: Map<string, NodePath<DefinedTypeNode>>;\n    instructions: Map<string, InstructionDictionary>;\n    pdas: Map<string, NodePath<PdaNode>>;\n    program: NodePath<ProgramNode>;\n};\n\ntype InstructionDictionary = {\n    accounts: Map<string, NodePath<InstructionAccountNode>>;\n    arguments: Map<string, NodePath<InstructionArgumentNode>>;\n    instruction: NodePath<InstructionNode>;\n};\n\nexport class LinkableDictionary {\n    readonly programs: Map<string, ProgramDictionary> = new Map();\n\n    recordPath(linkablePath: NodePath<LinkableNode>): this {\n        const linkableNode = getLastNodeFromPath(linkablePath);\n        const programDictionary = this.getOrCreateProgramDictionary(linkablePath);\n        if (!programDictionary) return this; // Do not record nodes that are outside of a program.\n        const instructionDictionary = this.getOrCreateInstructionDictionary(programDictionary, linkablePath);\n\n        if (isNodePath(linkablePath, 'accountNode')) {\n            programDictionary.accounts.set(linkableNode.name, linkablePath);\n        } else if (isNodePath(linkablePath, 'definedTypeNode')) {\n            programDictionary.definedTypes.set(linkableNode.name, linkablePath);\n        } else if (isNodePath(linkablePath, 'pdaNode')) {\n            programDictionary.pdas.set(linkableNode.name, linkablePath);\n        } else if (instructionDictionary && isNodePath(linkablePath, 'instructionAccountNode')) {\n            instructionDictionary.accounts.set(linkableNode.name, linkablePath);\n        } else if (instructionDictionary && isNodePath(linkablePath, 'instructionArgumentNode')) {\n            instructionDictionary.arguments.set(linkableNode.name, linkablePath);\n        }\n\n        return this;\n    }\n\n    getPathOrThrow<TLinkNode extends LinkNode>(\n        linkPath: NodePath<TLinkNode>,\n    ): NodePath<GetLinkableFromLinkNode<TLinkNode>> {\n        const linkablePath = this.getPath(linkPath);\n\n        if (!linkablePath) {\n            const linkNode = getLastNodeFromPath(linkPath);\n            throw new CodamaError(CODAMA_ERROR__LINKED_NODE_NOT_FOUND, {\n                kind: linkNode.kind,\n                linkNode,\n                name: linkNode.name,\n                path: linkPath,\n            });\n        }\n\n        return linkablePath;\n    }\n\n    getPath<TLinkNode extends LinkNode>(\n        linkPath: NodePath<TLinkNode>,\n    ): NodePath<GetLinkableFromLinkNode<TLinkNode>> | undefined {\n        const linkNode = getLastNodeFromPath(linkPath);\n        const programDictionary = this.getProgramDictionary(linkPath);\n        if (!programDictionary) return undefined;\n        const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);\n        type LinkablePath = NodePath<GetLinkableFromLinkNode<TLinkNode>> | undefined;\n\n        if (isNode(linkNode, 'accountLinkNode')) {\n            return programDictionary.accounts.get(linkNode.name) as LinkablePath;\n        } else if (isNode(linkNode, 'definedTypeLinkNode')) {\n            return programDictionary.definedTypes.get(linkNode.name) as LinkablePath;\n        } else if (isNode(linkNode, 'instructionAccountLinkNode')) {\n            return instructionDictionary?.accounts.get(linkNode.name) as LinkablePath;\n        } else if (isNode(linkNode, 'instructionArgumentLinkNode')) {\n            return instructionDictionary?.arguments.get(linkNode.name) as LinkablePath;\n        } else if (isNode(linkNode, 'instructionLinkNode')) {\n            return instructionDictionary?.instruction as LinkablePath;\n        } else if (isNode(linkNode, 'pdaLinkNode')) {\n            return programDictionary.pdas.get(linkNode.name) as LinkablePath;\n        } else if (isNode(linkNode, 'programLinkNode')) {\n            return programDictionary.program as LinkablePath;\n        }\n\n        return undefined;\n    }\n\n    getOrThrow<TLinkNode extends LinkNode>(linkPath: NodePath<TLinkNode>): GetLinkableFromLinkNode<TLinkNode> {\n        return getLastNodeFromPath(this.getPathOrThrow(linkPath));\n    }\n\n    get<TLinkNode extends LinkNode>(linkPath: NodePath<TLinkNode>): GetLinkableFromLinkNode<TLinkNode> | undefined {\n        const path = this.getPath(linkPath);\n        return path ? getLastNodeFromPath(path) : undefined;\n    }\n\n    has(linkPath: NodePath<LinkNode>): boolean {\n        const linkNode = getLastNodeFromPath(linkPath);\n        const programDictionary = this.getProgramDictionary(linkPath);\n        if (!programDictionary) return false;\n        const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);\n\n        if (isNode(linkNode, 'accountLinkNode')) {\n            return programDictionary.accounts.has(linkNode.name);\n        } else if (isNode(linkNode, 'definedTypeLinkNode')) {\n            return programDictionary.definedTypes.has(linkNode.name);\n        } else if (isNode(linkNode, 'instructionAccountLinkNode')) {\n            return !!instructionDictionary && instructionDictionary.accounts.has(linkNode.name);\n        } else if (isNode(linkNode, 'instructionArgumentLinkNode')) {\n            return !!instructionDictionary && instructionDictionary.arguments.has(linkNode.name);\n        } else if (isNode(linkNode, 'instructionLinkNode')) {\n            return programDictionary.instructions.has(linkNode.name);\n        } else if (isNode(linkNode, 'pdaLinkNode')) {\n            return programDictionary.pdas.has(linkNode.name);\n        } else if (isNode(linkNode, 'programLinkNode')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private getOrCreateProgramDictionary(linkablePath: NodePath<LinkableNode>): ProgramDictionary | undefined {\n        const linkableNode = getLastNodeFromPath(linkablePath);\n        const programNode = isNode(linkableNode, 'programNode') ? linkableNode : findProgramNodeFromPath(linkablePath);\n        if (!programNode) return undefined;\n\n        let programDictionary = this.programs.get(programNode.name);\n        if (!programDictionary) {\n            programDictionary = {\n                accounts: new Map(),\n                definedTypes: new Map(),\n                instructions: new Map(),\n                pdas: new Map(),\n                program: getNodePathUntilLastNode(linkablePath, 'programNode')!,\n            };\n            this.programs.set(programNode.name, programDictionary);\n        }\n\n        return programDictionary;\n    }\n\n    private getOrCreateInstructionDictionary(\n        programDictionary: ProgramDictionary,\n        linkablePath: NodePath<LinkableNode>,\n    ): InstructionDictionary | undefined {\n        const linkableNode = getLastNodeFromPath(linkablePath);\n        const instructionNode = isNode(linkableNode, 'instructionNode')\n            ? linkableNode\n            : findInstructionNodeFromPath(linkablePath);\n        if (!instructionNode) return undefined;\n\n        let instructionDictionary = programDictionary.instructions.get(instructionNode.name);\n        if (!instructionDictionary) {\n            instructionDictionary = {\n                accounts: new Map(),\n                arguments: new Map(),\n                instruction: getNodePathUntilLastNode(linkablePath, 'instructionNode')!,\n            };\n            programDictionary.instructions.set(instructionNode.name, instructionDictionary);\n        }\n\n        return instructionDictionary;\n    }\n\n    private getProgramDictionary(linkPath: NodePath<LinkNode>): ProgramDictionary | undefined {\n        const linkNode = getLastNodeFromPath(linkPath);\n        let programName: CamelCaseString | undefined = undefined;\n        if (isNode(linkNode, 'programLinkNode')) {\n            programName = linkNode.name;\n        } else if ('program' in linkNode) {\n            programName = linkNode.program?.name;\n        } else if ('instruction' in linkNode) {\n            programName = linkNode.instruction?.program?.name;\n        }\n        programName = programName ?? findProgramNodeFromPath(linkPath)?.name;\n\n        return programName ? this.programs.get(programName) : undefined;\n    }\n\n    private getInstructionDictionary(\n        programDictionary: ProgramDictionary,\n        linkPath: NodePath<LinkNode>,\n    ): InstructionDictionary | undefined {\n        const linkNode = getLastNodeFromPath(linkPath);\n        let instructionName: CamelCaseString | undefined = undefined;\n        if (isNode(linkNode, 'instructionLinkNode')) {\n            instructionName = linkNode.name;\n        } else if ('instruction' in linkNode) {\n            instructionName = linkNode.instruction?.name;\n        }\n        instructionName = instructionName ?? findInstructionNodeFromPath(linkPath)?.name;\n\n        return instructionName ? programDictionary.instructions.get(instructionName) : undefined;\n    }\n}\n","import { isNode, type NodeKind } from '@codama/nodes';\n\nimport { interceptFirstVisitVisitor } from './interceptFirstVisitVisitor';\nimport { interceptVisitor } from './interceptVisitor';\nimport { LINKABLE_NODES, LinkableDictionary } from './LinkableDictionary';\nimport { NodeStack } from './NodeStack';\nimport { pipe } from './pipe';\nimport { recordNodeStackVisitor } from './recordNodeStackVisitor';\nimport { visit, Visitor } from './visitor';\nimport { voidVisitor } from './voidVisitor';\n\nexport function getRecordLinkablesVisitor<TNodeKind extends NodeKind>(\n    linkables: LinkableDictionary,\n): Visitor<void, TNodeKind> {\n    const stack = new NodeStack();\n    return pipe(\n        voidVisitor(),\n        v =>\n            interceptVisitor(v, (node, next) => {\n                if (isNode(node, LINKABLE_NODES)) {\n                    linkables.recordPath(stack.getPath(LINKABLE_NODES));\n                }\n                return next(node);\n            }),\n        v => recordNodeStackVisitor(v, stack),\n    );\n}\n\nexport function recordLinkablesOnFirstVisitVisitor<TReturn, TNodeKind extends NodeKind>(\n    visitor: Visitor<TReturn, TNodeKind>,\n    linkables: LinkableDictionary,\n): Visitor<TReturn, TNodeKind> {\n    const recordingVisitor = getRecordLinkablesVisitor(linkables);\n\n    return pipe(visitor, v =>\n        interceptFirstVisitVisitor(v, (node, next) => {\n            visit(node, recordingVisitor);\n            return next(node);\n        }),\n    );\n}\n","import type { NodeKind } from '@codama/nodes';\n\nimport { mergeVisitor } from './mergeVisitor';\nimport { Visitor } from './visitor';\n\nexport function voidVisitor<TNodeKind extends NodeKind = NodeKind>(\n    options: { keys?: TNodeKind[] } = {},\n): Visitor<void, TNodeKind> {\n    return mergeVisitor(\n        () => undefined,\n        () => undefined,\n        options,\n    );\n}\n","import { GetNodeFromKind, NodeKind } from '@codama/nodes';\n\nimport { getVisitFunctionName, GetVisitorFunctionName, Visitor } from './visitor';\n\nexport function tapVisitor<TReturn, TNodeKey extends NodeKind, TVisitor extends Visitor<TReturn, TNodeKey>>(\n    visitor: TVisitor,\n    key: TNodeKey,\n    tap: (node: GetNodeFromKind<TNodeKey>) => void,\n): TVisitor {\n    const newVisitor = { ...visitor };\n    newVisitor[getVisitFunctionName(key)] = function tappedVisitNode(\n        this: TVisitor,\n        node: GetNodeFromKind<TNodeKey>,\n    ): TReturn {\n        tap(node);\n        const parentFunction = visitor[getVisitFunctionName(key)] as (node: GetNodeFromKind<TNodeKey>) => TReturn;\n        return parentFunction.bind(this)(node);\n    } as TVisitor[GetVisitorFunctionName<TNodeKey>];\n\n    return newVisitor;\n}\n"],"mappings":"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","names":["REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","visit","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","nodeSelectors","CodamaError","assertIsNode","CodamaError","stack","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","stack","CodamaError","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","CodamaError","isNode","REGISTERED_NODE_KINDS","REGISTERED_NODE_KINDS","visit","isNode","v","CodamaError","isNode","VALUE_NODES","isNode","CodamaError","VALUE_NODES","CodamaError","isNode","CodamaError","isNode","programNode","instructionNode","isNode","isNode"]}