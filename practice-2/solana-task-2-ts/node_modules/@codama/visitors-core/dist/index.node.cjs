"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  LINKABLE_NODES: () => LINKABLE_NODES,
  LinkableDictionary: () => LinkableDictionary,
  NodeStack: () => NodeStack,
  assertIsNodePath: () => assertIsNodePath,
  bottomUpTransformerVisitor: () => bottomUpTransformerVisitor,
  consoleLogVisitor: () => consoleLogVisitor,
  deduplicateInstructionDependencies: () => deduplicateInstructionDependencies,
  deleteNodesVisitor: () => deleteNodesVisitor,
  extendVisitor: () => extendVisitor,
  findFirstNodeFromPath: () => findFirstNodeFromPath,
  findInstructionNodeFromPath: () => findInstructionNodeFromPath,
  findLastNodeFromPath: () => findLastNodeFromPath,
  findProgramNodeFromPath: () => findProgramNodeFromPath,
  getByteSizeVisitor: () => getByteSizeVisitor,
  getConjunctiveNodeSelectorFunction: () => getConjunctiveNodeSelectorFunction,
  getDebugStringVisitor: () => getDebugStringVisitor,
  getInstructionDependencies: () => getInstructionDependencies,
  getLastNodeFromPath: () => getLastNodeFromPath,
  getNodePathUntilLastNode: () => getNodePathUntilLastNode,
  getNodeSelectorFunction: () => getNodeSelectorFunction,
  getRecordLinkablesVisitor: () => getRecordLinkablesVisitor,
  getResolvedInstructionInputsVisitor: () => getResolvedInstructionInputsVisitor,
  getUniqueHashStringVisitor: () => getUniqueHashStringVisitor,
  getVisitFunctionName: () => getVisitFunctionName,
  identityVisitor: () => identityVisitor,
  interceptFirstVisitVisitor: () => interceptFirstVisitVisitor,
  interceptVisitor: () => interceptVisitor,
  isFilledNodePath: () => isFilledNodePath,
  isNodePath: () => isNodePath,
  mapVisitor: () => mapVisitor,
  mergeVisitor: () => mergeVisitor,
  nodePathToString: () => nodePathToString,
  nodePathToStringArray: () => nodePathToStringArray,
  nonNullableIdentityVisitor: () => nonNullableIdentityVisitor,
  pipe: () => pipe,
  recordLinkablesOnFirstVisitVisitor: () => recordLinkablesOnFirstVisitVisitor,
  recordNodeStackVisitor: () => recordNodeStackVisitor,
  removeDocsVisitor: () => removeDocsVisitor,
  rootNodeVisitor: () => rootNodeVisitor,
  singleNodeVisitor: () => singleNodeVisitor,
  staticVisitor: () => staticVisitor,
  tapVisitor: () => tapVisitor,
  topDownTransformerVisitor: () => topDownTransformerVisitor,
  visit: () => visit,
  visitOrElse: () => visitOrElse,
  voidVisitor: () => voidVisitor
});
module.exports = __toCommonJS(index_exports);

// src/identityVisitor.ts
var import_nodes3 = require("@codama/nodes");

// src/staticVisitor.ts
var import_nodes2 = require("@codama/nodes");

// src/visitor.ts
var import_errors = require("@codama/errors");
var import_nodes = require("@codama/nodes");
function visit(node, visitor) {
  const key = getVisitFunctionName(node.kind);
  return visitor[key](node);
}
function visitOrElse(node, visitor, fallback) {
  const key = getVisitFunctionName(node.kind);
  return (key in visitor ? visitor[key] : fallback)(node);
}
function getVisitFunctionName(nodeKind) {
  if (!import_nodes.REGISTERED_NODE_KINDS.includes(nodeKind)) {
    throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__UNRECOGNIZED_NODE_KIND, { kind: nodeKind });
  }
  return `visit${(0, import_nodes.pascalCase)(nodeKind.slice(0, -4))}`;
}

// src/staticVisitor.ts
function staticVisitor(fn, options = {}) {
  const keys = options.keys ?? import_nodes2.REGISTERED_NODE_KINDS;
  const visitor = {};
  keys.forEach((key) => {
    visitor[getVisitFunctionName(key)] = fn.bind(visitor);
  });
  return visitor;
}

// src/identityVisitor.ts
function identityVisitor(options = {}) {
  const keys = options.keys ?? import_nodes3.REGISTERED_NODE_KINDS;
  const visitor = staticVisitor((node) => Object.freeze({ ...node }), { keys });
  const visit2 = (v) => (node) => keys.includes(node.kind) ? visit(node, v) : Object.freeze({ ...node });
  if (keys.includes("rootNode")) {
    visitor.visitRoot = function visitRoot(node) {
      const program = visit2(this)(node.program);
      if (program === null) return null;
      (0, import_nodes3.assertIsNode)(program, "programNode");
      return (0, import_nodes3.rootNode)(
        program,
        node.additionalPrograms.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("programNode"))
      );
    };
  }
  if (keys.includes("programNode")) {
    visitor.visitProgram = function visitProgram(node) {
      return (0, import_nodes3.programNode)({
        ...node,
        accounts: node.accounts.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("accountNode")),
        definedTypes: node.definedTypes.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("definedTypeNode")),
        errors: node.errors.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("errorNode")),
        instructions: node.instructions.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionNode")),
        pdas: node.pdas.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("pdaNode"))
      });
    };
  }
  if (keys.includes("pdaNode")) {
    visitor.visitPda = function visitPda(node) {
      return (0, import_nodes3.pdaNode)({
        ...node,
        seeds: node.seeds.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.PDA_SEED_NODES))
      });
    };
  }
  if (keys.includes("accountNode")) {
    visitor.visitAccount = function visitAccount(node) {
      const data = visit2(this)(node.data);
      if (data === null) return null;
      (0, import_nodes3.assertIsNode)(data, "structTypeNode");
      const pda = node.pda ? visit2(this)(node.pda) ?? void 0 : void 0;
      if (pda) (0, import_nodes3.assertIsNode)(pda, "pdaLinkNode");
      return (0, import_nodes3.accountNode)({ ...node, data, pda });
    };
  }
  if (keys.includes("instructionNode")) {
    visitor.visitInstruction = function visitInstruction(node) {
      return (0, import_nodes3.instructionNode)({
        ...node,
        accounts: node.accounts.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionAccountNode")),
        arguments: node.arguments.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionArgumentNode")),
        byteDeltas: node.byteDeltas ? node.byteDeltas.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionByteDeltaNode")) : void 0,
        discriminators: node.discriminators ? node.discriminators.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.DISCRIMINATOR_NODES)) : void 0,
        extraArguments: node.extraArguments ? node.extraArguments.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionArgumentNode")) : void 0,
        remainingAccounts: node.remainingAccounts ? node.remainingAccounts.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionRemainingAccountsNode")) : void 0,
        subInstructions: node.subInstructions ? node.subInstructions.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("instructionNode")) : void 0
      });
    };
  }
  if (keys.includes("instructionAccountNode")) {
    visitor.visitInstructionAccount = function visitInstructionAccount(node) {
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) (0, import_nodes3.assertIsNode)(defaultValue, import_nodes3.INSTRUCTION_INPUT_VALUE_NODES);
      return (0, import_nodes3.instructionAccountNode)({ ...node, defaultValue });
    };
  }
  if (keys.includes("instructionArgumentNode")) {
    visitor.visitInstructionArgument = function visitInstructionArgument(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) (0, import_nodes3.assertIsNode)(defaultValue, import_nodes3.INSTRUCTION_INPUT_VALUE_NODES);
      return (0, import_nodes3.instructionArgumentNode)({ ...node, defaultValue, type });
    };
  }
  if (keys.includes("instructionRemainingAccountsNode")) {
    visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, ["argumentValueNode", "resolverValueNode"]);
      return (0, import_nodes3.instructionRemainingAccountsNode)(value, { ...node });
    };
  }
  if (keys.includes("instructionByteDeltaNode")) {
    visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, ["numberValueNode", "accountLinkNode", "argumentValueNode", "resolverValueNode"]);
      return (0, import_nodes3.instructionByteDeltaNode)(value, { ...node });
    };
  }
  if (keys.includes("definedTypeNode")) {
    visitor.visitDefinedType = function visitDefinedType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.definedTypeNode)({ ...node, type });
    };
  }
  if (keys.includes("arrayTypeNode")) {
    visitor.visitArrayType = function visitArrayType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      (0, import_nodes3.assertIsNode)(size, import_nodes3.COUNT_NODES);
      const item = visit2(this)(node.item);
      if (item === null) return null;
      (0, import_nodes3.assertIsNode)(item, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.arrayTypeNode)(item, size);
    };
  }
  if (keys.includes("enumTypeNode")) {
    visitor.visitEnumType = function visitEnumType(node) {
      return (0, import_nodes3.enumTypeNode)(
        node.variants.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.ENUM_VARIANT_TYPE_NODES)),
        { size: node.size }
      );
    };
  }
  if (keys.includes("enumStructVariantTypeNode")) {
    visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {
      const newStruct = visit2(this)(node.struct);
      if (!newStruct) {
        return (0, import_nodes3.enumEmptyVariantTypeNode)(node.name);
      }
      (0, import_nodes3.assertIsNode)(newStruct, "structTypeNode");
      if (newStruct.fields.length === 0) {
        return (0, import_nodes3.enumEmptyVariantTypeNode)(node.name);
      }
      return (0, import_nodes3.enumStructVariantTypeNode)(node.name, newStruct);
    };
  }
  if (keys.includes("enumTupleVariantTypeNode")) {
    visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {
      const newTuple = visit2(this)(node.tuple);
      if (!newTuple) {
        return (0, import_nodes3.enumEmptyVariantTypeNode)(node.name);
      }
      (0, import_nodes3.assertIsNode)(newTuple, "tupleTypeNode");
      if (newTuple.items.length === 0) {
        return (0, import_nodes3.enumEmptyVariantTypeNode)(node.name);
      }
      return (0, import_nodes3.enumTupleVariantTypeNode)(node.name, newTuple);
    };
  }
  if (keys.includes("mapTypeNode")) {
    visitor.visitMapType = function visitMapType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      (0, import_nodes3.assertIsNode)(size, import_nodes3.COUNT_NODES);
      const key = visit2(this)(node.key);
      if (key === null) return null;
      (0, import_nodes3.assertIsNode)(key, import_nodes3.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.mapTypeNode)(key, value, size);
    };
  }
  if (keys.includes("optionTypeNode")) {
    visitor.visitOptionType = function visitOptionType(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(prefix, "numberTypeNode");
      const item = visit2(this)(node.item);
      if (item === null) return null;
      (0, import_nodes3.assertIsNode)(item, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.optionTypeNode)(item, { ...node, prefix });
    };
  }
  if (keys.includes("zeroableOptionTypeNode")) {
    visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {
      const item = visit2(this)(node.item);
      if (item === null) return null;
      (0, import_nodes3.assertIsNode)(item, import_nodes3.TYPE_NODES);
      const zeroValue = node.zeroValue ? visit2(this)(node.zeroValue) ?? void 0 : void 0;
      if (zeroValue) (0, import_nodes3.assertIsNode)(zeroValue, "constantValueNode");
      return (0, import_nodes3.zeroableOptionTypeNode)(item, zeroValue);
    };
  }
  if (keys.includes("remainderOptionTypeNode")) {
    visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {
      const item = visit2(this)(node.item);
      if (item === null) return null;
      (0, import_nodes3.assertIsNode)(item, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.remainderOptionTypeNode)(item);
    };
  }
  if (keys.includes("booleanTypeNode")) {
    visitor.visitBooleanType = function visitBooleanType(node) {
      const size = visit2(this)(node.size);
      if (size === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(size, "numberTypeNode");
      return (0, import_nodes3.booleanTypeNode)(size);
    };
  }
  if (keys.includes("setTypeNode")) {
    visitor.visitSetType = function visitSetType(node) {
      const size = visit2(this)(node.count);
      if (size === null) return null;
      (0, import_nodes3.assertIsNode)(size, import_nodes3.COUNT_NODES);
      const item = visit2(this)(node.item);
      if (item === null) return null;
      (0, import_nodes3.assertIsNode)(item, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.setTypeNode)(item, size);
    };
  }
  if (keys.includes("structTypeNode")) {
    visitor.visitStructType = function visitStructType(node) {
      const fields = node.fields.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("structFieldTypeNode"));
      return (0, import_nodes3.structTypeNode)(fields);
    };
  }
  if (keys.includes("structFieldTypeNode")) {
    visitor.visitStructFieldType = function visitStructFieldType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const defaultValue = node.defaultValue ? visit2(this)(node.defaultValue) ?? void 0 : void 0;
      if (defaultValue) (0, import_nodes3.assertIsNode)(defaultValue, import_nodes3.VALUE_NODES);
      return (0, import_nodes3.structFieldTypeNode)({ ...node, defaultValue, type });
    };
  }
  if (keys.includes("tupleTypeNode")) {
    visitor.visitTupleType = function visitTupleType(node) {
      const items = node.items.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.TYPE_NODES));
      return (0, import_nodes3.tupleTypeNode)(items);
    };
  }
  if (keys.includes("amountTypeNode")) {
    visitor.visitAmountType = function visitAmountType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(number, "numberTypeNode");
      return (0, import_nodes3.amountTypeNode)(number, node.decimals, node.unit);
    };
  }
  if (keys.includes("dateTimeTypeNode")) {
    visitor.visitDateTimeType = function visitDateTimeType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(number, "numberTypeNode");
      return (0, import_nodes3.dateTimeTypeNode)(number);
    };
  }
  if (keys.includes("solAmountTypeNode")) {
    visitor.visitSolAmountType = function visitSolAmountType(node) {
      const number = visit2(this)(node.number);
      if (number === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(number, "numberTypeNode");
      return (0, import_nodes3.solAmountTypeNode)(number);
    };
  }
  if (keys.includes("prefixedCountNode")) {
    visitor.visitPrefixedCount = function visitPrefixedCount(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(prefix, "numberTypeNode");
      return (0, import_nodes3.prefixedCountNode)(prefix);
    };
  }
  if (keys.includes("arrayValueNode")) {
    visitor.visitArrayValue = function visitArrayValue(node) {
      return (0, import_nodes3.arrayValueNode)(node.items.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.VALUE_NODES)));
    };
  }
  if (keys.includes("constantValueNode")) {
    visitor.visitConstantValue = function visitConstantValue(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, import_nodes3.VALUE_NODES);
      return (0, import_nodes3.constantValueNode)(type, value);
    };
  }
  if (keys.includes("enumValueNode")) {
    visitor.visitEnumValue = function visitEnumValue(node) {
      const enumLink = visit2(this)(node.enum);
      if (enumLink === null) return null;
      (0, import_nodes3.assertIsNode)(enumLink, ["definedTypeLinkNode"]);
      const value = node.value ? visit2(this)(node.value) ?? void 0 : void 0;
      if (value) (0, import_nodes3.assertIsNode)(value, ["structValueNode", "tupleValueNode"]);
      return (0, import_nodes3.enumValueNode)(enumLink, node.variant, value);
    };
  }
  if (keys.includes("mapValueNode")) {
    visitor.visitMapValue = function visitMapValue(node) {
      return (0, import_nodes3.mapValueNode)(
        node.entries.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("mapEntryValueNode"))
      );
    };
  }
  if (keys.includes("mapEntryValueNode")) {
    visitor.visitMapEntryValue = function visitMapEntryValue(node) {
      const key = visit2(this)(node.key);
      if (key === null) return null;
      (0, import_nodes3.assertIsNode)(key, import_nodes3.VALUE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, import_nodes3.VALUE_NODES);
      return (0, import_nodes3.mapEntryValueNode)(key, value);
    };
  }
  if (keys.includes("setValueNode")) {
    visitor.visitSetValue = function visitSetValue(node) {
      return (0, import_nodes3.setValueNode)(node.items.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.VALUE_NODES)));
    };
  }
  if (keys.includes("someValueNode")) {
    visitor.visitSomeValue = function visitSomeValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, import_nodes3.VALUE_NODES);
      return (0, import_nodes3.someValueNode)(value);
    };
  }
  if (keys.includes("structValueNode")) {
    visitor.visitStructValue = function visitStructValue(node) {
      return (0, import_nodes3.structValueNode)(
        node.fields.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("structFieldValueNode"))
      );
    };
  }
  if (keys.includes("structFieldValueNode")) {
    visitor.visitStructFieldValue = function visitStructFieldValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, import_nodes3.VALUE_NODES);
      return (0, import_nodes3.structFieldValueNode)(node.name, value);
    };
  }
  if (keys.includes("tupleValueNode")) {
    visitor.visitTupleValue = function visitTupleValue(node) {
      return (0, import_nodes3.tupleValueNode)(node.items.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(import_nodes3.VALUE_NODES)));
    };
  }
  if (keys.includes("constantPdaSeedNode")) {
    visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, [...import_nodes3.VALUE_NODES, "programIdValueNode"]);
      return (0, import_nodes3.constantPdaSeedNode)(type, value);
    };
  }
  if (keys.includes("variablePdaSeedNode")) {
    visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.variablePdaSeedNode)(node.name, type, node.docs);
    };
  }
  if (keys.includes("resolverValueNode")) {
    visitor.visitResolverValue = function visitResolverValue(node) {
      const dependsOn = (node.dependsOn ?? []).map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)(["accountValueNode", "argumentValueNode"]));
      return (0, import_nodes3.resolverValueNode)(node.name, {
        ...node,
        dependsOn: dependsOn.length === 0 ? void 0 : dependsOn
      });
    };
  }
  if (keys.includes("conditionalValueNode")) {
    visitor.visitConditionalValue = function visitConditionalValue(node) {
      const condition = visit2(this)(node.condition);
      if (condition === null) return null;
      (0, import_nodes3.assertIsNode)(condition, ["resolverValueNode", "accountValueNode", "argumentValueNode"]);
      const value = node.value ? visit2(this)(node.value) ?? void 0 : void 0;
      if (value) (0, import_nodes3.assertIsNode)(value, import_nodes3.VALUE_NODES);
      const ifTrue = node.ifTrue ? visit2(this)(node.ifTrue) ?? void 0 : void 0;
      if (ifTrue) (0, import_nodes3.assertIsNode)(ifTrue, import_nodes3.INSTRUCTION_INPUT_VALUE_NODES);
      const ifFalse = node.ifFalse ? visit2(this)(node.ifFalse) ?? void 0 : void 0;
      if (ifFalse) (0, import_nodes3.assertIsNode)(ifFalse, import_nodes3.INSTRUCTION_INPUT_VALUE_NODES);
      if (!ifTrue && !ifFalse) return null;
      return (0, import_nodes3.conditionalValueNode)({ condition, ifFalse, ifTrue, value });
    };
  }
  if (keys.includes("pdaValueNode")) {
    visitor.visitPdaValue = function visitPdaValue(node) {
      const pda = visit2(this)(node.pda);
      if (pda === null) return null;
      (0, import_nodes3.assertIsNode)(pda, ["pdaLinkNode", "pdaNode"]);
      const seeds = node.seeds.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("pdaSeedValueNode"));
      return (0, import_nodes3.pdaValueNode)(pda, seeds);
    };
  }
  if (keys.includes("pdaSeedValueNode")) {
    visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {
      const value = visit2(this)(node.value);
      if (value === null) return null;
      (0, import_nodes3.assertIsNode)(value, [...import_nodes3.VALUE_NODES, "accountValueNode", "argumentValueNode"]);
      return (0, import_nodes3.pdaSeedValueNode)(node.name, value);
    };
  }
  if (keys.includes("fixedSizeTypeNode")) {
    visitor.visitFixedSizeType = function visitFixedSizeType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.fixedSizeTypeNode)(type, node.size);
    };
  }
  if (keys.includes("sizePrefixTypeNode")) {
    visitor.visitSizePrefixType = function visitSizePrefixType(node) {
      const prefix = visit2(this)(node.prefix);
      if (prefix === null) return null;
      (0, import_nodes3.assertIsNestedTypeNode)(prefix, "numberTypeNode");
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.sizePrefixTypeNode)(type, prefix);
    };
  }
  if (keys.includes("preOffsetTypeNode")) {
    visitor.visitPreOffsetType = function visitPreOffsetType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.preOffsetTypeNode)(type, node.offset, node.strategy);
    };
  }
  if (keys.includes("postOffsetTypeNode")) {
    visitor.visitPostOffsetType = function visitPostOffsetType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.postOffsetTypeNode)(type, node.offset, node.strategy);
    };
  }
  if (keys.includes("sentinelTypeNode")) {
    visitor.visitSentinelType = function visitSentinelType(node) {
      const sentinel = visit2(this)(node.sentinel);
      if (sentinel === null) return null;
      (0, import_nodes3.assertIsNode)(sentinel, "constantValueNode");
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      return (0, import_nodes3.sentinelTypeNode)(type, sentinel);
    };
  }
  if (keys.includes("hiddenPrefixTypeNode")) {
    visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const prefix = node.prefix.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("constantValueNode"));
      if (prefix.length === 0) return type;
      return (0, import_nodes3.hiddenPrefixTypeNode)(type, prefix);
    };
  }
  if (keys.includes("hiddenSuffixTypeNode")) {
    visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {
      const type = visit2(this)(node.type);
      if (type === null) return null;
      (0, import_nodes3.assertIsNode)(type, import_nodes3.TYPE_NODES);
      const suffix = node.suffix.map(visit2(this)).filter((0, import_nodes3.removeNullAndAssertIsNodeFilter)("constantValueNode"));
      if (suffix.length === 0) return type;
      return (0, import_nodes3.hiddenSuffixTypeNode)(type, suffix);
    };
  }
  if (keys.includes("constantDiscriminatorNode")) {
    visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {
      const constant = visit2(this)(node.constant);
      if (constant === null) return null;
      (0, import_nodes3.assertIsNode)(constant, "constantValueNode");
      return (0, import_nodes3.constantDiscriminatorNode)(constant, node.offset);
    };
  }
  if (keys.includes("accountLinkNode")) {
    visitor.visitAccountLink = function visitAccountLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) (0, import_nodes3.assertIsNode)(program, "programLinkNode");
      return (0, import_nodes3.accountLinkNode)(node.name, program);
    };
  }
  if (keys.includes("definedTypeLinkNode")) {
    visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) (0, import_nodes3.assertIsNode)(program, "programLinkNode");
      return (0, import_nodes3.definedTypeLinkNode)(node.name, program);
    };
  }
  if (keys.includes("instructionLinkNode")) {
    visitor.visitInstructionLink = function visitInstructionLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) (0, import_nodes3.assertIsNode)(program, "programLinkNode");
      return (0, import_nodes3.instructionLinkNode)(node.name, program);
    };
  }
  if (keys.includes("instructionAccountLinkNode")) {
    visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {
      const instruction = node.instruction ? visit2(this)(node.instruction) ?? void 0 : void 0;
      if (instruction) (0, import_nodes3.assertIsNode)(instruction, "instructionLinkNode");
      return (0, import_nodes3.instructionAccountLinkNode)(node.name, instruction);
    };
  }
  if (keys.includes("instructionArgumentLinkNode")) {
    visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {
      const instruction = node.instruction ? visit2(this)(node.instruction) ?? void 0 : void 0;
      if (instruction) (0, import_nodes3.assertIsNode)(instruction, "instructionLinkNode");
      return (0, import_nodes3.instructionArgumentLinkNode)(node.name, instruction);
    };
  }
  if (keys.includes("pdaLinkNode")) {
    visitor.visitPdaLink = function visitPdaLink(node) {
      const program = node.program ? visit2(this)(node.program) ?? void 0 : void 0;
      if (program) (0, import_nodes3.assertIsNode)(program, "programLinkNode");
      return (0, import_nodes3.pdaLinkNode)(node.name, program);
    };
  }
  return visitor;
}

// src/interceptVisitor.ts
var import_nodes4 = require("@codama/nodes");
function interceptVisitor(visitor, interceptor) {
  const registeredVisitFunctions = import_nodes4.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  return Object.fromEntries(
    Object.keys(visitor).flatMap((key) => {
      const castedKey = key;
      if (!registeredVisitFunctions.includes(castedKey)) {
        return [];
      }
      return [
        [
          castedKey,
          function interceptedVisitNode(node) {
            const baseFunction = visitor[castedKey];
            return interceptor(node, baseFunction.bind(this));
          }
        ]
      ];
    })
  );
}

// src/NodeSelector.ts
var import_nodes5 = require("@codama/nodes");
var getNodeSelectorFunction = (selector) => {
  if (typeof selector === "function") return selector;
  const checkNode = (node, nodeSelector) => {
    if (nodeSelector === "*") return true;
    const matches = nodeSelector.match(/^(?:\[([^\]]+)\])?(.*)?$/);
    if (!matches) return false;
    const [, kinds, name] = matches;
    const kindArray = kinds ? kinds.split("|").map(import_nodes5.camelCase) : [];
    if (kindArray.length > 0 && !kindArray.includes(node.kind)) {
      return false;
    }
    if (name && (!("name" in node) || (0, import_nodes5.camelCase)(name) !== node.name)) {
      return false;
    }
    return true;
  };
  const checkPath = (path, nodeSelectors2) => {
    if (nodeSelectors2.length === 0) return true;
    if (path.length === 0) return false;
    const lastNode = path.pop();
    const lastNodeSelector = nodeSelectors2.pop();
    return checkNode(lastNode, lastNodeSelector) ? checkPath(path, nodeSelectors2) : checkPath(path, [...nodeSelectors2, lastNodeSelector]);
  };
  const checkInitialPath = (path, nodeSelectors2) => {
    if (nodeSelectors2.length === 0 || path.length === 0) return false;
    const lastNode = path.pop();
    const lastNodeSelector = nodeSelectors2.pop();
    return checkNode(lastNode, lastNodeSelector) && checkPath(path, nodeSelectors2);
  };
  const nodeSelectors = selector.split(".");
  return (path) => checkInitialPath([...path], [...nodeSelectors]);
};
var getConjunctiveNodeSelectorFunction = (selector) => {
  const selectors = Array.isArray(selector) ? selector : [selector];
  const selectorFunctions = selectors.map(getNodeSelectorFunction);
  return (path) => selectorFunctions.every((fn) => fn(path));
};

// src/NodeStack.ts
var import_errors2 = require("@codama/errors");

// src/NodePath.ts
var import_nodes6 = require("@codama/nodes");
function getLastNodeFromPath(path) {
  return path[path.length - 1];
}
function findFirstNodeFromPath(path, kind) {
  return path.find((node) => (0, import_nodes6.isNode)(node, kind));
}
function findLastNodeFromPath(path, kind) {
  for (let index = path.length - 1; index >= 0; index--) {
    const node = path[index];
    if ((0, import_nodes6.isNode)(node, kind)) return node;
  }
  return void 0;
}
function findProgramNodeFromPath(path) {
  return findLastNodeFromPath(path, "programNode");
}
function findInstructionNodeFromPath(path) {
  return findLastNodeFromPath(path, "instructionNode");
}
function getNodePathUntilLastNode(path, kind) {
  const lastIndex = (() => {
    for (let index = path.length - 1; index >= 0; index--) {
      const node = path[index];
      if ((0, import_nodes6.isNode)(node, kind)) return index;
    }
    return -1;
  })();
  if (lastIndex === -1) return void 0;
  return path.slice(0, lastIndex + 1);
}
function isFilledNodePath(path) {
  return !!path && path.length > 0;
}
function isNodePath(path, kind) {
  return (0, import_nodes6.isNode)(isFilledNodePath(path) ? getLastNodeFromPath(path) : null, kind);
}
function assertIsNodePath(path, kind) {
  (0, import_nodes6.assertIsNode)(isFilledNodePath(path) ? getLastNodeFromPath(path) : null, kind);
}
function nodePathToStringArray(path) {
  return path.map((node) => {
    return "name" in node ? `[${node.kind}]${node.name}` : `[${node.kind}]`;
  });
}
function nodePathToString(path) {
  return nodePathToStringArray(path).join(" > ");
}

// src/NodeStack.ts
var NodeStack = class _NodeStack {
  /**
   * Contains all the node paths saved during the traversal.
   *
   * - The very last path is the current path which is being
   *   used during the traversal.
   * - The other paths can be used to save and restore the
   *   current path when jumping to different parts of the tree.
   *
   * There must at least be one path in the stack at all times.
   */
  stack;
  constructor(...stack) {
    this.stack = stack.length === 0 ? [[]] : [...stack.map((nodes) => [...nodes])];
  }
  get currentPath() {
    return this.stack[this.stack.length - 1];
  }
  push(node) {
    this.currentPath.push(node);
  }
  pop() {
    return this.currentPath.pop();
  }
  peek() {
    return this.isEmpty() ? void 0 : this.currentPath[this.currentPath.length - 1];
  }
  pushPath(newPath = []) {
    this.stack.push([...newPath]);
  }
  popPath() {
    if (this.stack.length <= 1) {
      throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__VISITORS__CANNOT_REMOVE_LAST_PATH_IN_NODE_STACK, {
        path: [...this.stack[this.stack.length - 1]]
      });
    }
    return [...this.stack.pop()];
  }
  getPath(kind) {
    const path = [...this.currentPath];
    if (kind) {
      assertIsNodePath(path, kind);
    }
    return path;
  }
  isEmpty() {
    return this.currentPath.length === 0;
  }
  clone() {
    return new _NodeStack(...this.stack);
  }
  toString() {
    return nodePathToString(this.getPath());
  }
};

// src/pipe.ts
function pipe(init, ...fns) {
  return fns.reduce((acc, fn) => fn(acc), init);
}

// src/recordNodeStackVisitor.ts
function recordNodeStackVisitor(visitor, stack) {
  return interceptVisitor(visitor, (node, next) => {
    stack.push(node);
    const newNode = next(node);
    stack.pop();
    return newNode;
  });
}

// src/bottomUpTransformerVisitor.ts
function bottomUpTransformerVisitor(transformers, options = {}) {
  const transformerFunctions = transformers.map((transformer) => {
    if (typeof transformer === "function") return transformer;
    return (node, stack2) => getConjunctiveNodeSelectorFunction(transformer.select)(stack2.getPath()) ? transformer.transform(node, stack2) : node;
  });
  const stack = options.stack ?? new NodeStack();
  return pipe(
    identityVisitor(options),
    (v) => interceptVisitor(v, (node, next) => {
      return transformerFunctions.reduce(
        (acc, transformer) => acc === null ? null : transformer(acc, stack),
        next(node)
      );
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}

// src/mapVisitor.ts
var import_nodes7 = require("@codama/nodes");
function mapVisitor(visitor, map) {
  const registeredVisitFunctions = import_nodes7.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  return Object.fromEntries(
    Object.keys(visitor).flatMap((key) => {
      const castedKey = key;
      if (!registeredVisitFunctions.includes(castedKey)) {
        return [];
      }
      return [
        [
          castedKey,
          (node) => map(visitor[castedKey](node))
        ]
      ];
    })
  );
}

// src/consoleLogVisitor.ts
function consoleLogVisitor(visitor) {
  return mapVisitor(visitor, (value) => console.log(value));
}

// src/topDownTransformerVisitor.ts
function topDownTransformerVisitor(transformers, options = {}) {
  const transformerFunctions = transformers.map((transformer) => {
    if (typeof transformer === "function") return transformer;
    return (node, stack2) => getConjunctiveNodeSelectorFunction(transformer.select)(stack2.getPath()) ? transformer.transform(node, stack2) : node;
  });
  const stack = options.stack ?? new NodeStack();
  return pipe(
    identityVisitor(options),
    (v) => interceptVisitor(v, (node, next) => {
      const appliedNode = transformerFunctions.reduce(
        (acc, transformer) => acc === null ? null : transformer(acc, stack),
        node
      );
      if (appliedNode === null) return null;
      return next(appliedNode);
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}

// src/deleteNodesVisitor.ts
function deleteNodesVisitor(selectors, options) {
  return topDownTransformerVisitor(
    selectors.map(
      (selector) => ({
        select: selector,
        transform: () => null
      })
    ),
    options
  );
}

// src/extendVisitor.ts
var import_errors3 = require("@codama/errors");
var import_nodes8 = require("@codama/nodes");
function extendVisitor(visitor, overrides) {
  const registeredVisitFunctions = import_nodes8.REGISTERED_NODE_KINDS.map(getVisitFunctionName);
  const overriddenFunctions = Object.fromEntries(
    Object.keys(overrides).flatMap((key) => {
      if (!registeredVisitFunctions.includes(key)) {
        return [];
      }
      const castedKey = key;
      if (!visitor[castedKey]) {
        throw new import_errors3.CodamaError(import_errors3.CODAMA_ERROR__VISITORS__CANNOT_EXTEND_MISSING_VISIT_FUNCTION, {
          visitFunction: castedKey
        });
      }
      return [
        [
          castedKey,
          function extendedVisitNode(node) {
            const extendedFunction = overrides[castedKey];
            const nextFunction = visitor[castedKey];
            return extendedFunction.bind(this)(node, {
              next: nextFunction.bind(this),
              self: this
            });
          }
        ]
      ];
    })
  );
  return {
    ...visitor,
    ...overriddenFunctions
  };
}

// src/getByteSizeVisitor.ts
var import_nodes10 = require("@codama/nodes");

// src/mergeVisitor.ts
var import_nodes9 = require("@codama/nodes");
function mergeVisitor(leafValue, merge, options = {}) {
  const keys = options.keys ?? import_nodes9.REGISTERED_NODE_KINDS;
  const visitor = staticVisitor(leafValue, { keys });
  const visit2 = (v) => (node) => keys.includes(node.kind) ? [visit(node, v)] : [];
  if (keys.includes("rootNode")) {
    visitor.visitRoot = function visitRoot(node) {
      return merge(node, (0, import_nodes9.getAllPrograms)(node).flatMap(visit2(this)));
    };
  }
  if (keys.includes("programNode")) {
    visitor.visitProgram = function visitProgram(node) {
      return merge(node, [
        ...node.pdas.flatMap(visit2(this)),
        ...node.accounts.flatMap(visit2(this)),
        ...node.instructions.flatMap(visit2(this)),
        ...node.definedTypes.flatMap(visit2(this)),
        ...node.errors.flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("pdaNode")) {
    visitor.visitPda = function visitPda(node) {
      return merge(node, node.seeds.flatMap(visit2(this)));
    };
  }
  if (keys.includes("accountNode")) {
    visitor.visitAccount = function visitAccount(node) {
      return merge(node, [
        ...visit2(this)(node.data),
        ...node.pda ? visit2(this)(node.pda) : [],
        ...(node.discriminators ?? []).flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("instructionNode")) {
    visitor.visitInstruction = function visitInstruction(node) {
      return merge(node, [
        ...node.accounts.flatMap(visit2(this)),
        ...node.arguments.flatMap(visit2(this)),
        ...(node.extraArguments ?? []).flatMap(visit2(this)),
        ...(node.remainingAccounts ?? []).flatMap(visit2(this)),
        ...(node.byteDeltas ?? []).flatMap(visit2(this)),
        ...(node.discriminators ?? []).flatMap(visit2(this)),
        ...(node.subInstructions ?? []).flatMap(visit2(this))
      ]);
    };
  }
  if (keys.includes("instructionAccountNode")) {
    visitor.visitInstructionAccount = function visitInstructionAccount(node) {
      return merge(node, [...node.defaultValue ? visit2(this)(node.defaultValue) : []]);
    };
  }
  if (keys.includes("instructionArgumentNode")) {
    visitor.visitInstructionArgument = function visitInstructionArgument(node) {
      return merge(node, [
        ...visit2(this)(node.type),
        ...node.defaultValue ? visit2(this)(node.defaultValue) : []
      ]);
    };
  }
  if (keys.includes("instructionRemainingAccountsNode")) {
    visitor.visitInstructionRemainingAccounts = function visitInstructionRemainingAccounts(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("instructionByteDeltaNode")) {
    visitor.visitInstructionByteDelta = function visitInstructionByteDelta(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("definedTypeNode")) {
    visitor.visitDefinedType = function visitDefinedType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("arrayTypeNode")) {
    visitor.visitArrayType = function visitArrayType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("enumTypeNode")) {
    visitor.visitEnumType = function visitEnumType(node) {
      return merge(node, [...visit2(this)(node.size), ...node.variants.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("enumStructVariantTypeNode")) {
    visitor.visitEnumStructVariantType = function visitEnumStructVariantType(node) {
      return merge(node, visit2(this)(node.struct));
    };
  }
  if (keys.includes("enumTupleVariantTypeNode")) {
    visitor.visitEnumTupleVariantType = function visitEnumTupleVariantType(node) {
      return merge(node, visit2(this)(node.tuple));
    };
  }
  if (keys.includes("mapTypeNode")) {
    visitor.visitMapType = function visitMapType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.key), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("optionTypeNode")) {
    visitor.visitOptionType = function visitOptionType(node) {
      return merge(node, [...visit2(this)(node.prefix), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("zeroableOptionTypeNode")) {
    visitor.visitZeroableOptionType = function visitZeroableOptionType(node) {
      return merge(node, [...visit2(this)(node.item), ...node.zeroValue ? visit2(this)(node.zeroValue) : []]);
    };
  }
  if (keys.includes("remainderOptionTypeNode")) {
    visitor.visitRemainderOptionType = function visitRemainderOptionType(node) {
      return merge(node, visit2(this)(node.item));
    };
  }
  if (keys.includes("booleanTypeNode")) {
    visitor.visitBooleanType = function visitBooleanType(node) {
      return merge(node, visit2(this)(node.size));
    };
  }
  if (keys.includes("setTypeNode")) {
    visitor.visitSetType = function visitSetType(node) {
      return merge(node, [...visit2(this)(node.count), ...visit2(this)(node.item)]);
    };
  }
  if (keys.includes("structTypeNode")) {
    visitor.visitStructType = function visitStructType(node) {
      return merge(node, node.fields.flatMap(visit2(this)));
    };
  }
  if (keys.includes("structFieldTypeNode")) {
    visitor.visitStructFieldType = function visitStructFieldType(node) {
      return merge(node, [
        ...visit2(this)(node.type),
        ...node.defaultValue ? visit2(this)(node.defaultValue) : []
      ]);
    };
  }
  if (keys.includes("tupleTypeNode")) {
    visitor.visitTupleType = function visitTupleType(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("amountTypeNode")) {
    visitor.visitAmountType = function visitAmountType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("dateTimeTypeNode")) {
    visitor.visitDateTimeType = function visitDateTimeType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("solAmountTypeNode")) {
    visitor.visitSolAmountType = function visitSolAmountType(node) {
      return merge(node, visit2(this)(node.number));
    };
  }
  if (keys.includes("prefixedCountNode")) {
    visitor.visitPrefixedCount = function visitPrefixedCount(node) {
      return merge(node, visit2(this)(node.prefix));
    };
  }
  if (keys.includes("arrayValueNode")) {
    visitor.visitArrayValue = function visitArrayValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("constantValueNode")) {
    visitor.visitConstantValue = function visitConstantValue(node) {
      return merge(node, [...visit2(this)(node.type), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("enumValueNode")) {
    visitor.visitEnumValue = function visitEnumValue(node) {
      return merge(node, [...visit2(this)(node.enum), ...node.value ? visit2(this)(node.value) : []]);
    };
  }
  if (keys.includes("mapValueNode")) {
    visitor.visitMapValue = function visitMapValue(node) {
      return merge(node, node.entries.flatMap(visit2(this)));
    };
  }
  if (keys.includes("mapEntryValueNode")) {
    visitor.visitMapEntryValue = function visitMapEntryValue(node) {
      return merge(node, [...visit2(this)(node.key), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("setValueNode")) {
    visitor.visitSetValue = function visitSetValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("someValueNode")) {
    visitor.visitSomeValue = function visitSomeValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("structValueNode")) {
    visitor.visitStructValue = function visitStructValue(node) {
      return merge(node, node.fields.flatMap(visit2(this)));
    };
  }
  if (keys.includes("structFieldValueNode")) {
    visitor.visitStructFieldValue = function visitStructFieldValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("tupleValueNode")) {
    visitor.visitTupleValue = function visitTupleValue(node) {
      return merge(node, node.items.flatMap(visit2(this)));
    };
  }
  if (keys.includes("constantPdaSeedNode")) {
    visitor.visitConstantPdaSeed = function visitConstantPdaSeed(node) {
      return merge(node, [...visit2(this)(node.type), ...visit2(this)(node.value)]);
    };
  }
  if (keys.includes("variablePdaSeedNode")) {
    visitor.visitVariablePdaSeed = function visitVariablePdaSeed(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("resolverValueNode")) {
    visitor.visitResolverValue = function visitResolverValue(node) {
      return merge(node, (node.dependsOn ?? []).flatMap(visit2(this)));
    };
  }
  if (keys.includes("conditionalValueNode")) {
    visitor.visitConditionalValue = function visitConditionalValue(node) {
      return merge(node, [
        ...visit2(this)(node.condition),
        ...node.value ? visit2(this)(node.value) : [],
        ...node.ifTrue ? visit2(this)(node.ifTrue) : [],
        ...node.ifFalse ? visit2(this)(node.ifFalse) : []
      ]);
    };
  }
  if (keys.includes("pdaValueNode")) {
    visitor.visitPdaValue = function visitPdaValue(node) {
      return merge(node, [...visit2(this)(node.pda), ...node.seeds.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("pdaSeedValueNode")) {
    visitor.visitPdaSeedValue = function visitPdaSeedValue(node) {
      return merge(node, visit2(this)(node.value));
    };
  }
  if (keys.includes("fixedSizeTypeNode")) {
    visitor.visitFixedSizeType = function visitFixedSizeType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("sizePrefixTypeNode")) {
    visitor.visitSizePrefixType = function visitSizePrefixType(node) {
      return merge(node, [...visit2(this)(node.prefix), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("preOffsetTypeNode")) {
    visitor.visitPreOffsetType = function visitPreOffsetType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("postOffsetTypeNode")) {
    visitor.visitPostOffsetType = function visitPostOffsetType(node) {
      return merge(node, visit2(this)(node.type));
    };
  }
  if (keys.includes("sentinelTypeNode")) {
    visitor.visitSentinelType = function visitSentinelType(node) {
      return merge(node, [...visit2(this)(node.sentinel), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("hiddenPrefixTypeNode")) {
    visitor.visitHiddenPrefixType = function visitHiddenPrefixType(node) {
      return merge(node, [...node.prefix.flatMap(visit2(this)), ...visit2(this)(node.type)]);
    };
  }
  if (keys.includes("hiddenSuffixTypeNode")) {
    visitor.visitHiddenSuffixType = function visitHiddenSuffixType(node) {
      return merge(node, [...visit2(this)(node.type), ...node.suffix.flatMap(visit2(this))]);
    };
  }
  if (keys.includes("constantDiscriminatorNode")) {
    visitor.visitConstantDiscriminator = function visitConstantDiscriminator(node) {
      return merge(node, visit2(this)(node.constant));
    };
  }
  if (keys.includes("accountLinkNode")) {
    visitor.visitAccountLink = function visitAccountLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("definedTypeLinkNode")) {
    visitor.visitDefinedTypeLink = function visitDefinedTypeLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("instructionLinkNode")) {
    visitor.visitInstructionLink = function visitInstructionLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  if (keys.includes("instructionAccountLinkNode")) {
    visitor.visitInstructionAccountLink = function visitInstructionAccountLink(node) {
      return merge(node, node.instruction ? visit2(this)(node.instruction) : []);
    };
  }
  if (keys.includes("instructionArgumentLinkNode")) {
    visitor.visitInstructionArgumentLink = function visitInstructionArgumentLink(node) {
      return merge(node, node.instruction ? visit2(this)(node.instruction) : []);
    };
  }
  if (keys.includes("pdaLinkNode")) {
    visitor.visitPdaLink = function visitPdaLink(node) {
      return merge(node, node.program ? visit2(this)(node.program) : []);
    };
  }
  return visitor;
}

// src/getByteSizeVisitor.ts
function getByteSizeVisitor(linkables, options = {}) {
  const stack = options.stack ?? new NodeStack();
  const visitedDefinedTypes = /* @__PURE__ */ new Map();
  const definedTypeStack = [];
  const sumSizes = (values) => values.reduce((all, one) => all === null || one === null ? null : all + one, 0);
  const baseVisitor = mergeVisitor(
    () => null,
    (_, values) => sumSizes(values),
    {
      keys: [
        ...import_nodes10.REGISTERED_TYPE_NODE_KINDS,
        "definedTypeLinkNode",
        "definedTypeNode",
        "accountNode",
        "instructionNode",
        "instructionArgumentNode"
      ]
    }
  );
  return pipe(
    baseVisitor,
    (v) => extendVisitor(v, {
      visitAccount(node, { self }) {
        return visit(node.data, self);
      },
      visitArrayType(node, { self }) {
        if (!(0, import_nodes10.isNode)(node.count, "fixedCountNode")) return null;
        const fixedSize = node.count.value;
        const itemSize = visit(node.item, self);
        const arraySize = itemSize !== null ? itemSize * fixedSize : null;
        return fixedSize === 0 ? 0 : arraySize;
      },
      visitDefinedType(node, { self }) {
        if (visitedDefinedTypes.has(node.name)) {
          return visitedDefinedTypes.get(node.name);
        }
        definedTypeStack.push(node.name);
        const child = visit(node.type, self);
        definedTypeStack.pop();
        visitedDefinedTypes.set(node.name, child);
        return child;
      },
      visitDefinedTypeLink(node, { self }) {
        const linkedDefinedPath = linkables.getPath(stack.getPath(node.kind));
        if (!linkedDefinedPath) return null;
        const linkedDefinedType = getLastNodeFromPath(linkedDefinedPath);
        if (definedTypeStack.includes(linkedDefinedType.name)) {
          return null;
        }
        stack.pushPath(linkedDefinedPath);
        const result = visit(linkedDefinedType, self);
        stack.popPath();
        return result;
      },
      visitEnumEmptyVariantType() {
        return 0;
      },
      visitEnumType(node, { self }) {
        const prefix = visit(node.size, self) ?? 1;
        if ((0, import_nodes10.isScalarEnum)(node)) return prefix;
        const variantSizes = node.variants.map((v2) => visit(v2, self));
        const allVariantHaveTheSameFixedSize = variantSizes.every((one, _, all) => one === all[0]);
        return allVariantHaveTheSameFixedSize && variantSizes.length > 0 && variantSizes[0] !== null ? variantSizes[0] + prefix : null;
      },
      visitFixedSizeType(node) {
        return node.size;
      },
      visitInstruction(node, { self }) {
        return sumSizes(node.arguments.map((arg) => visit(arg, self)));
      },
      visitInstructionArgument(node, { self }) {
        return visit(node.type, self);
      },
      visitNumberType(node) {
        if (node.format === "shortU16") return null;
        return parseInt(node.format.slice(1), 10) / 8;
      },
      visitOptionType(node, { self }) {
        if (!node.fixed) return null;
        const prefixSize = visit(node.prefix, self);
        const itemSize = visit(node.item, self);
        return itemSize !== null ? itemSize + prefixSize : null;
      },
      visitPublicKeyType() {
        return 32;
      }
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}

// src/getDebugStringVisitor.ts
function getDebugStringVisitor(options = {}) {
  const indent = options.indent ?? false;
  const indentSeparator = options.indentSeparator ?? "|   ";
  let stackLevel = -1;
  return pipe(
    mergeVisitor(
      (node) => {
        const details = getNodeDetails(node).join(".");
        if (indent) {
          return `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ""}`;
        }
        return `${node.kind}${details ? `[${details}]` : ""}`;
      },
      (node, values) => {
        const details = getNodeDetails(node).join(".");
        if (indent) {
          return [
            `${indentSeparator.repeat(stackLevel)}${node.kind}${details ? ` [${details}]` : ""}`,
            ...values
          ].join("\n");
        }
        return `${node.kind}${details ? `[${details}]` : ""}(${values.join(", ")})`;
      }
    ),
    (v) => interceptVisitor(v, (node, next) => {
      stackLevel += 1;
      const newNode = next(node);
      stackLevel -= 1;
      return newNode;
    })
  );
}
function getNodeDetails(node) {
  switch (node.kind) {
    case "programNode":
      return [node.name, node.publicKey];
    case "instructionAccountNode":
      return [
        node.name,
        ...node.isWritable ? ["writable"] : [],
        ...node.isSigner === true ? ["signer"] : [],
        ...node.isSigner === "either" ? ["optionalSigner"] : [],
        ...node.isOptional ? ["optional"] : []
      ];
    case "instructionRemainingAccountsNode":
      return [
        ...node.isOptional ? ["optional"] : [],
        ...node.isWritable ? ["writable"] : [],
        ...node.isSigner === true ? ["signer"] : [],
        ...node.isSigner === "either" ? ["optionalSigner"] : []
      ];
    case "instructionByteDeltaNode":
      return [...node.subtract ? ["subtract"] : [], ...node.withHeader ? ["withHeader"] : []];
    case "errorNode":
      return [node.code.toString(), node.name];
    case "accountLinkNode":
    case "definedTypeLinkNode":
    case "instructionAccountLinkNode":
    case "instructionArgumentLinkNode":
    case "instructionLinkNode":
    case "pdaLinkNode":
    case "programLinkNode":
      return [node.name];
    case "numberTypeNode":
      return [node.format, ...node.endian === "be" ? ["bigEndian"] : []];
    case "amountTypeNode":
      return [node.decimals.toString(), ...node.unit ? [node.unit] : []];
    case "stringTypeNode":
      return [node.encoding];
    case "optionTypeNode":
      return node.fixed ? ["fixed"] : [];
    case "fixedCountNode":
      return [node.value.toString()];
    case "numberValueNode":
      return [node.number.toString()];
    case "stringValueNode":
      return [node.string];
    case "booleanValueNode":
      return [node.boolean ? "true" : "false"];
    case "bytesValueNode":
      return [node.encoding, node.data];
    case "publicKeyValueNode":
      return [...node.identifier ? [`${node.identifier}`] : [], node.publicKey];
    case "enumValueNode":
      return [node.variant];
    case "resolverValueNode":
      return [node.name];
    case "constantDiscriminatorNode":
      return [...node.offset > 0 ? [`offset:${node.offset}`] : []];
    case "fieldDiscriminatorNode":
      return [node.name, ...node.offset > 0 ? [`offset:${node.offset}`] : []];
    case "sizeDiscriminatorNode":
      return [node.size.toString()];
    case "fixedSizeTypeNode":
      return [node.size.toString()];
    case "preOffsetTypeNode":
      return [node.offset.toString(), node.strategy ?? "relative"];
    case "postOffsetTypeNode":
      return [node.offset.toString(), node.strategy ?? "relative"];
    default:
      return "name" in node ? [node.name] : [];
  }
}

// src/getResolvedInstructionInputsVisitor.ts
var import_errors4 = require("@codama/errors");
var import_nodes11 = require("@codama/nodes");

// src/singleNodeVisitor.ts
function singleNodeVisitor(key, fn) {
  const visitor = {};
  visitor[getVisitFunctionName(key)] = fn;
  return visitor;
}
function rootNodeVisitor(fn) {
  return singleNodeVisitor("rootNode", fn);
}

// src/getResolvedInstructionInputsVisitor.ts
function getResolvedInstructionInputsVisitor(options = {}) {
  const includeDataArgumentValueNodes = options.includeDataArgumentValueNodes ?? false;
  let stack = [];
  let resolved = [];
  let visitedAccounts = /* @__PURE__ */ new Map();
  let visitedArgs = /* @__PURE__ */ new Map();
  function resolveInstructionInput(instruction, input) {
    if ((0, import_nodes11.isNode)(input, "instructionAccountNode") && visitedAccounts.has(input.name) || (0, import_nodes11.isNode)(input, "instructionArgumentNode") && visitedArgs.has(input.name)) {
      return;
    }
    const isCircular = stack.some(({ kind, name }) => kind === input.kind && name === input.name);
    if (isCircular) {
      const cycle = [...stack, input];
      throw new import_errors4.CodamaError(
        import_errors4.CODAMA_ERROR__VISITORS__CYCLIC_DEPENDENCY_DETECTED_WHEN_RESOLVING_INSTRUCTION_DEFAULT_VALUES,
        {
          cycle,
          formattedCycle: cycle.map(({ name }) => name).join(" -> "),
          instruction,
          instructionName: instruction.name
        }
      );
    }
    stack.push(input);
    const localResolved = input.kind === "instructionAccountNode" ? resolveInstructionAccount(instruction, input) : resolveInstructionArgument(instruction, input);
    stack.pop();
    resolved.push(localResolved);
    if (localResolved.kind === "instructionAccountNode") {
      visitedAccounts.set(input.name, localResolved);
    } else {
      visitedArgs.set(input.name, localResolved);
    }
  }
  function resolveInstructionAccount(instruction, account) {
    const dependsOn = getInstructionDependencies(account);
    resolveInstructionDependencies(instruction, account, dependsOn);
    const localResolved = {
      ...account,
      dependsOn,
      isPda: (0, import_nodes11.getAllInstructionArguments)(instruction).some(
        (argument) => (0, import_nodes11.isNode)(argument.defaultValue, "accountBumpValueNode") && argument.defaultValue.name === account.name
      ),
      resolvedIsOptional: !!account.isOptional,
      resolvedIsSigner: account.isSigner
    };
    switch (localResolved.defaultValue?.kind) {
      case "accountValueNode":
        const defaultAccount = visitedAccounts.get(localResolved.defaultValue.name);
        const resolvedIsPublicKey = account.isSigner === false && defaultAccount.isSigner === false;
        const resolvedIsSigner = account.isSigner === true && defaultAccount.isSigner === true;
        const resolvedIsOptionalSigner = !resolvedIsPublicKey && !resolvedIsSigner;
        localResolved.resolvedIsSigner = resolvedIsOptionalSigner ? "either" : resolvedIsSigner;
        localResolved.resolvedIsOptional = !!defaultAccount.isOptional;
        break;
      case "publicKeyValueNode":
      case "programLinkNode":
      case "programIdValueNode":
        localResolved.resolvedIsSigner = account.isSigner === false ? false : "either";
        localResolved.resolvedIsOptional = false;
        break;
      case "pdaValueNode":
        localResolved.resolvedIsSigner = account.isSigner === false ? false : "either";
        localResolved.resolvedIsOptional = false;
        const { seeds } = localResolved.defaultValue;
        seeds.forEach((seed) => {
          if (!(0, import_nodes11.isNode)(seed.value, "accountValueNode")) return;
          const dependency = visitedAccounts.get(seed.value.name);
          if (dependency.resolvedIsOptional) {
            throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__VISITORS__CANNOT_USE_OPTIONAL_ACCOUNT_AS_PDA_SEED_VALUE, {
              instruction,
              instructionAccount: account,
              instructionAccountName: account.name,
              instructionName: instruction.name,
              seed,
              seedName: seed.name,
              seedValueName: seed.value.name
            });
          }
        });
        break;
      case "identityValueNode":
      case "payerValueNode":
      case "resolverValueNode":
        localResolved.resolvedIsOptional = false;
        break;
      default:
        break;
    }
    return localResolved;
  }
  function resolveInstructionArgument(instruction, argument) {
    const dependsOn = getInstructionDependencies(argument);
    resolveInstructionDependencies(instruction, argument, dependsOn);
    return { ...argument, dependsOn };
  }
  function resolveInstructionDependencies(instruction, parent, dependencies) {
    dependencies.forEach((dependency) => {
      let input = null;
      if ((0, import_nodes11.isNode)(dependency, "accountValueNode")) {
        const dependencyAccount = instruction.accounts.find((a) => a.name === dependency.name);
        if (!dependencyAccount) {
          throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {
            dependency,
            dependencyKind: dependency.kind,
            dependencyName: dependency.name,
            instruction,
            instructionName: instruction.name,
            parent,
            parentKind: parent.kind,
            parentName: parent.name
          });
        }
        input = { ...dependencyAccount };
      } else if ((0, import_nodes11.isNode)(dependency, "argumentValueNode")) {
        const dependencyArgument = (0, import_nodes11.getAllInstructionArguments)(instruction).find(
          (a) => a.name === dependency.name
        );
        if (!dependencyArgument) {
          throw new import_errors4.CodamaError(import_errors4.CODAMA_ERROR__VISITORS__INVALID_INSTRUCTION_DEFAULT_VALUE_DEPENDENCY, {
            dependency,
            dependencyKind: dependency.kind,
            dependencyName: dependency.name,
            instruction,
            instructionName: instruction.name,
            parent,
            parentKind: parent.kind,
            parentName: parent.name
          });
        }
        input = { ...dependencyArgument };
      }
      if (input) {
        resolveInstructionInput(instruction, input);
      }
    });
  }
  return singleNodeVisitor("instructionNode", (node) => {
    stack = [];
    resolved = [];
    visitedAccounts = /* @__PURE__ */ new Map();
    visitedArgs = /* @__PURE__ */ new Map();
    const inputs = [
      ...node.accounts,
      ...node.arguments.filter((a) => {
        if (includeDataArgumentValueNodes) return a.defaultValue;
        return a.defaultValue && !(0, import_nodes11.isNode)(a.defaultValue, import_nodes11.VALUE_NODES);
      }),
      ...(node.extraArguments ?? []).filter((a) => a.defaultValue)
    ];
    inputs.forEach((input) => {
      resolveInstructionInput(node, input);
    });
    return resolved;
  });
}
function deduplicateInstructionDependencies(dependencies) {
  const accounts = /* @__PURE__ */ new Map();
  const args = /* @__PURE__ */ new Map();
  dependencies.forEach((dependency) => {
    if ((0, import_nodes11.isNode)(dependency, "accountValueNode")) {
      accounts.set(dependency.name, dependency);
    } else if ((0, import_nodes11.isNode)(dependency, "argumentValueNode")) {
      args.set(dependency.name, dependency);
    }
  });
  return [...accounts.values(), ...args.values()];
}
function getInstructionDependencies(input) {
  if ((0, import_nodes11.isNode)(input, "instructionNode")) {
    return deduplicateInstructionDependencies([
      ...input.accounts.flatMap(getInstructionDependencies),
      ...input.arguments.flatMap(getInstructionDependencies),
      ...(input.extraArguments ?? []).flatMap(getInstructionDependencies)
    ]);
  }
  if (!input.defaultValue) return [];
  const getNestedDependencies = (defaultValue) => {
    if (!defaultValue) return [];
    return getInstructionDependencies({ ...input, defaultValue });
  };
  if ((0, import_nodes11.isNode)(input.defaultValue, ["accountValueNode", "accountBumpValueNode"])) {
    return [(0, import_nodes11.accountValueNode)(input.defaultValue.name)];
  }
  if ((0, import_nodes11.isNode)(input.defaultValue, ["argumentValueNode"])) {
    return [(0, import_nodes11.argumentValueNode)(input.defaultValue.name)];
  }
  if ((0, import_nodes11.isNode)(input.defaultValue, "pdaValueNode")) {
    const dependencies = /* @__PURE__ */ new Map();
    input.defaultValue.seeds.forEach((seed) => {
      if ((0, import_nodes11.isNode)(seed.value, ["accountValueNode", "argumentValueNode"])) {
        dependencies.set(seed.value.name, { ...seed.value });
      }
    });
    return [...dependencies.values()];
  }
  if ((0, import_nodes11.isNode)(input.defaultValue, "resolverValueNode")) {
    return input.defaultValue.dependsOn ?? [];
  }
  if ((0, import_nodes11.isNode)(input.defaultValue, "conditionalValueNode")) {
    return deduplicateInstructionDependencies([
      ...getNestedDependencies(input.defaultValue.condition),
      ...getNestedDependencies(input.defaultValue.ifTrue),
      ...getNestedDependencies(input.defaultValue.ifFalse)
    ]);
  }
  return [];
}

// src/getUniqueHashStringVisitor.ts
var import_json_stable_stringify = __toESM(require("json-stable-stringify"));

// src/nonNullableIdentityVisitor.ts
function nonNullableIdentityVisitor(options = {}) {
  return identityVisitor(options);
}

// src/removeDocsVisitor.ts
function removeDocsVisitor(options = {}) {
  return interceptVisitor(nonNullableIdentityVisitor(options), (node, next) => {
    if ("docs" in node) {
      return next({ ...node, docs: [] });
    }
    return next(node);
  });
}

// src/getUniqueHashStringVisitor.ts
function getUniqueHashStringVisitor(options = {}) {
  const removeDocs = options.removeDocs ?? false;
  if (!removeDocs) {
    return staticVisitor((node) => (0, import_json_stable_stringify.default)(node));
  }
  return mapVisitor(removeDocsVisitor(), (node) => (0, import_json_stable_stringify.default)(node));
}

// src/interceptFirstVisitVisitor.ts
function interceptFirstVisitVisitor(visitor, interceptor) {
  let isFirstVisit = true;
  return interceptVisitor(visitor, (node, next) => {
    try {
      if (isFirstVisit) {
        isFirstVisit = false;
        const result = interceptor(node, next);
        isFirstVisit = true;
        return result;
      }
      return next(node);
    } catch (error) {
      isFirstVisit = true;
      throw error;
    }
  });
}

// src/LinkableDictionary.ts
var import_errors5 = require("@codama/errors");
var import_nodes12 = require("@codama/nodes");
var LINKABLE_NODES = [
  "accountNode",
  "definedTypeNode",
  "instructionAccountNode",
  "instructionArgumentNode",
  "instructionNode",
  "pdaNode",
  "programNode"
];
var LinkableDictionary = class {
  programs = /* @__PURE__ */ new Map();
  recordPath(linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const programDictionary = this.getOrCreateProgramDictionary(linkablePath);
    if (!programDictionary) return this;
    const instructionDictionary = this.getOrCreateInstructionDictionary(programDictionary, linkablePath);
    if (isNodePath(linkablePath, "accountNode")) {
      programDictionary.accounts.set(linkableNode.name, linkablePath);
    } else if (isNodePath(linkablePath, "definedTypeNode")) {
      programDictionary.definedTypes.set(linkableNode.name, linkablePath);
    } else if (isNodePath(linkablePath, "pdaNode")) {
      programDictionary.pdas.set(linkableNode.name, linkablePath);
    } else if (instructionDictionary && isNodePath(linkablePath, "instructionAccountNode")) {
      instructionDictionary.accounts.set(linkableNode.name, linkablePath);
    } else if (instructionDictionary && isNodePath(linkablePath, "instructionArgumentNode")) {
      instructionDictionary.arguments.set(linkableNode.name, linkablePath);
    }
    return this;
  }
  getPathOrThrow(linkPath) {
    const linkablePath = this.getPath(linkPath);
    if (!linkablePath) {
      const linkNode = getLastNodeFromPath(linkPath);
      throw new import_errors5.CodamaError(import_errors5.CODAMA_ERROR__LINKED_NODE_NOT_FOUND, {
        kind: linkNode.kind,
        linkNode,
        name: linkNode.name,
        path: linkPath
      });
    }
    return linkablePath;
  }
  getPath(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    const programDictionary = this.getProgramDictionary(linkPath);
    if (!programDictionary) return void 0;
    const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);
    if ((0, import_nodes12.isNode)(linkNode, "accountLinkNode")) {
      return programDictionary.accounts.get(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "definedTypeLinkNode")) {
      return programDictionary.definedTypes.get(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionAccountLinkNode")) {
      return instructionDictionary?.accounts.get(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionArgumentLinkNode")) {
      return instructionDictionary?.arguments.get(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionLinkNode")) {
      return instructionDictionary?.instruction;
    } else if ((0, import_nodes12.isNode)(linkNode, "pdaLinkNode")) {
      return programDictionary.pdas.get(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "programLinkNode")) {
      return programDictionary.program;
    }
    return void 0;
  }
  getOrThrow(linkPath) {
    return getLastNodeFromPath(this.getPathOrThrow(linkPath));
  }
  get(linkPath) {
    const path = this.getPath(linkPath);
    return path ? getLastNodeFromPath(path) : void 0;
  }
  has(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    const programDictionary = this.getProgramDictionary(linkPath);
    if (!programDictionary) return false;
    const instructionDictionary = this.getInstructionDictionary(programDictionary, linkPath);
    if ((0, import_nodes12.isNode)(linkNode, "accountLinkNode")) {
      return programDictionary.accounts.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "definedTypeLinkNode")) {
      return programDictionary.definedTypes.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionAccountLinkNode")) {
      return !!instructionDictionary && instructionDictionary.accounts.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionArgumentLinkNode")) {
      return !!instructionDictionary && instructionDictionary.arguments.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "instructionLinkNode")) {
      return programDictionary.instructions.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "pdaLinkNode")) {
      return programDictionary.pdas.has(linkNode.name);
    } else if ((0, import_nodes12.isNode)(linkNode, "programLinkNode")) {
      return true;
    }
    return false;
  }
  getOrCreateProgramDictionary(linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const programNode2 = (0, import_nodes12.isNode)(linkableNode, "programNode") ? linkableNode : findProgramNodeFromPath(linkablePath);
    if (!programNode2) return void 0;
    let programDictionary = this.programs.get(programNode2.name);
    if (!programDictionary) {
      programDictionary = {
        accounts: /* @__PURE__ */ new Map(),
        definedTypes: /* @__PURE__ */ new Map(),
        instructions: /* @__PURE__ */ new Map(),
        pdas: /* @__PURE__ */ new Map(),
        program: getNodePathUntilLastNode(linkablePath, "programNode")
      };
      this.programs.set(programNode2.name, programDictionary);
    }
    return programDictionary;
  }
  getOrCreateInstructionDictionary(programDictionary, linkablePath) {
    const linkableNode = getLastNodeFromPath(linkablePath);
    const instructionNode2 = (0, import_nodes12.isNode)(linkableNode, "instructionNode") ? linkableNode : findInstructionNodeFromPath(linkablePath);
    if (!instructionNode2) return void 0;
    let instructionDictionary = programDictionary.instructions.get(instructionNode2.name);
    if (!instructionDictionary) {
      instructionDictionary = {
        accounts: /* @__PURE__ */ new Map(),
        arguments: /* @__PURE__ */ new Map(),
        instruction: getNodePathUntilLastNode(linkablePath, "instructionNode")
      };
      programDictionary.instructions.set(instructionNode2.name, instructionDictionary);
    }
    return instructionDictionary;
  }
  getProgramDictionary(linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    let programName = void 0;
    if ((0, import_nodes12.isNode)(linkNode, "programLinkNode")) {
      programName = linkNode.name;
    } else if ("program" in linkNode) {
      programName = linkNode.program?.name;
    } else if ("instruction" in linkNode) {
      programName = linkNode.instruction?.program?.name;
    }
    programName = programName ?? findProgramNodeFromPath(linkPath)?.name;
    return programName ? this.programs.get(programName) : void 0;
  }
  getInstructionDictionary(programDictionary, linkPath) {
    const linkNode = getLastNodeFromPath(linkPath);
    let instructionName = void 0;
    if ((0, import_nodes12.isNode)(linkNode, "instructionLinkNode")) {
      instructionName = linkNode.name;
    } else if ("instruction" in linkNode) {
      instructionName = linkNode.instruction?.name;
    }
    instructionName = instructionName ?? findInstructionNodeFromPath(linkPath)?.name;
    return instructionName ? programDictionary.instructions.get(instructionName) : void 0;
  }
};

// src/recordLinkablesVisitor.ts
var import_nodes13 = require("@codama/nodes");

// src/voidVisitor.ts
function voidVisitor(options = {}) {
  return mergeVisitor(
    () => void 0,
    () => void 0,
    options
  );
}

// src/recordLinkablesVisitor.ts
function getRecordLinkablesVisitor(linkables) {
  const stack = new NodeStack();
  return pipe(
    voidVisitor(),
    (v) => interceptVisitor(v, (node, next) => {
      if ((0, import_nodes13.isNode)(node, LINKABLE_NODES)) {
        linkables.recordPath(stack.getPath(LINKABLE_NODES));
      }
      return next(node);
    }),
    (v) => recordNodeStackVisitor(v, stack)
  );
}
function recordLinkablesOnFirstVisitVisitor(visitor, linkables) {
  const recordingVisitor = getRecordLinkablesVisitor(linkables);
  return pipe(
    visitor,
    (v) => interceptFirstVisitVisitor(v, (node, next) => {
      visit(node, recordingVisitor);
      return next(node);
    })
  );
}

// src/tapVisitor.ts
function tapVisitor(visitor, key, tap) {
  const newVisitor = { ...visitor };
  newVisitor[getVisitFunctionName(key)] = function tappedVisitNode(node) {
    tap(node);
    const parentFunction = visitor[getVisitFunctionName(key)];
    return parentFunction.bind(this)(node);
  };
  return newVisitor;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LINKABLE_NODES,
  LinkableDictionary,
  NodeStack,
  assertIsNodePath,
  bottomUpTransformerVisitor,
  consoleLogVisitor,
  deduplicateInstructionDependencies,
  deleteNodesVisitor,
  extendVisitor,
  findFirstNodeFromPath,
  findInstructionNodeFromPath,
  findLastNodeFromPath,
  findProgramNodeFromPath,
  getByteSizeVisitor,
  getConjunctiveNodeSelectorFunction,
  getDebugStringVisitor,
  getInstructionDependencies,
  getLastNodeFromPath,
  getNodePathUntilLastNode,
  getNodeSelectorFunction,
  getRecordLinkablesVisitor,
  getResolvedInstructionInputsVisitor,
  getUniqueHashStringVisitor,
  getVisitFunctionName,
  identityVisitor,
  interceptFirstVisitVisitor,
  interceptVisitor,
  isFilledNodePath,
  isNodePath,
  mapVisitor,
  mergeVisitor,
  nodePathToString,
  nodePathToStringArray,
  nonNullableIdentityVisitor,
  pipe,
  recordLinkablesOnFirstVisitVisitor,
  recordNodeStackVisitor,
  removeDocsVisitor,
  rootNodeVisitor,
  singleNodeVisitor,
  staticVisitor,
  tapVisitor,
  topDownTransformerVisitor,
  visit,
  visitOrElse,
  voidVisitor
});
//# sourceMappingURL=index.node.cjs.map