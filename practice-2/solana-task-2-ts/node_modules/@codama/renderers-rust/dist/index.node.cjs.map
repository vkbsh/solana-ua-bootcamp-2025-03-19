{"version":3,"sources":["../src/index.ts","../src/ImportMap.ts","../src/getRenderMapVisitor.ts","../src/getTypeManifestVisitor.ts","../src/utils/codecs.ts","../src/utils/linkOverrides.ts","../src/utils/render.ts","../src/utils/traitOptions.ts","../src/renderValueNodeVisitor.ts","../src/renderVisitor.ts"],"sourcesContent":["export * from './ImportMap';\nexport * from './getRenderMapVisitor';\nexport * from './getTypeManifestVisitor';\nexport * from './renderVisitor';\n\nexport { renderVisitor as default } from './renderVisitor';\n","import { TypeManifest } from './getTypeManifestVisitor';\n\nconst DEFAULT_MODULE_MAP: Record<string, string> = {\n    generated: 'crate::generated',\n    generatedAccounts: 'crate::generated::accounts',\n    generatedErrors: 'crate::generated::errors',\n    generatedInstructions: 'crate::generated::instructions',\n    generatedTypes: 'crate::generated::types',\n    hooked: 'crate::hooked',\n    mplEssentials: 'mpl_toolbox',\n    mplToolbox: 'mpl_toolbox',\n};\n\nexport class ImportMap {\n    protected readonly _imports: Set<string> = new Set();\n\n    protected readonly _aliases: Map<string, string> = new Map();\n\n    get imports(): Set<string> {\n        return this._imports;\n    }\n\n    get aliases(): Map<string, string> {\n        return this._aliases;\n    }\n\n    add(imports: Set<string> | string[] | string): ImportMap {\n        const newImports = typeof imports === 'string' ? [imports] : imports;\n        newImports.forEach(i => this._imports.add(i));\n        return this;\n    }\n\n    remove(imports: Set<string> | string[] | string): ImportMap {\n        const importsToRemove = typeof imports === 'string' ? [imports] : imports;\n        importsToRemove.forEach(i => this._imports.delete(i));\n        return this;\n    }\n\n    mergeWith(...others: ImportMap[]): ImportMap {\n        others.forEach(other => {\n            this.add(other._imports);\n            other._aliases.forEach((alias, importName) => this.addAlias(importName, alias));\n        });\n        return this;\n    }\n\n    mergeWithManifest(manifest: TypeManifest): ImportMap {\n        return this.mergeWith(manifest.imports);\n    }\n\n    addAlias(importName: string, alias: string): ImportMap {\n        this._aliases.set(importName, alias);\n        return this;\n    }\n\n    isEmpty(): boolean {\n        return this._imports.size === 0;\n    }\n\n    resolveDependencyMap(dependencies: Record<string, string>): ImportMap {\n        const dependencyMap = { ...DEFAULT_MODULE_MAP, ...dependencies };\n        const newImportMap = new ImportMap();\n        const resolveDependency = (i: string): string => {\n            const dependencyKey = Object.keys(dependencyMap).find(key => i.startsWith(`${key}::`));\n            if (!dependencyKey) return i;\n            const dependencyValue = dependencyMap[dependencyKey];\n            return dependencyValue + i.slice(dependencyKey.length);\n        };\n        this._imports.forEach(i => newImportMap.add(resolveDependency(i)));\n        this._aliases.forEach((alias, i) => newImportMap.addAlias(resolveDependency(i), alias));\n        return newImportMap;\n    }\n\n    toString(dependencies: Record<string, string>): string {\n        const resolvedMap = this.resolveDependencyMap(dependencies);\n        const importStatements = [...resolvedMap.imports].map(i => {\n            const alias = resolvedMap.aliases.get(i);\n            if (alias) return `use ${i} as ${alias};`;\n            return `use ${i};`;\n        });\n        return importStatements.join('\\n');\n    }\n}\n","import { logWarn } from '@codama/errors';\nimport {\n    getAllAccounts,\n    getAllDefinedTypes,\n    getAllInstructionsWithSubs,\n    getAllPrograms,\n    InstructionNode,\n    isNode,\n    isNodeFilter,\n    pascalCase,\n    ProgramNode,\n    resolveNestedTypeNode,\n    snakeCase,\n    structTypeNodeFromInstructionArgumentNodes,\n    VALUE_NODES,\n} from '@codama/nodes';\nimport { RenderMap } from '@codama/renderers-core';\nimport {\n    extendVisitor,\n    LinkableDictionary,\n    NodeStack,\n    pipe,\n    recordLinkablesOnFirstVisitVisitor,\n    recordNodeStackVisitor,\n    staticVisitor,\n    visit,\n} from '@codama/visitors-core';\n\nimport { getTypeManifestVisitor } from './getTypeManifestVisitor';\nimport { ImportMap } from './ImportMap';\nimport { renderValueNode } from './renderValueNodeVisitor';\nimport { getImportFromFactory, getTraitsFromNodeFactory, LinkOverrides, render, TraitOptions } from './utils';\n\nexport type GetRenderMapOptions = {\n    anchorTraits?: boolean;\n    defaultTraitOverrides?: string[];\n    dependencyMap?: Record<string, string>;\n    linkOverrides?: LinkOverrides;\n    renderParentInstructions?: boolean;\n    traitOptions?: TraitOptions;\n};\n\nexport function getRenderMapVisitor(options: GetRenderMapOptions = {}) {\n    const linkables = new LinkableDictionary();\n    const stack = new NodeStack();\n    let program: ProgramNode | null = null;\n\n    const renderParentInstructions = options.renderParentInstructions ?? false;\n    const dependencyMap = options.dependencyMap ?? {};\n    const getImportFrom = getImportFromFactory(options.linkOverrides ?? {});\n    const getTraitsFromNode = getTraitsFromNodeFactory(options.traitOptions);\n    const typeManifestVisitor = getTypeManifestVisitor({ getImportFrom, getTraitsFromNode });\n    const anchorTraits = options.anchorTraits ?? true;\n\n    return pipe(\n        staticVisitor(() => new RenderMap(), {\n            keys: ['rootNode', 'programNode', 'instructionNode', 'accountNode', 'definedTypeNode'],\n        }),\n        v =>\n            extendVisitor(v, {\n                visitAccount(node) {\n                    const typeManifest = visit(node, typeManifestVisitor);\n\n                    // Seeds.\n                    const seedsImports = new ImportMap();\n                    const pda = node.pda ? linkables.get([...stack.getPath(), node.pda]) : undefined;\n                    const pdaSeeds = pda?.seeds ?? [];\n                    const seeds = pdaSeeds.map(seed => {\n                        if (isNode(seed, 'variablePdaSeedNode')) {\n                            const seedManifest = visit(seed.type, typeManifestVisitor);\n                            seedsImports.mergeWith(seedManifest.imports);\n                            const resolvedType = resolveNestedTypeNode(seed.type);\n                            return { ...seed, resolvedType, typeManifest: seedManifest };\n                        }\n                        if (isNode(seed.value, 'programIdValueNode')) {\n                            return seed;\n                        }\n                        const seedManifest = visit(seed.type, typeManifestVisitor);\n                        const valueManifest = renderValueNode(seed.value, getImportFrom, true);\n                        seedsImports.mergeWith(valueManifest.imports);\n                        const resolvedType = resolveNestedTypeNode(seed.type);\n                        return { ...seed, resolvedType, typeManifest: seedManifest, valueManifest };\n                    });\n                    const hasVariableSeeds = pdaSeeds.filter(isNodeFilter('variablePdaSeedNode')).length > 0;\n                    const constantSeeds = seeds\n                        .filter(isNodeFilter('constantPdaSeedNode'))\n                        .filter(seed => !isNode(seed.value, 'programIdValueNode'));\n\n                    const { imports } = typeManifest;\n\n                    if (hasVariableSeeds) {\n                        imports.mergeWith(seedsImports);\n                    }\n\n                    return new RenderMap().add(\n                        `accounts/${snakeCase(node.name)}.rs`,\n                        render('accountsPage.njk', {\n                            account: node,\n                            anchorTraits,\n                            constantSeeds,\n                            hasVariableSeeds,\n                            imports: imports\n                                .remove(`generatedAccounts::${pascalCase(node.name)}`)\n                                .toString(dependencyMap),\n                            pda,\n                            program,\n                            seeds,\n                            typeManifest,\n                        }),\n                    );\n                },\n\n                visitDefinedType(node) {\n                    const typeManifest = visit(node, typeManifestVisitor);\n                    const imports = new ImportMap().mergeWithManifest(typeManifest);\n\n                    return new RenderMap().add(\n                        `types/${snakeCase(node.name)}.rs`,\n                        render('definedTypesPage.njk', {\n                            definedType: node,\n                            imports: imports.remove(`generatedTypes::${pascalCase(node.name)}`).toString(dependencyMap),\n                            typeManifest,\n                        }),\n                    );\n                },\n\n                visitInstruction(node) {\n                    // Imports.\n                    const imports = new ImportMap();\n\n                    // canMergeAccountsAndArgs\n                    const accountsAndArgsConflicts = getConflictsForInstructionAccountsAndArgs(node);\n                    if (accountsAndArgsConflicts.length > 0) {\n                        logWarn(\n                            `[Rust] Accounts and args of instruction [${node.name}] have the following ` +\n                                `conflicting attributes [${accountsAndArgsConflicts.join(', ')}]. ` +\n                                `Thus, the conflicting arguments will be suffixed with \"_arg\". ` +\n                                'You may want to rename the conflicting attributes.',\n                        );\n                    }\n\n                    // Instruction args.\n                    const instructionArgs: {\n                        default: boolean;\n                        innerOptionType: string | null;\n                        name: string;\n                        optional: boolean;\n                        type: string;\n                        value: string | null;\n                    }[] = [];\n                    let hasArgs = false;\n                    let hasOptional = false;\n\n                    node.arguments.forEach(argument => {\n                        const argumentVisitor = getTypeManifestVisitor({\n                            getImportFrom,\n                            getTraitsFromNode,\n                            nestedStruct: true,\n                            parentName: `${pascalCase(node.name)}InstructionData`,\n                        });\n                        const manifest = visit(argument.type, argumentVisitor);\n                        imports.mergeWith(manifest.imports);\n                        const innerOptionType = isNode(argument.type, 'optionTypeNode')\n                            ? manifest.type.slice('Option<'.length, -1)\n                            : null;\n\n                        const hasDefaultValue = !!argument.defaultValue && isNode(argument.defaultValue, VALUE_NODES);\n                        let renderValue: string | null = null;\n                        if (hasDefaultValue) {\n                            const { imports: argImports, render: value } = renderValueNode(\n                                argument.defaultValue,\n                                getImportFrom,\n                            );\n                            imports.mergeWith(argImports);\n                            renderValue = value;\n                        }\n\n                        hasArgs = hasArgs || argument.defaultValueStrategy !== 'omitted';\n                        hasOptional = hasOptional || (hasDefaultValue && argument.defaultValueStrategy !== 'omitted');\n\n                        const name = accountsAndArgsConflicts.includes(argument.name)\n                            ? `${argument.name}_arg`\n                            : argument.name;\n\n                        instructionArgs.push({\n                            default: hasDefaultValue && argument.defaultValueStrategy === 'omitted',\n                            innerOptionType,\n                            name,\n                            optional: hasDefaultValue && argument.defaultValueStrategy !== 'omitted',\n                            type: manifest.type,\n                            value: renderValue,\n                        });\n                    });\n\n                    const struct = structTypeNodeFromInstructionArgumentNodes(node.arguments);\n                    const structVisitor = getTypeManifestVisitor({\n                        getImportFrom,\n                        getTraitsFromNode,\n                        parentName: `${pascalCase(node.name)}InstructionData`,\n                    });\n                    const typeManifest = visit(struct, structVisitor);\n\n                    const dataTraits = getTraitsFromNode(node);\n                    imports.mergeWith(dataTraits.imports);\n\n                    return new RenderMap().add(\n                        `instructions/${snakeCase(node.name)}.rs`,\n                        render('instructionsPage.njk', {\n                            dataTraits: dataTraits.render,\n                            hasArgs,\n                            hasOptional,\n                            imports: imports\n                                .remove(`generatedInstructions::${pascalCase(node.name)}`)\n                                .toString(dependencyMap),\n                            instruction: node,\n                            instructionArgs,\n                            program,\n                            typeManifest,\n                        }),\n                    );\n                },\n\n                visitProgram(node, { self }) {\n                    program = node;\n                    const renderMap = new RenderMap()\n                        .mergeWith(...node.accounts.map(account => visit(account, self)))\n                        .mergeWith(...node.definedTypes.map(type => visit(type, self)))\n                        .mergeWith(\n                            ...getAllInstructionsWithSubs(node, {\n                                leavesOnly: !renderParentInstructions,\n                            }).map(ix => visit(ix, self)),\n                        );\n\n                    // Errors.\n                    if (node.errors.length > 0) {\n                        renderMap.add(\n                            `errors/${snakeCase(node.name)}.rs`,\n                            render('errorsPage.njk', {\n                                errors: node.errors,\n                                imports: new ImportMap().toString(dependencyMap),\n                                program: node,\n                            }),\n                        );\n                    }\n\n                    program = null;\n                    return renderMap;\n                },\n\n                visitRoot(node, { self }) {\n                    const programsToExport = getAllPrograms(node);\n                    const accountsToExport = getAllAccounts(node);\n                    const instructionsToExport = getAllInstructionsWithSubs(node, {\n                        leavesOnly: !renderParentInstructions,\n                    });\n                    const definedTypesToExport = getAllDefinedTypes(node);\n                    const hasAnythingToExport =\n                        programsToExport.length > 0 ||\n                        accountsToExport.length > 0 ||\n                        instructionsToExport.length > 0 ||\n                        definedTypesToExport.length > 0;\n\n                    const ctx = {\n                        accountsToExport,\n                        definedTypesToExport,\n                        hasAnythingToExport,\n                        instructionsToExport,\n                        programsToExport,\n                        root: node,\n                    };\n\n                    const map = new RenderMap();\n                    if (accountsToExport.length > 0) {\n                        map.add('shared.rs', render('sharedPage.njk', ctx));\n                    }\n                    if (programsToExport.length > 0) {\n                        map.add('programs.rs', render('programsMod.njk', ctx)).add(\n                            'errors/mod.rs',\n                            render('errorsMod.njk', ctx),\n                        );\n                    }\n                    if (accountsToExport.length > 0) {\n                        map.add('accounts/mod.rs', render('accountsMod.njk', ctx));\n                    }\n                    if (instructionsToExport.length > 0) {\n                        map.add('instructions/mod.rs', render('instructionsMod.njk', ctx));\n                    }\n                    if (definedTypesToExport.length > 0) {\n                        map.add('types/mod.rs', render('definedTypesMod.njk', ctx));\n                    }\n\n                    return map\n                        .add('mod.rs', render('rootMod.njk', ctx))\n                        .mergeWith(...getAllPrograms(node).map(p => visit(p, self)));\n                },\n            }),\n        v => recordNodeStackVisitor(v, stack),\n        v => recordLinkablesOnFirstVisitVisitor(v, linkables),\n    );\n}\n\nfunction getConflictsForInstructionAccountsAndArgs(instruction: InstructionNode): string[] {\n    const allNames = [\n        ...instruction.accounts.map(account => account.name),\n        ...instruction.arguments.map(argument => argument.name),\n    ];\n    const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);\n    return [...new Set(duplicates)];\n}\n","import { CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, CodamaError } from '@codama/errors';\nimport {\n    arrayTypeNode,\n    CountNode,\n    definedTypeNode,\n    fixedCountNode,\n    isNode,\n    NumberTypeNode,\n    numberTypeNode,\n    parseDocs,\n    pascalCase,\n    prefixedCountNode,\n    REGISTERED_TYPE_NODE_KINDS,\n    remainderCountNode,\n    resolveNestedTypeNode,\n    snakeCase,\n} from '@codama/nodes';\nimport { extendVisitor, mergeVisitor, pipe, visit } from '@codama/visitors-core';\n\nimport { ImportMap } from './ImportMap';\nimport { GetImportFromFunction, GetTraitsFromNodeFunction, rustDocblock } from './utils';\n\nexport type TypeManifest = {\n    imports: ImportMap;\n    nestedStructs: string[];\n    type: string;\n};\n\nexport function getTypeManifestVisitor(options: {\n    getImportFrom: GetImportFromFunction;\n    getTraitsFromNode: GetTraitsFromNodeFunction;\n    nestedStruct?: boolean;\n    parentName?: string | null;\n}) {\n    const { getImportFrom, getTraitsFromNode } = options;\n    let parentName: string | null = options.parentName ?? null;\n    let nestedStruct: boolean = options.nestedStruct ?? false;\n    let inlineStruct: boolean = false;\n    let parentSize: NumberTypeNode | number | null = null;\n\n    return pipe(\n        mergeVisitor(\n            (): TypeManifest => ({ imports: new ImportMap(), nestedStructs: [], type: '' }),\n            (_, values) => ({\n                ...mergeManifests(values),\n                type: values.map(v => v.type).join('\\n'),\n            }),\n            { keys: [...REGISTERED_TYPE_NODE_KINDS, 'definedTypeLinkNode', 'definedTypeNode', 'accountNode'] },\n        ),\n        v =>\n            extendVisitor(v, {\n                visitAccount(account, { self }) {\n                    parentName = pascalCase(account.name);\n                    const manifest = visit(account.data, self);\n                    const traits = getTraitsFromNode(account);\n                    manifest.imports.mergeWith(traits.imports);\n                    parentName = null;\n                    return {\n                        ...manifest,\n                        type: traits.render + manifest.type,\n                    };\n                },\n\n                visitArrayType(arrayType, { self }) {\n                    const childManifest = visit(arrayType.item, self);\n\n                    if (isNode(arrayType.count, 'fixedCountNode')) {\n                        return {\n                            ...childManifest,\n                            type: `[${childManifest.type}; ${arrayType.count.value}]`,\n                        };\n                    }\n\n                    if (isNode(arrayType.count, 'remainderCountNode')) {\n                        childManifest.imports.add('kaigan::types::RemainderVec');\n                        return {\n                            ...childManifest,\n                            type: `RemainderVec<${childManifest.type}>`,\n                        };\n                    }\n\n                    const prefix = resolveNestedTypeNode(arrayType.count.prefix);\n                    if (prefix.endian === 'le') {\n                        switch (prefix.format) {\n                            case 'u32':\n                                return {\n                                    ...childManifest,\n                                    type: `Vec<${childManifest.type}>`,\n                                };\n                            case 'u8':\n                            case 'u16':\n                            case 'u64': {\n                                const prefixFormat = prefix.format.toUpperCase();\n                                childManifest.imports.add(`kaigan::types::${prefixFormat}PrefixVec`);\n                                return {\n                                    ...childManifest,\n                                    type: `${prefixFormat}PrefixVec<${childManifest.type}>`,\n                                };\n                            }\n                            case 'shortU16': {\n                                childManifest.imports.add('solana_program::short_vec::ShortVec');\n                                return {\n                                    ...childManifest,\n                                    type: `ShortVec<${childManifest.type}>`,\n                                };\n                            }\n                            default:\n                                throw new Error(`Array prefix not supported: ${prefix.format}`);\n                        }\n                    }\n\n                    // TODO: Add to the Rust validator.\n                    throw new Error('Array size not supported by Borsh');\n                },\n\n                visitBooleanType(booleanType) {\n                    const resolvedSize = resolveNestedTypeNode(booleanType.size);\n                    if (resolvedSize.format === 'u8' && resolvedSize.endian === 'le') {\n                        return {\n                            imports: new ImportMap(),\n                            nestedStructs: [],\n                            type: 'bool',\n                        };\n                    }\n\n                    // TODO: Add to the Rust validator.\n                    throw new Error('Bool size not supported by Borsh');\n                },\n\n                visitBytesType(_bytesType, { self }) {\n                    let arraySize: CountNode = remainderCountNode();\n                    if (typeof parentSize === 'number') {\n                        arraySize = fixedCountNode(parentSize);\n                    } else if (parentSize && typeof parentSize === 'object') {\n                        arraySize = prefixedCountNode(parentSize);\n                    }\n                    const arrayType = arrayTypeNode(numberTypeNode('u8'), arraySize);\n                    return visit(arrayType, self);\n                },\n\n                visitDefinedType(definedType, { self }) {\n                    parentName = pascalCase(definedType.name);\n                    const manifest = visit(definedType.type, self);\n                    const traits = getTraitsFromNode(definedType);\n                    manifest.imports.mergeWith(traits.imports);\n                    parentName = null;\n\n                    const renderedType = isNode(definedType.type, ['enumTypeNode', 'structTypeNode'])\n                        ? manifest.type\n                        : `pub type ${pascalCase(definedType.name)} = ${manifest.type};`;\n\n                    return { ...manifest, type: `${traits.render}${renderedType}` };\n                },\n\n                visitDefinedTypeLink(node) {\n                    const pascalCaseDefinedType = pascalCase(node.name);\n                    const importFrom = getImportFrom(node);\n                    return {\n                        imports: new ImportMap().add(`${importFrom}::${pascalCaseDefinedType}`),\n                        nestedStructs: [],\n                        type: pascalCaseDefinedType,\n                    };\n                },\n\n                visitEnumEmptyVariantType(enumEmptyVariantType) {\n                    const name = pascalCase(enumEmptyVariantType.name);\n                    return {\n                        imports: new ImportMap(),\n                        nestedStructs: [],\n                        type: `${name},`,\n                    };\n                },\n\n                visitEnumStructVariantType(enumStructVariantType, { self }) {\n                    const name = pascalCase(enumStructVariantType.name);\n                    const originalParentName = parentName;\n\n                    if (!originalParentName) {\n                        throw new Error('Enum struct variant type must have a parent name.');\n                    }\n\n                    inlineStruct = true;\n                    parentName = pascalCase(originalParentName) + name;\n                    const typeManifest = visit(enumStructVariantType.struct, self);\n                    inlineStruct = false;\n                    parentName = originalParentName;\n\n                    return {\n                        ...typeManifest,\n                        type: `${name} ${typeManifest.type},`,\n                    };\n                },\n\n                visitEnumTupleVariantType(enumTupleVariantType, { self }) {\n                    const name = pascalCase(enumTupleVariantType.name);\n                    const originalParentName = parentName;\n\n                    if (!originalParentName) {\n                        throw new Error('Enum struct variant type must have a parent name.');\n                    }\n\n                    parentName = pascalCase(originalParentName) + name;\n                    const childManifest = visit(enumTupleVariantType.tuple, self);\n                    parentName = originalParentName;\n\n                    let derive = '';\n                    if (childManifest.type === '(Pubkey)') {\n                        derive =\n                            '#[cfg_attr(feature = \"serde\", serde(with = \"serde_with::As::<serde_with::DisplayFromStr>\"))]\\n';\n                    } else if (childManifest.type === '(Vec<Pubkey>)') {\n                        derive =\n                            '#[cfg_attr(feature = \"serde\", serde(with = \"serde_with::As::<Vec<serde_with::DisplayFromStr>>\"))]\\n';\n                    }\n\n                    return {\n                        ...childManifest,\n                        type: `${derive}${name}${childManifest.type},`,\n                    };\n                },\n\n                visitEnumType(enumType, { self }) {\n                    const originalParentName = parentName;\n                    if (!originalParentName) {\n                        // TODO: Add to the Rust validator.\n                        throw new Error('Enum type must have a parent name.');\n                    }\n\n                    const variants = enumType.variants.map(variant => visit(variant, self));\n                    const variantNames = variants.map(variant => variant.type).join('\\n');\n                    const mergedManifest = mergeManifests(variants);\n\n                    return {\n                        ...mergedManifest,\n                        type: `pub enum ${pascalCase(originalParentName)} {\\n${variantNames}\\n}`,\n                    };\n                },\n\n                visitFixedSizeType(fixedSizeType, { self }) {\n                    parentSize = fixedSizeType.size;\n                    const manifest = visit(fixedSizeType.type, self);\n                    parentSize = null;\n                    return manifest;\n                },\n\n                visitMapType(mapType, { self }) {\n                    const key = visit(mapType.key, self);\n                    const value = visit(mapType.value, self);\n                    const mergedManifest = mergeManifests([key, value]);\n                    mergedManifest.imports.add('std::collections::HashMap');\n                    return {\n                        ...mergedManifest,\n                        type: `HashMap<${key.type}, ${value.type}>`,\n                    };\n                },\n\n                visitNumberType(numberType) {\n                    if (numberType.endian !== 'le') {\n                        // TODO: Add to the Rust validator.\n                        throw new Error('Number endianness not supported by Borsh');\n                    }\n\n                    if (numberType.format === 'shortU16') {\n                        return {\n                            imports: new ImportMap().add('solana_program::short_vec::ShortU16'),\n                            nestedStructs: [],\n                            type: 'ShortU16',\n                        };\n                    }\n\n                    return {\n                        imports: new ImportMap(),\n                        nestedStructs: [],\n                        type: numberType.format,\n                    };\n                },\n\n                visitOptionType(optionType, { self }) {\n                    const childManifest = visit(optionType.item, self);\n\n                    const optionPrefix = resolveNestedTypeNode(optionType.prefix);\n                    if (optionPrefix.format === 'u8' && optionPrefix.endian === 'le') {\n                        return {\n                            ...childManifest,\n                            type: `Option<${childManifest.type}>`,\n                        };\n                    }\n\n                    // TODO: Add to the Rust validator.\n                    throw new Error('Option size not supported by Borsh');\n                },\n\n                visitPublicKeyType() {\n                    return {\n                        imports: new ImportMap().add('solana_program::pubkey::Pubkey'),\n                        nestedStructs: [],\n                        type: 'Pubkey',\n                    };\n                },\n\n                visitRemainderOptionType(node) {\n                    throw new CodamaError(CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });\n                },\n\n                visitSetType(setType, { self }) {\n                    const childManifest = visit(setType.item, self);\n                    childManifest.imports.add('std::collections::HashSet');\n                    return {\n                        ...childManifest,\n                        type: `HashSet<${childManifest.type}>`,\n                    };\n                },\n\n                visitSizePrefixType(sizePrefixType, { self }) {\n                    parentSize = resolveNestedTypeNode(sizePrefixType.prefix);\n                    const manifest = visit(sizePrefixType.type, self);\n                    parentSize = null;\n                    return manifest;\n                },\n\n                visitStringType() {\n                    if (!parentSize) {\n                        return {\n                            imports: new ImportMap().add(`kaigan::types::RemainderStr`),\n                            nestedStructs: [],\n                            type: `RemainderStr`,\n                        };\n                    }\n\n                    if (typeof parentSize === 'number') {\n                        return {\n                            imports: new ImportMap(),\n                            nestedStructs: [],\n                            type: `[u8; ${parentSize}]`,\n                        };\n                    }\n\n                    if (isNode(parentSize, 'numberTypeNode') && parentSize.endian === 'le') {\n                        switch (parentSize.format) {\n                            case 'u32':\n                                return {\n                                    imports: new ImportMap(),\n                                    nestedStructs: [],\n                                    type: 'String',\n                                };\n                            case 'u8':\n                            case 'u16':\n                            case 'u64': {\n                                const prefix = parentSize.format.toUpperCase();\n                                return {\n                                    imports: new ImportMap().add(`kaigan::types::${prefix}PrefixString`),\n                                    nestedStructs: [],\n                                    type: `${prefix}PrefixString`,\n                                };\n                            }\n                            default:\n                                throw new Error(`'String size not supported: ${parentSize.format}`);\n                        }\n                    }\n\n                    // TODO: Add to the Rust validator.\n                    throw new Error('String size not supported by Borsh');\n                },\n\n                visitStructFieldType(structFieldType, { self }) {\n                    const originalParentName = parentName;\n                    const originalInlineStruct = inlineStruct;\n                    const originalNestedStruct = nestedStruct;\n\n                    if (!originalParentName) {\n                        throw new Error('Struct field type must have a parent name.');\n                    }\n\n                    parentName = pascalCase(originalParentName) + pascalCase(structFieldType.name);\n                    nestedStruct = true;\n                    inlineStruct = false;\n\n                    const fieldManifest = visit(structFieldType.type, self);\n\n                    parentName = originalParentName;\n                    inlineStruct = originalInlineStruct;\n                    nestedStruct = originalNestedStruct;\n\n                    const fieldName = snakeCase(structFieldType.name);\n                    const docblock = rustDocblock(parseDocs(structFieldType.docs));\n                    const resolvedNestedType = resolveNestedTypeNode(structFieldType.type);\n\n                    let derive = '';\n                    if (fieldManifest.type === 'Pubkey') {\n                        derive =\n                            '#[cfg_attr(feature = \"serde\", serde(with = \"serde_with::As::<serde_with::DisplayFromStr>\"))]\\n';\n                    } else if (fieldManifest.type === 'Vec<Pubkey>') {\n                        derive =\n                            '#[cfg_attr(feature = \"serde\", serde(with = \"serde_with::As::<Vec<serde_with::DisplayFromStr>>\"))]\\n';\n                    } else if (\n                        isNode(resolvedNestedType, 'arrayTypeNode') &&\n                        isNode(resolvedNestedType.count, 'fixedCountNode') &&\n                        resolvedNestedType.count.value > 32\n                    ) {\n                        derive = '#[cfg_attr(feature = \"serde\", serde(with = \"serde_big_array::BigArray\"))]\\n';\n                    } else if (\n                        isNode(resolvedNestedType, ['bytesTypeNode', 'stringTypeNode']) &&\n                        isNode(structFieldType.type, 'fixedSizeTypeNode') &&\n                        structFieldType.type.size > 32\n                    ) {\n                        derive =\n                            '#[cfg_attr(feature = \"serde\", serde(with = \"serde_with::As::<serde_with::Bytes>\"))]\\n';\n                    }\n\n                    return {\n                        ...fieldManifest,\n                        type: inlineStruct\n                            ? `${docblock}${derive}${fieldName}: ${fieldManifest.type},`\n                            : `${docblock}${derive}pub ${fieldName}: ${fieldManifest.type},`,\n                    };\n                },\n\n                visitStructType(structType, { self }) {\n                    const originalParentName = parentName;\n\n                    if (!originalParentName) {\n                        // TODO: Add to the Rust validator.\n                        throw new Error('Struct type must have a parent name.');\n                    }\n\n                    const fields = structType.fields.map(field => visit(field, self));\n                    const fieldTypes = fields.map(field => field.type).join('\\n');\n                    const mergedManifest = mergeManifests(fields);\n\n                    if (nestedStruct) {\n                        const nestedTraits = getTraitsFromNode(\n                            definedTypeNode({ name: originalParentName, type: structType }),\n                        );\n                        mergedManifest.imports.mergeWith(nestedTraits.imports);\n                        return {\n                            ...mergedManifest,\n                            nestedStructs: [\n                                ...mergedManifest.nestedStructs,\n                                `${nestedTraits.render}pub struct ${pascalCase(originalParentName)} {\\n${fieldTypes}\\n}`,\n                            ],\n                            type: pascalCase(originalParentName),\n                        };\n                    }\n\n                    if (inlineStruct) {\n                        return { ...mergedManifest, type: `{\\n${fieldTypes}\\n}` };\n                    }\n\n                    return {\n                        ...mergedManifest,\n                        type: `pub struct ${pascalCase(originalParentName)} {\\n${fieldTypes}\\n}`,\n                    };\n                },\n\n                visitTupleType(tupleType, { self }) {\n                    const items = tupleType.items.map(item => visit(item, self));\n                    const mergedManifest = mergeManifests(items);\n\n                    return {\n                        ...mergedManifest,\n                        type: `(${items.map(item => item.type).join(', ')})`,\n                    };\n                },\n\n                visitZeroableOptionType(node) {\n                    throw new CodamaError(CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });\n                },\n            }),\n    );\n}\n\nfunction mergeManifests(manifests: TypeManifest[]): Pick<TypeManifest, 'imports' | 'nestedStructs'> {\n    return {\n        imports: new ImportMap().mergeWith(...manifests.map(td => td.imports)),\n        nestedStructs: manifests.flatMap(m => m.nestedStructs),\n    };\n}\n","import { BytesValueNode } from '@codama/nodes';\nimport { getBase16Encoder, getBase58Encoder, getBase64Encoder, getUtf8Encoder } from '@solana/codecs-strings';\n\nexport function getBytesFromBytesValueNode(node: BytesValueNode): Uint8Array {\n    switch (node.encoding) {\n        case 'utf8':\n            return getUtf8Encoder().encode(node.data) as Uint8Array;\n        case 'base16':\n            return getBase16Encoder().encode(node.data) as Uint8Array;\n        case 'base58':\n            return getBase58Encoder().encode(node.data) as Uint8Array;\n        case 'base64':\n        default:\n            return getBase64Encoder().encode(node.data) as Uint8Array;\n    }\n}\n","import { CODAMA_ERROR__UNEXPECTED_NODE_KIND, CodamaError } from '@codama/errors';\nimport {\n    AccountLinkNode,\n    DefinedTypeLinkNode,\n    InstructionLinkNode,\n    PdaLinkNode,\n    ProgramLinkNode,\n    ResolverValueNode,\n} from '@codama/nodes';\n\nexport type LinkOverrides = {\n    accounts?: Record<string, string>;\n    definedTypes?: Record<string, string>;\n    instructions?: Record<string, string>;\n    pdas?: Record<string, string>;\n    programs?: Record<string, string>;\n    resolvers?: Record<string, string>;\n};\n\ntype OverridableNodes =\n    | AccountLinkNode\n    | DefinedTypeLinkNode\n    | InstructionLinkNode\n    | PdaLinkNode\n    | ProgramLinkNode\n    | ResolverValueNode;\n\nexport type GetImportFromFunction = (node: OverridableNodes, fallback?: string) => string;\n\nexport function getImportFromFactory(overrides: LinkOverrides): GetImportFromFunction {\n    const linkOverrides = {\n        accounts: overrides.accounts ?? {},\n        definedTypes: overrides.definedTypes ?? {},\n        instructions: overrides.instructions ?? {},\n        pdas: overrides.pdas ?? {},\n        programs: overrides.programs ?? {},\n        resolvers: overrides.resolvers ?? {},\n    };\n\n    return (node: OverridableNodes) => {\n        const kind = node.kind;\n        switch (kind) {\n            case 'accountLinkNode':\n                return linkOverrides.accounts[node.name] ?? 'generatedAccounts';\n            case 'definedTypeLinkNode':\n                return linkOverrides.definedTypes[node.name] ?? 'generatedTypes';\n            case 'instructionLinkNode':\n                return linkOverrides.instructions[node.name] ?? 'generatedInstructions';\n            case 'pdaLinkNode':\n                return linkOverrides.pdas[node.name] ?? 'generatedAccounts';\n            case 'programLinkNode':\n                return linkOverrides.programs[node.name] ?? 'generatedPrograms';\n            case 'resolverValueNode':\n                return linkOverrides.resolvers[node.name] ?? 'hooked';\n            default:\n                throw new CodamaError(CODAMA_ERROR__UNEXPECTED_NODE_KIND, {\n                    expectedKinds: [\n                        'AccountLinkNode',\n                        'DefinedTypeLinkNode',\n                        'InstructionLinkNode',\n                        'PdaLinkNode',\n                        'ProgramLinkNode',\n                        'resolverValueNode',\n                    ],\n                    kind: kind satisfies never,\n                    node,\n                });\n        }\n    };\n}\n","import { dirname as pathDirname, join } from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport { camelCase, kebabCase, pascalCase, snakeCase, titleCase } from '@codama/nodes';\nimport nunjucks, { ConfigureOptions as NunJucksOptions } from 'nunjucks';\n\nexport function rustDocblock(docs: string[]): string {\n    if (docs.length <= 0) return '';\n    const lines = docs.map(doc => `/// ${doc}`);\n    return `${lines.join('\\n')}\\n`;\n}\n\nexport const render = (template: string, context?: object, options?: NunJucksOptions): string => {\n    // @ts-expect-error import.meta will be used in the right environment.\n    const dirname = __ESM__ ? pathDirname(fileURLToPath(import.meta.url)) : __dirname;\n    const templates = __TEST__ ? join(dirname, '..', '..', 'public', 'templates') : join(dirname, 'templates'); // Path to templates from bundled output file.\n    const env = nunjucks.configure(templates, { autoescape: false, trimBlocks: true, ...options });\n    env.addFilter('pascalCase', pascalCase);\n    env.addFilter('camelCase', camelCase);\n    env.addFilter('snakeCase', snakeCase);\n    env.addFilter('kebabCase', kebabCase);\n    env.addFilter('titleCase', titleCase);\n    env.addFilter('rustDocblock', rustDocblock);\n    return env.render(template, context);\n};\n","import {\n    AccountNode,\n    assertIsNode,\n    camelCase,\n    DefinedTypeNode,\n    InstructionNode,\n    isNode,\n    isScalarEnum,\n} from '@codama/nodes';\n\nimport { ImportMap } from '../ImportMap';\n\nexport type TraitOptions = {\n    /** The default traits to implement for all types. */\n    baseDefaults?: string[];\n    /**\n     * The default traits to implement for data enums only — on top of the base defaults.\n     * Data enums are enums with at least one non-unit variant.\n     */\n    dataEnumDefaults?: string[];\n    /**\n     * The mapping of feature flags to traits.\n     * For each entry, the traits will be rendered within a\n     * `#[cfg_attr(feature = \"feature_name\", derive(Traits))]` attribute.\n     */\n    featureFlags?: Record<string, string[]>;\n    /** The complete trait overrides of specific types. */\n    overrides?: Record<string, string[]>;\n    /**\n     * The default traits to implement for scalar enums only — on top of the base defaults.\n     * Scalar enums are enums with no variants or only unit variants.\n     */\n    scalarEnumDefaults?: string[];\n    /** The default traits to implement for structs only — on top of the base defaults. */\n    structDefaults?: string[];\n    /** Whether or not to use the fully qualified name for traits, instead of importing them. */\n    useFullyQualifiedName?: boolean;\n};\n\nexport const DEFAULT_TRAIT_OPTIONS: Required<TraitOptions> = {\n    baseDefaults: [\n        'borsh::BorshSerialize',\n        'borsh::BorshDeserialize',\n        'serde::Serialize',\n        'serde::Deserialize',\n        'Clone',\n        'Debug',\n        'Eq',\n        'PartialEq',\n    ],\n    dataEnumDefaults: [],\n    featureFlags: { serde: ['serde::Serialize', 'serde::Deserialize'] },\n    overrides: {},\n    scalarEnumDefaults: ['Copy', 'PartialOrd', 'Hash', 'num_derive::FromPrimitive'],\n    structDefaults: [],\n    useFullyQualifiedName: false,\n};\n\nexport type GetTraitsFromNodeFunction = (node: AccountNode | DefinedTypeNode | InstructionNode) => {\n    imports: ImportMap;\n    render: string;\n};\n\nexport function getTraitsFromNodeFactory(options: TraitOptions = {}): GetTraitsFromNodeFunction {\n    return node => getTraitsFromNode(node, options);\n}\n\nexport function getTraitsFromNode(\n    node: AccountNode | DefinedTypeNode | InstructionNode,\n    userOptions: TraitOptions = {},\n): { imports: ImportMap; render: string } {\n    assertIsNode(node, ['accountNode', 'definedTypeNode', 'instructionNode']);\n    const options: Required<TraitOptions> = { ...DEFAULT_TRAIT_OPTIONS, ...userOptions };\n\n    // Get the node type and return early if it's a type alias.\n    const nodeType = getNodeType(node);\n    if (nodeType === 'alias') {\n        return { imports: new ImportMap(), render: '' };\n    }\n\n    // Find all the FQN traits for the node.\n    const sanitizedOverrides = Object.fromEntries(\n        Object.entries(options.overrides).map(([key, value]) => [camelCase(key), value]),\n    );\n    const nodeOverrides: string[] | undefined = sanitizedOverrides[node.name];\n    const allTraits = nodeOverrides === undefined ? getDefaultTraits(nodeType, options) : nodeOverrides;\n\n    // Wrap the traits in feature flags if necessary.\n    const partitionedTraits = partitionTraitsInFeatures(allTraits, options.featureFlags);\n    let unfeaturedTraits = partitionedTraits[0];\n    const featuredTraits = partitionedTraits[1];\n\n    // Import the traits if necessary.\n    const imports = new ImportMap();\n    if (!options.useFullyQualifiedName) {\n        unfeaturedTraits = extractFullyQualifiedNames(unfeaturedTraits, imports);\n    }\n\n    // Render the trait lines.\n    const traitLines: string[] = [\n        ...(unfeaturedTraits.length > 0 ? [`#[derive(${unfeaturedTraits.join(', ')})]\\n`] : []),\n        ...Object.entries(featuredTraits).map(([feature, traits]) => {\n            return `#[cfg_attr(feature = \"${feature}\", derive(${traits.join(', ')}))]\\n`;\n        }),\n    ];\n\n    return { imports, render: traitLines.join('') };\n}\n\nfunction getNodeType(\n    node: AccountNode | DefinedTypeNode | InstructionNode,\n): 'alias' | 'dataEnum' | 'scalarEnum' | 'struct' {\n    if (isNode(node, ['accountNode', 'instructionNode'])) return 'struct';\n    if (isNode(node.type, 'structTypeNode')) return 'struct';\n    if (isNode(node.type, 'enumTypeNode')) {\n        return isScalarEnum(node.type) ? 'scalarEnum' : 'dataEnum';\n    }\n    return 'alias';\n}\n\nfunction getDefaultTraits(\n    nodeType: 'dataEnum' | 'scalarEnum' | 'struct',\n    options: Pick<\n        Required<TraitOptions>,\n        'baseDefaults' | 'dataEnumDefaults' | 'scalarEnumDefaults' | 'structDefaults'\n    >,\n): string[] {\n    switch (nodeType) {\n        case 'dataEnum':\n            return [...options.baseDefaults, ...options.dataEnumDefaults];\n        case 'scalarEnum':\n            return [...options.baseDefaults, ...options.scalarEnumDefaults];\n        case 'struct':\n            return [...options.baseDefaults, ...options.structDefaults];\n    }\n}\n\nfunction partitionTraitsInFeatures(\n    traits: string[],\n    featureFlags: Record<string, string[]>,\n): [string[], Record<string, string[]>] {\n    // Reverse the feature flags option for quick lookup.\n    // If there are any duplicate traits, the first one encountered will be used.\n    const reverseFeatureFlags = Object.entries(featureFlags).reduce(\n        (acc, [feature, traits]) => {\n            for (const trait of traits) {\n                if (!acc[trait]) acc[trait] = feature;\n            }\n            return acc;\n        },\n        {} as Record<string, string>,\n    );\n\n    const unfeaturedTraits: string[] = [];\n    const featuredTraits: Record<string, string[]> = {};\n    for (const trait of traits) {\n        const feature: string | undefined = reverseFeatureFlags[trait];\n        if (feature === undefined) {\n            unfeaturedTraits.push(trait);\n        } else {\n            if (!featuredTraits[feature]) featuredTraits[feature] = [];\n            featuredTraits[feature].push(trait);\n        }\n    }\n\n    return [unfeaturedTraits, featuredTraits];\n}\n\nfunction extractFullyQualifiedNames(traits: string[], imports: ImportMap): string[] {\n    return traits.map(trait => {\n        const index = trait.lastIndexOf('::');\n        if (index === -1) return trait;\n        imports.add(trait);\n        return trait.slice(index + 2);\n    });\n}\n","import {\n    arrayValueNode,\n    bytesValueNode,\n    isNode,\n    numberValueNode,\n    pascalCase,\n    RegisteredValueNode,\n    ValueNode,\n} from '@codama/nodes';\nimport { visit, Visitor } from '@codama/visitors-core';\n\nimport { ImportMap } from './ImportMap';\nimport { getBytesFromBytesValueNode, GetImportFromFunction } from './utils';\n\nexport function renderValueNode(\n    value: ValueNode,\n    getImportFrom: GetImportFromFunction,\n    useStr: boolean = false,\n): {\n    imports: ImportMap;\n    render: string;\n} {\n    return visit(value, renderValueNodeVisitor(getImportFrom, useStr));\n}\n\nexport function renderValueNodeVisitor(\n    getImportFrom: GetImportFromFunction,\n    useStr: boolean = false,\n): Visitor<\n    {\n        imports: ImportMap;\n        render: string;\n    },\n    RegisteredValueNode['kind']\n> {\n    return {\n        visitArrayValue(node) {\n            const list = node.items.map(v => visit(v, this));\n            return {\n                imports: new ImportMap().mergeWith(...list.map(c => c.imports)),\n                render: `[${list.map(c => c.render).join(', ')}]`,\n            };\n        },\n        visitBooleanValue(node) {\n            return {\n                imports: new ImportMap(),\n                render: JSON.stringify(node.boolean),\n            };\n        },\n        visitBytesValue(node) {\n            const bytes = getBytesFromBytesValueNode(node);\n            const numbers = Array.from(bytes).map(numberValueNode);\n            return visit(arrayValueNode(numbers), this);\n        },\n        visitConstantValue(node) {\n            if (isNode(node.value, 'bytesValueNode')) {\n                return visit(node.value, this);\n            }\n            if (isNode(node.type, 'stringTypeNode') && isNode(node.value, 'stringValueNode')) {\n                return visit(bytesValueNode(node.type.encoding, node.value.string), this);\n            }\n            if (isNode(node.type, 'numberTypeNode') && isNode(node.value, 'numberValueNode')) {\n                const numberManifest = visit(node.value, this);\n                const { format, endian } = node.type;\n                const byteFunction = endian === 'le' ? 'to_le_bytes' : 'to_be_bytes';\n                numberManifest.render = `${numberManifest.render}${format}.${byteFunction}()`;\n                return numberManifest;\n            }\n            throw new Error('Unsupported constant value type.');\n        },\n        visitEnumValue(node) {\n            const imports = new ImportMap();\n            const enumName = pascalCase(node.enum.name);\n            const variantName = pascalCase(node.variant);\n            const importFrom = getImportFrom(node.enum);\n            imports.add(`${importFrom}::${enumName}`);\n            if (!node.value) {\n                return { imports, render: `${enumName}::${variantName}` };\n            }\n            const enumValue = visit(node.value, this);\n            const fields = enumValue.render;\n            return {\n                imports: imports.mergeWith(enumValue.imports),\n                render: `${enumName}::${variantName} ${fields}`,\n            };\n        },\n        visitMapEntryValue(node) {\n            const mapKey = visit(node.key, this);\n            const mapValue = visit(node.value, this);\n            return {\n                imports: mapKey.imports.mergeWith(mapValue.imports),\n                render: `[${mapKey.render}, ${mapValue.render}]`,\n            };\n        },\n        visitMapValue(node) {\n            const map = node.entries.map(entry => visit(entry, this));\n            const imports = new ImportMap().add('std::collection::HashMap');\n            return {\n                imports: imports.mergeWith(...map.map(c => c.imports)),\n                render: `HashMap::from([${map.map(c => c.render).join(', ')}])`,\n            };\n        },\n        visitNoneValue() {\n            return {\n                imports: new ImportMap(),\n                render: 'None',\n            };\n        },\n        visitNumberValue(node) {\n            return {\n                imports: new ImportMap(),\n                render: node.number.toString(),\n            };\n        },\n        visitPublicKeyValue(node) {\n            return {\n                imports: new ImportMap().add('solana_program::pubkey'),\n                render: `pubkey!(\"${node.publicKey}\")`,\n            };\n        },\n        visitSetValue(node) {\n            const set = node.items.map(v => visit(v, this));\n            const imports = new ImportMap().add('std::collection::HashSet');\n            return {\n                imports: imports.mergeWith(...set.map(c => c.imports)),\n                render: `HashSet::from([${set.map(c => c.render).join(', ')}])`,\n            };\n        },\n        visitSomeValue(node) {\n            const child = visit(node.value, this);\n            return {\n                ...child,\n                render: `Some(${child.render})`,\n            };\n        },\n        visitStringValue(node) {\n            return {\n                imports: new ImportMap(),\n                render: useStr ? `${JSON.stringify(node.string)}` : `String::from(${JSON.stringify(node.string)})`,\n            };\n        },\n        visitStructFieldValue(node) {\n            const structValue = visit(node.value, this);\n            return {\n                imports: structValue.imports,\n                render: `${node.name}: ${structValue.render}`,\n            };\n        },\n        visitStructValue(node) {\n            const struct = node.fields.map(field => visit(field, this));\n            return {\n                imports: new ImportMap().mergeWith(...struct.map(c => c.imports)),\n                render: `{ ${struct.map(c => c.render).join(', ')} }`,\n            };\n        },\n        visitTupleValue(node) {\n            const tuple = node.items.map(v => visit(v, this));\n            return {\n                imports: new ImportMap().mergeWith(...tuple.map(c => c.imports)),\n                render: `(${tuple.map(c => c.render).join(', ')})`,\n            };\n        },\n    };\n}\n","import { logError, logWarn } from '@codama/errors';\nimport { deleteDirectory, writeRenderMapVisitor } from '@codama/renderers-core';\nimport { rootNodeVisitor, visit } from '@codama/visitors-core';\nimport { spawnSync } from 'child_process';\n\nimport { GetRenderMapOptions, getRenderMapVisitor } from './getRenderMapVisitor';\n\nexport type RenderOptions = GetRenderMapOptions & {\n    crateFolder?: string;\n    deleteFolderBeforeRendering?: boolean;\n    formatCode?: boolean;\n    toolchain?: string;\n};\n\nexport function renderVisitor(path: string, options: RenderOptions = {}) {\n    return rootNodeVisitor(root => {\n        // Delete existing generated folder.\n        if (options.deleteFolderBeforeRendering ?? true) {\n            deleteDirectory(path);\n        }\n\n        // Render the new files.\n        visit(root, writeRenderMapVisitor(getRenderMapVisitor(options), path));\n\n        // format the code\n        if (options.formatCode) {\n            if (options.crateFolder) {\n                const toolchain = options.toolchain ?? '+stable';\n                runFormatter('cargo', [toolchain, 'fmt', '--manifest-path', `${options.crateFolder}/Cargo.toml`]);\n            } else {\n                logWarn('No crate folder specified, skipping formatting.');\n            }\n        }\n    });\n}\n\nfunction runFormatter(cmd: string, args: string[]) {\n    const { stdout, stderr, error } = spawnSync(cmd, args);\n    if (error?.message?.includes('ENOENT')) {\n        logWarn(`Could not find ${cmd}, skipping formatting.`);\n        return;\n    }\n    if (stdout.length > 0) {\n        logWarn(`(cargo-fmt) ${stdout ? stdout?.toString() : error}`);\n    }\n    if (stderr.length > 0) {\n        logError(`(cargo-fmt) ${stderr ? stderr.toString() : error}`);\n    }\n}\n"],"mappings":"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","names":["import_errors","import_nodes","import_visitors_core","import_errors","import_nodes","nunjucks","import_nodes","traits","getTraitsFromNode","import_nodes","import_visitors_core","getTraitsFromNode","seedManifest","resolvedType","import_errors","import_renderers_core","import_visitors_core"]}