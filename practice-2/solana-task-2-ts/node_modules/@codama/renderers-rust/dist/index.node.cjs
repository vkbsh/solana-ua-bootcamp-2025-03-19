"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ImportMap: () => ImportMap,
  default: () => renderVisitor,
  getRenderMapVisitor: () => getRenderMapVisitor,
  getTypeManifestVisitor: () => getTypeManifestVisitor,
  renderVisitor: () => renderVisitor
});
module.exports = __toCommonJS(index_exports);

// src/ImportMap.ts
var DEFAULT_MODULE_MAP = {
  generated: "crate::generated",
  generatedAccounts: "crate::generated::accounts",
  generatedErrors: "crate::generated::errors",
  generatedInstructions: "crate::generated::instructions",
  generatedTypes: "crate::generated::types",
  hooked: "crate::hooked",
  mplEssentials: "mpl_toolbox",
  mplToolbox: "mpl_toolbox"
};
var ImportMap = class _ImportMap {
  _imports = /* @__PURE__ */ new Set();
  _aliases = /* @__PURE__ */ new Map();
  get imports() {
    return this._imports;
  }
  get aliases() {
    return this._aliases;
  }
  add(imports) {
    const newImports = typeof imports === "string" ? [imports] : imports;
    newImports.forEach((i) => this._imports.add(i));
    return this;
  }
  remove(imports) {
    const importsToRemove = typeof imports === "string" ? [imports] : imports;
    importsToRemove.forEach((i) => this._imports.delete(i));
    return this;
  }
  mergeWith(...others) {
    others.forEach((other) => {
      this.add(other._imports);
      other._aliases.forEach((alias, importName) => this.addAlias(importName, alias));
    });
    return this;
  }
  mergeWithManifest(manifest) {
    return this.mergeWith(manifest.imports);
  }
  addAlias(importName, alias) {
    this._aliases.set(importName, alias);
    return this;
  }
  isEmpty() {
    return this._imports.size === 0;
  }
  resolveDependencyMap(dependencies) {
    const dependencyMap = { ...DEFAULT_MODULE_MAP, ...dependencies };
    const newImportMap = new _ImportMap();
    const resolveDependency = (i) => {
      const dependencyKey = Object.keys(dependencyMap).find((key) => i.startsWith(`${key}::`));
      if (!dependencyKey) return i;
      const dependencyValue = dependencyMap[dependencyKey];
      return dependencyValue + i.slice(dependencyKey.length);
    };
    this._imports.forEach((i) => newImportMap.add(resolveDependency(i)));
    this._aliases.forEach((alias, i) => newImportMap.addAlias(resolveDependency(i), alias));
    return newImportMap;
  }
  toString(dependencies) {
    const resolvedMap = this.resolveDependencyMap(dependencies);
    const importStatements = [...resolvedMap.imports].map((i) => {
      const alias = resolvedMap.aliases.get(i);
      if (alias) return `use ${i} as ${alias};`;
      return `use ${i};`;
    });
    return importStatements.join("\n");
  }
};

// src/getRenderMapVisitor.ts
var import_errors3 = require("@codama/errors");
var import_nodes5 = require("@codama/nodes");
var import_renderers_core = require("@codama/renderers-core");
var import_visitors_core3 = require("@codama/visitors-core");

// src/getTypeManifestVisitor.ts
var import_errors2 = require("@codama/errors");
var import_nodes3 = require("@codama/nodes");
var import_visitors_core = require("@codama/visitors-core");

// src/utils/codecs.ts
var import_codecs_strings = require("@solana/codecs-strings");
function getBytesFromBytesValueNode(node) {
  switch (node.encoding) {
    case "utf8":
      return (0, import_codecs_strings.getUtf8Encoder)().encode(node.data);
    case "base16":
      return (0, import_codecs_strings.getBase16Encoder)().encode(node.data);
    case "base58":
      return (0, import_codecs_strings.getBase58Encoder)().encode(node.data);
    case "base64":
    default:
      return (0, import_codecs_strings.getBase64Encoder)().encode(node.data);
  }
}

// src/utils/linkOverrides.ts
var import_errors = require("@codama/errors");
function getImportFromFactory(overrides) {
  const linkOverrides = {
    accounts: overrides.accounts ?? {},
    definedTypes: overrides.definedTypes ?? {},
    instructions: overrides.instructions ?? {},
    pdas: overrides.pdas ?? {},
    programs: overrides.programs ?? {},
    resolvers: overrides.resolvers ?? {}
  };
  return (node) => {
    const kind = node.kind;
    switch (kind) {
      case "accountLinkNode":
        return linkOverrides.accounts[node.name] ?? "generatedAccounts";
      case "definedTypeLinkNode":
        return linkOverrides.definedTypes[node.name] ?? "generatedTypes";
      case "instructionLinkNode":
        return linkOverrides.instructions[node.name] ?? "generatedInstructions";
      case "pdaLinkNode":
        return linkOverrides.pdas[node.name] ?? "generatedAccounts";
      case "programLinkNode":
        return linkOverrides.programs[node.name] ?? "generatedPrograms";
      case "resolverValueNode":
        return linkOverrides.resolvers[node.name] ?? "hooked";
      default:
        throw new import_errors.CodamaError(import_errors.CODAMA_ERROR__UNEXPECTED_NODE_KIND, {
          expectedKinds: [
            "AccountLinkNode",
            "DefinedTypeLinkNode",
            "InstructionLinkNode",
            "PdaLinkNode",
            "ProgramLinkNode",
            "resolverValueNode"
          ],
          kind,
          node
        });
    }
  };
}

// src/utils/render.ts
var import_node_path = require("path");
var import_node_url = require("url");
var import_nodes = require("@codama/nodes");
var import_nunjucks = __toESM(require("nunjucks"));
function rustDocblock(docs) {
  if (docs.length <= 0) return "";
  const lines = docs.map((doc) => `/// ${doc}`);
  return `${lines.join("\n")}
`;
}
var render = (template, context, options) => {
  const dirname = false ? pathDirname(fileURLToPath(import_meta.url)) : __dirname;
  const templates = false ? (0, import_node_path.join)(dirname, "..", "..", "public", "templates") : (0, import_node_path.join)(dirname, "templates");
  const env = import_nunjucks.default.configure(templates, { autoescape: false, trimBlocks: true, ...options });
  env.addFilter("pascalCase", import_nodes.pascalCase);
  env.addFilter("camelCase", import_nodes.camelCase);
  env.addFilter("snakeCase", import_nodes.snakeCase);
  env.addFilter("kebabCase", import_nodes.kebabCase);
  env.addFilter("titleCase", import_nodes.titleCase);
  env.addFilter("rustDocblock", rustDocblock);
  return env.render(template, context);
};

// src/utils/traitOptions.ts
var import_nodes2 = require("@codama/nodes");
var DEFAULT_TRAIT_OPTIONS = {
  baseDefaults: [
    "borsh::BorshSerialize",
    "borsh::BorshDeserialize",
    "serde::Serialize",
    "serde::Deserialize",
    "Clone",
    "Debug",
    "Eq",
    "PartialEq"
  ],
  dataEnumDefaults: [],
  featureFlags: { serde: ["serde::Serialize", "serde::Deserialize"] },
  overrides: {},
  scalarEnumDefaults: ["Copy", "PartialOrd", "Hash", "num_derive::FromPrimitive"],
  structDefaults: [],
  useFullyQualifiedName: false
};
function getTraitsFromNodeFactory(options = {}) {
  return (node) => getTraitsFromNode(node, options);
}
function getTraitsFromNode(node, userOptions = {}) {
  (0, import_nodes2.assertIsNode)(node, ["accountNode", "definedTypeNode", "instructionNode"]);
  const options = { ...DEFAULT_TRAIT_OPTIONS, ...userOptions };
  const nodeType = getNodeType(node);
  if (nodeType === "alias") {
    return { imports: new ImportMap(), render: "" };
  }
  const sanitizedOverrides = Object.fromEntries(
    Object.entries(options.overrides).map(([key, value]) => [(0, import_nodes2.camelCase)(key), value])
  );
  const nodeOverrides = sanitizedOverrides[node.name];
  const allTraits = nodeOverrides === void 0 ? getDefaultTraits(nodeType, options) : nodeOverrides;
  const partitionedTraits = partitionTraitsInFeatures(allTraits, options.featureFlags);
  let unfeaturedTraits = partitionedTraits[0];
  const featuredTraits = partitionedTraits[1];
  const imports = new ImportMap();
  if (!options.useFullyQualifiedName) {
    unfeaturedTraits = extractFullyQualifiedNames(unfeaturedTraits, imports);
  }
  const traitLines = [
    ...unfeaturedTraits.length > 0 ? [`#[derive(${unfeaturedTraits.join(", ")})]
`] : [],
    ...Object.entries(featuredTraits).map(([feature, traits]) => {
      return `#[cfg_attr(feature = "${feature}", derive(${traits.join(", ")}))]
`;
    })
  ];
  return { imports, render: traitLines.join("") };
}
function getNodeType(node) {
  if ((0, import_nodes2.isNode)(node, ["accountNode", "instructionNode"])) return "struct";
  if ((0, import_nodes2.isNode)(node.type, "structTypeNode")) return "struct";
  if ((0, import_nodes2.isNode)(node.type, "enumTypeNode")) {
    return (0, import_nodes2.isScalarEnum)(node.type) ? "scalarEnum" : "dataEnum";
  }
  return "alias";
}
function getDefaultTraits(nodeType, options) {
  switch (nodeType) {
    case "dataEnum":
      return [...options.baseDefaults, ...options.dataEnumDefaults];
    case "scalarEnum":
      return [...options.baseDefaults, ...options.scalarEnumDefaults];
    case "struct":
      return [...options.baseDefaults, ...options.structDefaults];
  }
}
function partitionTraitsInFeatures(traits, featureFlags) {
  const reverseFeatureFlags = Object.entries(featureFlags).reduce(
    (acc, [feature, traits2]) => {
      for (const trait of traits2) {
        if (!acc[trait]) acc[trait] = feature;
      }
      return acc;
    },
    {}
  );
  const unfeaturedTraits = [];
  const featuredTraits = {};
  for (const trait of traits) {
    const feature = reverseFeatureFlags[trait];
    if (feature === void 0) {
      unfeaturedTraits.push(trait);
    } else {
      if (!featuredTraits[feature]) featuredTraits[feature] = [];
      featuredTraits[feature].push(trait);
    }
  }
  return [unfeaturedTraits, featuredTraits];
}
function extractFullyQualifiedNames(traits, imports) {
  return traits.map((trait) => {
    const index = trait.lastIndexOf("::");
    if (index === -1) return trait;
    imports.add(trait);
    return trait.slice(index + 2);
  });
}

// src/getTypeManifestVisitor.ts
function getTypeManifestVisitor(options) {
  const { getImportFrom, getTraitsFromNode: getTraitsFromNode2 } = options;
  let parentName = options.parentName ?? null;
  let nestedStruct = options.nestedStruct ?? false;
  let inlineStruct = false;
  let parentSize = null;
  return (0, import_visitors_core.pipe)(
    (0, import_visitors_core.mergeVisitor)(
      () => ({ imports: new ImportMap(), nestedStructs: [], type: "" }),
      (_, values) => ({
        ...mergeManifests(values),
        type: values.map((v) => v.type).join("\n")
      }),
      { keys: [...import_nodes3.REGISTERED_TYPE_NODE_KINDS, "definedTypeLinkNode", "definedTypeNode", "accountNode"] }
    ),
    (v) => (0, import_visitors_core.extendVisitor)(v, {
      visitAccount(account, { self }) {
        parentName = (0, import_nodes3.pascalCase)(account.name);
        const manifest = (0, import_visitors_core.visit)(account.data, self);
        const traits = getTraitsFromNode2(account);
        manifest.imports.mergeWith(traits.imports);
        parentName = null;
        return {
          ...manifest,
          type: traits.render + manifest.type
        };
      },
      visitArrayType(arrayType, { self }) {
        const childManifest = (0, import_visitors_core.visit)(arrayType.item, self);
        if ((0, import_nodes3.isNode)(arrayType.count, "fixedCountNode")) {
          return {
            ...childManifest,
            type: `[${childManifest.type}; ${arrayType.count.value}]`
          };
        }
        if ((0, import_nodes3.isNode)(arrayType.count, "remainderCountNode")) {
          childManifest.imports.add("kaigan::types::RemainderVec");
          return {
            ...childManifest,
            type: `RemainderVec<${childManifest.type}>`
          };
        }
        const prefix = (0, import_nodes3.resolveNestedTypeNode)(arrayType.count.prefix);
        if (prefix.endian === "le") {
          switch (prefix.format) {
            case "u32":
              return {
                ...childManifest,
                type: `Vec<${childManifest.type}>`
              };
            case "u8":
            case "u16":
            case "u64": {
              const prefixFormat = prefix.format.toUpperCase();
              childManifest.imports.add(`kaigan::types::${prefixFormat}PrefixVec`);
              return {
                ...childManifest,
                type: `${prefixFormat}PrefixVec<${childManifest.type}>`
              };
            }
            case "shortU16": {
              childManifest.imports.add("solana_program::short_vec::ShortVec");
              return {
                ...childManifest,
                type: `ShortVec<${childManifest.type}>`
              };
            }
            default:
              throw new Error(`Array prefix not supported: ${prefix.format}`);
          }
        }
        throw new Error("Array size not supported by Borsh");
      },
      visitBooleanType(booleanType) {
        const resolvedSize = (0, import_nodes3.resolveNestedTypeNode)(booleanType.size);
        if (resolvedSize.format === "u8" && resolvedSize.endian === "le") {
          return {
            imports: new ImportMap(),
            nestedStructs: [],
            type: "bool"
          };
        }
        throw new Error("Bool size not supported by Borsh");
      },
      visitBytesType(_bytesType, { self }) {
        let arraySize = (0, import_nodes3.remainderCountNode)();
        if (typeof parentSize === "number") {
          arraySize = (0, import_nodes3.fixedCountNode)(parentSize);
        } else if (parentSize && typeof parentSize === "object") {
          arraySize = (0, import_nodes3.prefixedCountNode)(parentSize);
        }
        const arrayType = (0, import_nodes3.arrayTypeNode)((0, import_nodes3.numberTypeNode)("u8"), arraySize);
        return (0, import_visitors_core.visit)(arrayType, self);
      },
      visitDefinedType(definedType, { self }) {
        parentName = (0, import_nodes3.pascalCase)(definedType.name);
        const manifest = (0, import_visitors_core.visit)(definedType.type, self);
        const traits = getTraitsFromNode2(definedType);
        manifest.imports.mergeWith(traits.imports);
        parentName = null;
        const renderedType = (0, import_nodes3.isNode)(definedType.type, ["enumTypeNode", "structTypeNode"]) ? manifest.type : `pub type ${(0, import_nodes3.pascalCase)(definedType.name)} = ${manifest.type};`;
        return { ...manifest, type: `${traits.render}${renderedType}` };
      },
      visitDefinedTypeLink(node) {
        const pascalCaseDefinedType = (0, import_nodes3.pascalCase)(node.name);
        const importFrom = getImportFrom(node);
        return {
          imports: new ImportMap().add(`${importFrom}::${pascalCaseDefinedType}`),
          nestedStructs: [],
          type: pascalCaseDefinedType
        };
      },
      visitEnumEmptyVariantType(enumEmptyVariantType) {
        const name = (0, import_nodes3.pascalCase)(enumEmptyVariantType.name);
        return {
          imports: new ImportMap(),
          nestedStructs: [],
          type: `${name},`
        };
      },
      visitEnumStructVariantType(enumStructVariantType, { self }) {
        const name = (0, import_nodes3.pascalCase)(enumStructVariantType.name);
        const originalParentName = parentName;
        if (!originalParentName) {
          throw new Error("Enum struct variant type must have a parent name.");
        }
        inlineStruct = true;
        parentName = (0, import_nodes3.pascalCase)(originalParentName) + name;
        const typeManifest = (0, import_visitors_core.visit)(enumStructVariantType.struct, self);
        inlineStruct = false;
        parentName = originalParentName;
        return {
          ...typeManifest,
          type: `${name} ${typeManifest.type},`
        };
      },
      visitEnumTupleVariantType(enumTupleVariantType, { self }) {
        const name = (0, import_nodes3.pascalCase)(enumTupleVariantType.name);
        const originalParentName = parentName;
        if (!originalParentName) {
          throw new Error("Enum struct variant type must have a parent name.");
        }
        parentName = (0, import_nodes3.pascalCase)(originalParentName) + name;
        const childManifest = (0, import_visitors_core.visit)(enumTupleVariantType.tuple, self);
        parentName = originalParentName;
        let derive = "";
        if (childManifest.type === "(Pubkey)") {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::DisplayFromStr>"))]\n';
        } else if (childManifest.type === "(Vec<Pubkey>)") {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_with::As::<Vec<serde_with::DisplayFromStr>>"))]\n';
        }
        return {
          ...childManifest,
          type: `${derive}${name}${childManifest.type},`
        };
      },
      visitEnumType(enumType, { self }) {
        const originalParentName = parentName;
        if (!originalParentName) {
          throw new Error("Enum type must have a parent name.");
        }
        const variants = enumType.variants.map((variant) => (0, import_visitors_core.visit)(variant, self));
        const variantNames = variants.map((variant) => variant.type).join("\n");
        const mergedManifest = mergeManifests(variants);
        return {
          ...mergedManifest,
          type: `pub enum ${(0, import_nodes3.pascalCase)(originalParentName)} {
${variantNames}
}`
        };
      },
      visitFixedSizeType(fixedSizeType, { self }) {
        parentSize = fixedSizeType.size;
        const manifest = (0, import_visitors_core.visit)(fixedSizeType.type, self);
        parentSize = null;
        return manifest;
      },
      visitMapType(mapType, { self }) {
        const key = (0, import_visitors_core.visit)(mapType.key, self);
        const value = (0, import_visitors_core.visit)(mapType.value, self);
        const mergedManifest = mergeManifests([key, value]);
        mergedManifest.imports.add("std::collections::HashMap");
        return {
          ...mergedManifest,
          type: `HashMap<${key.type}, ${value.type}>`
        };
      },
      visitNumberType(numberType) {
        if (numberType.endian !== "le") {
          throw new Error("Number endianness not supported by Borsh");
        }
        if (numberType.format === "shortU16") {
          return {
            imports: new ImportMap().add("solana_program::short_vec::ShortU16"),
            nestedStructs: [],
            type: "ShortU16"
          };
        }
        return {
          imports: new ImportMap(),
          nestedStructs: [],
          type: numberType.format
        };
      },
      visitOptionType(optionType, { self }) {
        const childManifest = (0, import_visitors_core.visit)(optionType.item, self);
        const optionPrefix = (0, import_nodes3.resolveNestedTypeNode)(optionType.prefix);
        if (optionPrefix.format === "u8" && optionPrefix.endian === "le") {
          return {
            ...childManifest,
            type: `Option<${childManifest.type}>`
          };
        }
        throw new Error("Option size not supported by Borsh");
      },
      visitPublicKeyType() {
        return {
          imports: new ImportMap().add("solana_program::pubkey::Pubkey"),
          nestedStructs: [],
          type: "Pubkey"
        };
      },
      visitRemainderOptionType(node) {
        throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });
      },
      visitSetType(setType, { self }) {
        const childManifest = (0, import_visitors_core.visit)(setType.item, self);
        childManifest.imports.add("std::collections::HashSet");
        return {
          ...childManifest,
          type: `HashSet<${childManifest.type}>`
        };
      },
      visitSizePrefixType(sizePrefixType, { self }) {
        parentSize = (0, import_nodes3.resolveNestedTypeNode)(sizePrefixType.prefix);
        const manifest = (0, import_visitors_core.visit)(sizePrefixType.type, self);
        parentSize = null;
        return manifest;
      },
      visitStringType() {
        if (!parentSize) {
          return {
            imports: new ImportMap().add(`kaigan::types::RemainderStr`),
            nestedStructs: [],
            type: `RemainderStr`
          };
        }
        if (typeof parentSize === "number") {
          return {
            imports: new ImportMap(),
            nestedStructs: [],
            type: `[u8; ${parentSize}]`
          };
        }
        if ((0, import_nodes3.isNode)(parentSize, "numberTypeNode") && parentSize.endian === "le") {
          switch (parentSize.format) {
            case "u32":
              return {
                imports: new ImportMap(),
                nestedStructs: [],
                type: "String"
              };
            case "u8":
            case "u16":
            case "u64": {
              const prefix = parentSize.format.toUpperCase();
              return {
                imports: new ImportMap().add(`kaigan::types::${prefix}PrefixString`),
                nestedStructs: [],
                type: `${prefix}PrefixString`
              };
            }
            default:
              throw new Error(`'String size not supported: ${parentSize.format}`);
          }
        }
        throw new Error("String size not supported by Borsh");
      },
      visitStructFieldType(structFieldType, { self }) {
        const originalParentName = parentName;
        const originalInlineStruct = inlineStruct;
        const originalNestedStruct = nestedStruct;
        if (!originalParentName) {
          throw new Error("Struct field type must have a parent name.");
        }
        parentName = (0, import_nodes3.pascalCase)(originalParentName) + (0, import_nodes3.pascalCase)(structFieldType.name);
        nestedStruct = true;
        inlineStruct = false;
        const fieldManifest = (0, import_visitors_core.visit)(structFieldType.type, self);
        parentName = originalParentName;
        inlineStruct = originalInlineStruct;
        nestedStruct = originalNestedStruct;
        const fieldName = (0, import_nodes3.snakeCase)(structFieldType.name);
        const docblock = rustDocblock((0, import_nodes3.parseDocs)(structFieldType.docs));
        const resolvedNestedType = (0, import_nodes3.resolveNestedTypeNode)(structFieldType.type);
        let derive = "";
        if (fieldManifest.type === "Pubkey") {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::DisplayFromStr>"))]\n';
        } else if (fieldManifest.type === "Vec<Pubkey>") {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_with::As::<Vec<serde_with::DisplayFromStr>>"))]\n';
        } else if ((0, import_nodes3.isNode)(resolvedNestedType, "arrayTypeNode") && (0, import_nodes3.isNode)(resolvedNestedType.count, "fixedCountNode") && resolvedNestedType.count.value > 32) {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_big_array::BigArray"))]\n';
        } else if ((0, import_nodes3.isNode)(resolvedNestedType, ["bytesTypeNode", "stringTypeNode"]) && (0, import_nodes3.isNode)(structFieldType.type, "fixedSizeTypeNode") && structFieldType.type.size > 32) {
          derive = '#[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::Bytes>"))]\n';
        }
        return {
          ...fieldManifest,
          type: inlineStruct ? `${docblock}${derive}${fieldName}: ${fieldManifest.type},` : `${docblock}${derive}pub ${fieldName}: ${fieldManifest.type},`
        };
      },
      visitStructType(structType, { self }) {
        const originalParentName = parentName;
        if (!originalParentName) {
          throw new Error("Struct type must have a parent name.");
        }
        const fields = structType.fields.map((field) => (0, import_visitors_core.visit)(field, self));
        const fieldTypes = fields.map((field) => field.type).join("\n");
        const mergedManifest = mergeManifests(fields);
        if (nestedStruct) {
          const nestedTraits = getTraitsFromNode2(
            (0, import_nodes3.definedTypeNode)({ name: originalParentName, type: structType })
          );
          mergedManifest.imports.mergeWith(nestedTraits.imports);
          return {
            ...mergedManifest,
            nestedStructs: [
              ...mergedManifest.nestedStructs,
              `${nestedTraits.render}pub struct ${(0, import_nodes3.pascalCase)(originalParentName)} {
${fieldTypes}
}`
            ],
            type: (0, import_nodes3.pascalCase)(originalParentName)
          };
        }
        if (inlineStruct) {
          return { ...mergedManifest, type: `{
${fieldTypes}
}` };
        }
        return {
          ...mergedManifest,
          type: `pub struct ${(0, import_nodes3.pascalCase)(originalParentName)} {
${fieldTypes}
}`
        };
      },
      visitTupleType(tupleType, { self }) {
        const items = tupleType.items.map((item) => (0, import_visitors_core.visit)(item, self));
        const mergedManifest = mergeManifests(items);
        return {
          ...mergedManifest,
          type: `(${items.map((item) => item.type).join(", ")})`
        };
      },
      visitZeroableOptionType(node) {
        throw new import_errors2.CodamaError(import_errors2.CODAMA_ERROR__RENDERERS__UNSUPPORTED_NODE, { kind: node.kind, node });
      }
    })
  );
}
function mergeManifests(manifests) {
  return {
    imports: new ImportMap().mergeWith(...manifests.map((td) => td.imports)),
    nestedStructs: manifests.flatMap((m) => m.nestedStructs)
  };
}

// src/renderValueNodeVisitor.ts
var import_nodes4 = require("@codama/nodes");
var import_visitors_core2 = require("@codama/visitors-core");
function renderValueNode(value, getImportFrom, useStr = false) {
  return (0, import_visitors_core2.visit)(value, renderValueNodeVisitor(getImportFrom, useStr));
}
function renderValueNodeVisitor(getImportFrom, useStr = false) {
  return {
    visitArrayValue(node) {
      const list = node.items.map((v) => (0, import_visitors_core2.visit)(v, this));
      return {
        imports: new ImportMap().mergeWith(...list.map((c) => c.imports)),
        render: `[${list.map((c) => c.render).join(", ")}]`
      };
    },
    visitBooleanValue(node) {
      return {
        imports: new ImportMap(),
        render: JSON.stringify(node.boolean)
      };
    },
    visitBytesValue(node) {
      const bytes = getBytesFromBytesValueNode(node);
      const numbers = Array.from(bytes).map(import_nodes4.numberValueNode);
      return (0, import_visitors_core2.visit)((0, import_nodes4.arrayValueNode)(numbers), this);
    },
    visitConstantValue(node) {
      if ((0, import_nodes4.isNode)(node.value, "bytesValueNode")) {
        return (0, import_visitors_core2.visit)(node.value, this);
      }
      if ((0, import_nodes4.isNode)(node.type, "stringTypeNode") && (0, import_nodes4.isNode)(node.value, "stringValueNode")) {
        return (0, import_visitors_core2.visit)((0, import_nodes4.bytesValueNode)(node.type.encoding, node.value.string), this);
      }
      if ((0, import_nodes4.isNode)(node.type, "numberTypeNode") && (0, import_nodes4.isNode)(node.value, "numberValueNode")) {
        const numberManifest = (0, import_visitors_core2.visit)(node.value, this);
        const { format, endian } = node.type;
        const byteFunction = endian === "le" ? "to_le_bytes" : "to_be_bytes";
        numberManifest.render = `${numberManifest.render}${format}.${byteFunction}()`;
        return numberManifest;
      }
      throw new Error("Unsupported constant value type.");
    },
    visitEnumValue(node) {
      const imports = new ImportMap();
      const enumName = (0, import_nodes4.pascalCase)(node.enum.name);
      const variantName = (0, import_nodes4.pascalCase)(node.variant);
      const importFrom = getImportFrom(node.enum);
      imports.add(`${importFrom}::${enumName}`);
      if (!node.value) {
        return { imports, render: `${enumName}::${variantName}` };
      }
      const enumValue = (0, import_visitors_core2.visit)(node.value, this);
      const fields = enumValue.render;
      return {
        imports: imports.mergeWith(enumValue.imports),
        render: `${enumName}::${variantName} ${fields}`
      };
    },
    visitMapEntryValue(node) {
      const mapKey = (0, import_visitors_core2.visit)(node.key, this);
      const mapValue = (0, import_visitors_core2.visit)(node.value, this);
      return {
        imports: mapKey.imports.mergeWith(mapValue.imports),
        render: `[${mapKey.render}, ${mapValue.render}]`
      };
    },
    visitMapValue(node) {
      const map = node.entries.map((entry) => (0, import_visitors_core2.visit)(entry, this));
      const imports = new ImportMap().add("std::collection::HashMap");
      return {
        imports: imports.mergeWith(...map.map((c) => c.imports)),
        render: `HashMap::from([${map.map((c) => c.render).join(", ")}])`
      };
    },
    visitNoneValue() {
      return {
        imports: new ImportMap(),
        render: "None"
      };
    },
    visitNumberValue(node) {
      return {
        imports: new ImportMap(),
        render: node.number.toString()
      };
    },
    visitPublicKeyValue(node) {
      return {
        imports: new ImportMap().add("solana_program::pubkey"),
        render: `pubkey!("${node.publicKey}")`
      };
    },
    visitSetValue(node) {
      const set = node.items.map((v) => (0, import_visitors_core2.visit)(v, this));
      const imports = new ImportMap().add("std::collection::HashSet");
      return {
        imports: imports.mergeWith(...set.map((c) => c.imports)),
        render: `HashSet::from([${set.map((c) => c.render).join(", ")}])`
      };
    },
    visitSomeValue(node) {
      const child = (0, import_visitors_core2.visit)(node.value, this);
      return {
        ...child,
        render: `Some(${child.render})`
      };
    },
    visitStringValue(node) {
      return {
        imports: new ImportMap(),
        render: useStr ? `${JSON.stringify(node.string)}` : `String::from(${JSON.stringify(node.string)})`
      };
    },
    visitStructFieldValue(node) {
      const structValue = (0, import_visitors_core2.visit)(node.value, this);
      return {
        imports: structValue.imports,
        render: `${node.name}: ${structValue.render}`
      };
    },
    visitStructValue(node) {
      const struct = node.fields.map((field) => (0, import_visitors_core2.visit)(field, this));
      return {
        imports: new ImportMap().mergeWith(...struct.map((c) => c.imports)),
        render: `{ ${struct.map((c) => c.render).join(", ")} }`
      };
    },
    visitTupleValue(node) {
      const tuple = node.items.map((v) => (0, import_visitors_core2.visit)(v, this));
      return {
        imports: new ImportMap().mergeWith(...tuple.map((c) => c.imports)),
        render: `(${tuple.map((c) => c.render).join(", ")})`
      };
    }
  };
}

// src/getRenderMapVisitor.ts
function getRenderMapVisitor(options = {}) {
  const linkables = new import_visitors_core3.LinkableDictionary();
  const stack = new import_visitors_core3.NodeStack();
  let program = null;
  const renderParentInstructions = options.renderParentInstructions ?? false;
  const dependencyMap = options.dependencyMap ?? {};
  const getImportFrom = getImportFromFactory(options.linkOverrides ?? {});
  const getTraitsFromNode2 = getTraitsFromNodeFactory(options.traitOptions);
  const typeManifestVisitor = getTypeManifestVisitor({ getImportFrom, getTraitsFromNode: getTraitsFromNode2 });
  const anchorTraits = options.anchorTraits ?? true;
  return (0, import_visitors_core3.pipe)(
    (0, import_visitors_core3.staticVisitor)(() => new import_renderers_core.RenderMap(), {
      keys: ["rootNode", "programNode", "instructionNode", "accountNode", "definedTypeNode"]
    }),
    (v) => (0, import_visitors_core3.extendVisitor)(v, {
      visitAccount(node) {
        const typeManifest = (0, import_visitors_core3.visit)(node, typeManifestVisitor);
        const seedsImports = new ImportMap();
        const pda = node.pda ? linkables.get([...stack.getPath(), node.pda]) : void 0;
        const pdaSeeds = pda?.seeds ?? [];
        const seeds = pdaSeeds.map((seed) => {
          if ((0, import_nodes5.isNode)(seed, "variablePdaSeedNode")) {
            const seedManifest2 = (0, import_visitors_core3.visit)(seed.type, typeManifestVisitor);
            seedsImports.mergeWith(seedManifest2.imports);
            const resolvedType2 = (0, import_nodes5.resolveNestedTypeNode)(seed.type);
            return { ...seed, resolvedType: resolvedType2, typeManifest: seedManifest2 };
          }
          if ((0, import_nodes5.isNode)(seed.value, "programIdValueNode")) {
            return seed;
          }
          const seedManifest = (0, import_visitors_core3.visit)(seed.type, typeManifestVisitor);
          const valueManifest = renderValueNode(seed.value, getImportFrom, true);
          seedsImports.mergeWith(valueManifest.imports);
          const resolvedType = (0, import_nodes5.resolveNestedTypeNode)(seed.type);
          return { ...seed, resolvedType, typeManifest: seedManifest, valueManifest };
        });
        const hasVariableSeeds = pdaSeeds.filter((0, import_nodes5.isNodeFilter)("variablePdaSeedNode")).length > 0;
        const constantSeeds = seeds.filter((0, import_nodes5.isNodeFilter)("constantPdaSeedNode")).filter((seed) => !(0, import_nodes5.isNode)(seed.value, "programIdValueNode"));
        const { imports } = typeManifest;
        if (hasVariableSeeds) {
          imports.mergeWith(seedsImports);
        }
        return new import_renderers_core.RenderMap().add(
          `accounts/${(0, import_nodes5.snakeCase)(node.name)}.rs`,
          render("accountsPage.njk", {
            account: node,
            anchorTraits,
            constantSeeds,
            hasVariableSeeds,
            imports: imports.remove(`generatedAccounts::${(0, import_nodes5.pascalCase)(node.name)}`).toString(dependencyMap),
            pda,
            program,
            seeds,
            typeManifest
          })
        );
      },
      visitDefinedType(node) {
        const typeManifest = (0, import_visitors_core3.visit)(node, typeManifestVisitor);
        const imports = new ImportMap().mergeWithManifest(typeManifest);
        return new import_renderers_core.RenderMap().add(
          `types/${(0, import_nodes5.snakeCase)(node.name)}.rs`,
          render("definedTypesPage.njk", {
            definedType: node,
            imports: imports.remove(`generatedTypes::${(0, import_nodes5.pascalCase)(node.name)}`).toString(dependencyMap),
            typeManifest
          })
        );
      },
      visitInstruction(node) {
        const imports = new ImportMap();
        const accountsAndArgsConflicts = getConflictsForInstructionAccountsAndArgs(node);
        if (accountsAndArgsConflicts.length > 0) {
          (0, import_errors3.logWarn)(
            `[Rust] Accounts and args of instruction [${node.name}] have the following conflicting attributes [${accountsAndArgsConflicts.join(", ")}]. Thus, the conflicting arguments will be suffixed with "_arg". You may want to rename the conflicting attributes.`
          );
        }
        const instructionArgs = [];
        let hasArgs = false;
        let hasOptional = false;
        node.arguments.forEach((argument) => {
          const argumentVisitor = getTypeManifestVisitor({
            getImportFrom,
            getTraitsFromNode: getTraitsFromNode2,
            nestedStruct: true,
            parentName: `${(0, import_nodes5.pascalCase)(node.name)}InstructionData`
          });
          const manifest = (0, import_visitors_core3.visit)(argument.type, argumentVisitor);
          imports.mergeWith(manifest.imports);
          const innerOptionType = (0, import_nodes5.isNode)(argument.type, "optionTypeNode") ? manifest.type.slice("Option<".length, -1) : null;
          const hasDefaultValue = !!argument.defaultValue && (0, import_nodes5.isNode)(argument.defaultValue, import_nodes5.VALUE_NODES);
          let renderValue = null;
          if (hasDefaultValue) {
            const { imports: argImports, render: value } = renderValueNode(
              argument.defaultValue,
              getImportFrom
            );
            imports.mergeWith(argImports);
            renderValue = value;
          }
          hasArgs = hasArgs || argument.defaultValueStrategy !== "omitted";
          hasOptional = hasOptional || hasDefaultValue && argument.defaultValueStrategy !== "omitted";
          const name = accountsAndArgsConflicts.includes(argument.name) ? `${argument.name}_arg` : argument.name;
          instructionArgs.push({
            default: hasDefaultValue && argument.defaultValueStrategy === "omitted",
            innerOptionType,
            name,
            optional: hasDefaultValue && argument.defaultValueStrategy !== "omitted",
            type: manifest.type,
            value: renderValue
          });
        });
        const struct = (0, import_nodes5.structTypeNodeFromInstructionArgumentNodes)(node.arguments);
        const structVisitor = getTypeManifestVisitor({
          getImportFrom,
          getTraitsFromNode: getTraitsFromNode2,
          parentName: `${(0, import_nodes5.pascalCase)(node.name)}InstructionData`
        });
        const typeManifest = (0, import_visitors_core3.visit)(struct, structVisitor);
        const dataTraits = getTraitsFromNode2(node);
        imports.mergeWith(dataTraits.imports);
        return new import_renderers_core.RenderMap().add(
          `instructions/${(0, import_nodes5.snakeCase)(node.name)}.rs`,
          render("instructionsPage.njk", {
            dataTraits: dataTraits.render,
            hasArgs,
            hasOptional,
            imports: imports.remove(`generatedInstructions::${(0, import_nodes5.pascalCase)(node.name)}`).toString(dependencyMap),
            instruction: node,
            instructionArgs,
            program,
            typeManifest
          })
        );
      },
      visitProgram(node, { self }) {
        program = node;
        const renderMap = new import_renderers_core.RenderMap().mergeWith(...node.accounts.map((account) => (0, import_visitors_core3.visit)(account, self))).mergeWith(...node.definedTypes.map((type) => (0, import_visitors_core3.visit)(type, self))).mergeWith(
          ...(0, import_nodes5.getAllInstructionsWithSubs)(node, {
            leavesOnly: !renderParentInstructions
          }).map((ix) => (0, import_visitors_core3.visit)(ix, self))
        );
        if (node.errors.length > 0) {
          renderMap.add(
            `errors/${(0, import_nodes5.snakeCase)(node.name)}.rs`,
            render("errorsPage.njk", {
              errors: node.errors,
              imports: new ImportMap().toString(dependencyMap),
              program: node
            })
          );
        }
        program = null;
        return renderMap;
      },
      visitRoot(node, { self }) {
        const programsToExport = (0, import_nodes5.getAllPrograms)(node);
        const accountsToExport = (0, import_nodes5.getAllAccounts)(node);
        const instructionsToExport = (0, import_nodes5.getAllInstructionsWithSubs)(node, {
          leavesOnly: !renderParentInstructions
        });
        const definedTypesToExport = (0, import_nodes5.getAllDefinedTypes)(node);
        const hasAnythingToExport = programsToExport.length > 0 || accountsToExport.length > 0 || instructionsToExport.length > 0 || definedTypesToExport.length > 0;
        const ctx = {
          accountsToExport,
          definedTypesToExport,
          hasAnythingToExport,
          instructionsToExport,
          programsToExport,
          root: node
        };
        const map = new import_renderers_core.RenderMap();
        if (accountsToExport.length > 0) {
          map.add("shared.rs", render("sharedPage.njk", ctx));
        }
        if (programsToExport.length > 0) {
          map.add("programs.rs", render("programsMod.njk", ctx)).add(
            "errors/mod.rs",
            render("errorsMod.njk", ctx)
          );
        }
        if (accountsToExport.length > 0) {
          map.add("accounts/mod.rs", render("accountsMod.njk", ctx));
        }
        if (instructionsToExport.length > 0) {
          map.add("instructions/mod.rs", render("instructionsMod.njk", ctx));
        }
        if (definedTypesToExport.length > 0) {
          map.add("types/mod.rs", render("definedTypesMod.njk", ctx));
        }
        return map.add("mod.rs", render("rootMod.njk", ctx)).mergeWith(...(0, import_nodes5.getAllPrograms)(node).map((p) => (0, import_visitors_core3.visit)(p, self)));
      }
    }),
    (v) => (0, import_visitors_core3.recordNodeStackVisitor)(v, stack),
    (v) => (0, import_visitors_core3.recordLinkablesOnFirstVisitVisitor)(v, linkables)
  );
}
function getConflictsForInstructionAccountsAndArgs(instruction) {
  const allNames = [
    ...instruction.accounts.map((account) => account.name),
    ...instruction.arguments.map((argument) => argument.name)
  ];
  const duplicates = allNames.filter((e, i, a) => a.indexOf(e) !== i);
  return [...new Set(duplicates)];
}

// src/renderVisitor.ts
var import_errors4 = require("@codama/errors");
var import_renderers_core2 = require("@codama/renderers-core");
var import_visitors_core4 = require("@codama/visitors-core");
var import_child_process = require("child_process");
function renderVisitor(path, options = {}) {
  return (0, import_visitors_core4.rootNodeVisitor)((root) => {
    if (options.deleteFolderBeforeRendering ?? true) {
      (0, import_renderers_core2.deleteDirectory)(path);
    }
    (0, import_visitors_core4.visit)(root, (0, import_renderers_core2.writeRenderMapVisitor)(getRenderMapVisitor(options), path));
    if (options.formatCode) {
      if (options.crateFolder) {
        const toolchain = options.toolchain ?? "+stable";
        runFormatter("cargo", [toolchain, "fmt", "--manifest-path", `${options.crateFolder}/Cargo.toml`]);
      } else {
        (0, import_errors4.logWarn)("No crate folder specified, skipping formatting.");
      }
    }
  });
}
function runFormatter(cmd, args) {
  const { stdout, stderr, error } = (0, import_child_process.spawnSync)(cmd, args);
  if (error?.message?.includes("ENOENT")) {
    (0, import_errors4.logWarn)(`Could not find ${cmd}, skipping formatting.`);
    return;
  }
  if (stdout.length > 0) {
    (0, import_errors4.logWarn)(`(cargo-fmt) ${stdout ? stdout?.toString() : error}`);
  }
  if (stderr.length > 0) {
    (0, import_errors4.logError)(`(cargo-fmt) ${stderr ? stderr.toString() : error}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ImportMap,
  getRenderMapVisitor,
  getTypeManifestVisitor,
  renderVisitor
});
//# sourceMappingURL=index.node.cjs.map